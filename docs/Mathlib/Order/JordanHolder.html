<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="stylesheet" href="../.././src/pygments.css"></link><link rel="shortcut icon" href="../.././favicon.ico"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Order.JordanHolder</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Order.JordanHolder";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Order</span>.<span class="name">JordanHolder</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;
            <button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/Order/Lattice.html">Mathlib.Order.Lattice</a></li><li><a href="../.././Mathlib/Data/Fintype/Card.html">Mathlib.Data.Fintype.Card</a></li><li><a href="../.././Mathlib/Data/List/Sort.html">Mathlib.Data.List.Sort</a></li><li><a href="../.././Mathlib/Logic/Equiv/Fin.html">Mathlib.Logic.Equiv.Fin</a></li><li><a href="../.././Mathlib/Logic/Equiv/Functor.html">Mathlib.Logic.Equiv.Functor</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Order.JordanHolder" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#JordanHolderLattice"><span class="name">JordanHolderLattice</span></a></div><div class="nav_link"><a class="break_within" href="#JordanHolderLattice.isMaximal_inf_right_of_isMaximal_sup"><span class="name">JordanHolderLattice</span>.<span class="name">isMaximal_inf_right_of_isMaximal_sup</span></a></div><div class="nav_link"><a class="break_within" href="#JordanHolderLattice.isMaximal_of_eq_inf"><span class="name">JordanHolderLattice</span>.<span class="name">isMaximal_of_eq_inf</span></a></div><div class="nav_link"><a class="break_within" href="#JordanHolderLattice.second_iso_of_eq"><span class="name">JordanHolderLattice</span>.<span class="name">second_iso_of_eq</span></a></div><div class="nav_link"><a class="break_within" href="#JordanHolderLattice.IsMaximal.iso_refl"><span class="name">JordanHolderLattice</span>.<span class="name">IsMaximal</span>.<span class="name">iso_refl</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries"><span class="name">CompositionSeries</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.coeFun"><span class="name">CompositionSeries</span>.<span class="name">coeFun</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.inhabited"><span class="name">CompositionSeries</span>.<span class="name">inhabited</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.step"><span class="name">CompositionSeries</span>.<span class="name">step</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.coeFn_mk"><span class="name">CompositionSeries</span>.<span class="name">coeFn_mk</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.lt_succ"><span class="name">CompositionSeries</span>.<span class="name">lt_succ</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.strictMono"><span class="name">CompositionSeries</span>.<span class="name">strictMono</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.injective"><span class="name">CompositionSeries</span>.<span class="name">injective</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.inj"><span class="name">CompositionSeries</span>.<span class="name">inj</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.membership"><span class="name">CompositionSeries</span>.<span class="name">membership</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.mem_def"><span class="name">CompositionSeries</span>.<span class="name">mem_def</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.total"><span class="name">CompositionSeries</span>.<span class="name">total</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.toList"><span class="name">CompositionSeries</span>.<span class="name">toList</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.ext_fun"><span class="name">CompositionSeries</span>.<span class="name">ext_fun</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.length_toList"><span class="name">CompositionSeries</span>.<span class="name">length_toList</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.toList_ne_nil"><span class="name">CompositionSeries</span>.<span class="name">toList_ne_nil</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.toList_injective"><span class="name">CompositionSeries</span>.<span class="name">toList_injective</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.chain'_toList"><span class="name">CompositionSeries</span>.<span class="name">chain'_toList</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.toList_sorted"><span class="name">CompositionSeries</span>.<span class="name">toList_sorted</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.toList_nodup"><span class="name">CompositionSeries</span>.<span class="name">toList_nodup</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.mem_toList"><span class="name">CompositionSeries</span>.<span class="name">mem_toList</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.ofList"><span class="name">CompositionSeries</span>.<span class="name">ofList</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.length_ofList"><span class="name">CompositionSeries</span>.<span class="name">length_ofList</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.ofList_toList"><span class="name">CompositionSeries</span>.<span class="name">ofList_toList</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.ofList_toList'"><span class="name">CompositionSeries</span>.<span class="name">ofList_toList'</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.toList_ofList"><span class="name">CompositionSeries</span>.<span class="name">toList_ofList</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.ext"><span class="name">CompositionSeries</span>.<span class="name">ext</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.top"><span class="name">CompositionSeries</span>.<span class="name">top</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.top_mem"><span class="name">CompositionSeries</span>.<span class="name">top_mem</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.le_top"><span class="name">CompositionSeries</span>.<span class="name">le_top</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.le_top_of_mem"><span class="name">CompositionSeries</span>.<span class="name">le_top_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.bot"><span class="name">CompositionSeries</span>.<span class="name">bot</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.bot_mem"><span class="name">CompositionSeries</span>.<span class="name">bot_mem</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.bot_le"><span class="name">CompositionSeries</span>.<span class="name">bot_le</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.bot_le_of_mem"><span class="name">CompositionSeries</span>.<span class="name">bot_le_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.length_pos_of_mem_ne"><span class="name">CompositionSeries</span>.<span class="name">length_pos_of_mem_ne</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.forall_mem_eq_of_length_eq_zero"><span class="name">CompositionSeries</span>.<span class="name">forall_mem_eq_of_length_eq_zero</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.eraseTop_series"><span class="name">CompositionSeries</span>.<span class="name">eraseTop_series</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.eraseTop_length"><span class="name">CompositionSeries</span>.<span class="name">eraseTop_length</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.eraseTop"><span class="name">CompositionSeries</span>.<span class="name">eraseTop</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.top_eraseTop"><span class="name">CompositionSeries</span>.<span class="name">top_eraseTop</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.eraseTop_top_le"><span class="name">CompositionSeries</span>.<span class="name">eraseTop_top_le</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.bot_eraseTop"><span class="name">CompositionSeries</span>.<span class="name">bot_eraseTop</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.mem_eraseTop_of_ne_of_mem"><span class="name">CompositionSeries</span>.<span class="name">mem_eraseTop_of_ne_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.mem_eraseTop"><span class="name">CompositionSeries</span>.<span class="name">mem_eraseTop</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.lt_top_of_mem_eraseTop"><span class="name">CompositionSeries</span>.<span class="name">lt_top_of_mem_eraseTop</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.isMaximal_eraseTop_top"><span class="name">CompositionSeries</span>.<span class="name">isMaximal_eraseTop_top</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.append_castAdd_aux"><span class="name">CompositionSeries</span>.<span class="name">append_castAdd_aux</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.append_succ_castAdd_aux"><span class="name">CompositionSeries</span>.<span class="name">append_succ_castAdd_aux</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.append_natAdd_aux"><span class="name">CompositionSeries</span>.<span class="name">append_natAdd_aux</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.append_succ_natAdd_aux"><span class="name">CompositionSeries</span>.<span class="name">append_succ_natAdd_aux</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.append_length"><span class="name">CompositionSeries</span>.<span class="name">append_length</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.append"><span class="name">CompositionSeries</span>.<span class="name">append</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.coe_append"><span class="name">CompositionSeries</span>.<span class="name">coe_append</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.append_castAdd"><span class="name">CompositionSeries</span>.<span class="name">append_castAdd</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.append_succ_castAdd"><span class="name">CompositionSeries</span>.<span class="name">append_succ_castAdd</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.append_natAdd"><span class="name">CompositionSeries</span>.<span class="name">append_natAdd</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.append_succ_natAdd"><span class="name">CompositionSeries</span>.<span class="name">append_succ_natAdd</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.snoc_length"><span class="name">CompositionSeries</span>.<span class="name">snoc_length</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.snoc"><span class="name">CompositionSeries</span>.<span class="name">snoc</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.top_snoc"><span class="name">CompositionSeries</span>.<span class="name">top_snoc</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.snoc_last"><span class="name">CompositionSeries</span>.<span class="name">snoc_last</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.snoc_castSucc"><span class="name">CompositionSeries</span>.<span class="name">snoc_castSucc</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.bot_snoc"><span class="name">CompositionSeries</span>.<span class="name">bot_snoc</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.mem_snoc"><span class="name">CompositionSeries</span>.<span class="name">mem_snoc</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.eq_snoc_eraseTop"><span class="name">CompositionSeries</span>.<span class="name">eq_snoc_eraseTop</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.snoc_eraseTop_top"><span class="name">CompositionSeries</span>.<span class="name">snoc_eraseTop_top</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.Equivalent"><span class="name">CompositionSeries</span>.<span class="name">Equivalent</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.Equivalent.refl"><span class="name">CompositionSeries</span>.<span class="name">Equivalent</span>.<span class="name">refl</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.Equivalent.symm"><span class="name">CompositionSeries</span>.<span class="name">Equivalent</span>.<span class="name">symm</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.Equivalent.trans"><span class="name">CompositionSeries</span>.<span class="name">Equivalent</span>.<span class="name">trans</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.Equivalent.append"><span class="name">CompositionSeries</span>.<span class="name">Equivalent</span>.<span class="name">append</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.Equivalent.snoc"><span class="name">CompositionSeries</span>.<span class="name">Equivalent</span>.<span class="name">snoc</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.Equivalent.length_eq"><span class="name">CompositionSeries</span>.<span class="name">Equivalent</span>.<span class="name">length_eq</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.Equivalent.snoc_snoc_swap"><span class="name">CompositionSeries</span>.<span class="name">Equivalent</span>.<span class="name">snoc_snoc_swap</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.length_eq_zero_of_bot_eq_bot_of_top_eq_top_of_length_eq_zero"><span class="name">CompositionSeries</span>.<span class="name">length_eq_zero_of_bot_eq_bot_of_top_eq_top_of_length_eq_zero</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.length_pos_of_bot_eq_bot_of_top_eq_top_of_length_pos"><span class="name">CompositionSeries</span>.<span class="name">length_pos_of_bot_eq_bot_of_top_eq_top_of_length_pos</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.eq_of_bot_eq_bot_of_top_eq_top_of_length_eq_zero"><span class="name">CompositionSeries</span>.<span class="name">eq_of_bot_eq_bot_of_top_eq_top_of_length_eq_zero</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.exists_top_eq_snoc_equivalant"><span class="name">CompositionSeries</span>.<span class="name">exists_top_eq_snoc_equivalant</span></a></div><div class="nav_link"><a class="break_within" href="#CompositionSeries.jordan_holder"><span class="name">CompositionSeries</span>.<span class="name">jordan_holder</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Jordan-Hölder-Theorem">Jordan-Hölder Theorem <a class="hover-link" href="#Jordan-Hölder-Theorem">#</a></h1><p>This file proves the Jordan Hölder theorem for a <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a></code>, a class also defined in
this file. Examples of <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a></code> include <code>Subgroup G</code> if <code>G</code> is a group, and
<code>Submodule R M</code> if <code>M</code> is an <code>R</code>-module. Using this approach the theorem need not be proved
separately for both groups and modules, the proof in this file can be applied to both.</p><h2 class="markdown-heading" id="Main-definitions">Main definitions <a class="hover-link" href="#Main-definitions">#</a></h2><p>The main definitions in this file are <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a></code> and <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a></code>,
and the relation <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">Equivalent</a></code> on <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a></code></p><p>A <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a></code> is the class for which the Jordan Hölder theorem is proved. A
Jordan Hölder lattice is a lattice equipped with a notion of maximality, <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">IsMaximal</a></code>, and a notion
of isomorphism of pairs <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">Iso</a></code>. In the example of subgroups of a group, <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">IsMaximal</a> H K</code> means that
<code>H</code> is a maximal normal subgroup of <code>K</code>, and <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">Iso</a> (H₁, K₁) (H₂, K₂)</code> means that the quotient
<code>H₁ / K₁</code> is isomorphic to the quotient <code>H₂ / K₂</code>. <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">Iso</a></code> must be symmetric and transitive and must
satisfy the second isomorphism theorem <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">Iso</a> (H, H ⊔ K) (H ⊓ K, K)</code>.</p><p>A <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> X</code> is a finite nonempty series of elements of the lattice <code>X</code> such that
each element is maximal inside the next. The length of a <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> X</code> is
one less than the number of elements in the series. Note that there is no stipulation
that a series start from the bottom of the lattice and finish at the top.
For a composition series <code>s</code>, <code>s.<a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">top</a></code> is the largest element of the series,
and <code>s.<a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot">bot</a></code> is the least element.</p><p>Two <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> X</code>, <code>s₁</code> and <code>s₂</code> are equivalent if there is a bijection
<code>e : <a href="../.././Init/Prelude.html#Fin">Fin</a> s₁.<a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.length">length</a> ≃ <a href="../.././Init/Prelude.html#Fin">Fin</a> s₂.<a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.length">length</a></code> such that for any <code>i</code>,
<code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">Iso</a> (s₁ i, s₁ i.succ) (s₂ (e i), s₂ (e i.succ))</code></p><h2 class="markdown-heading" id="Main-theorems">Main theorems <a class="hover-link" href="#Main-theorems">#</a></h2><p>The main theorem is <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.jordan_holder">CompositionSeries.jordan_holder</a></code>, which says that if two composition
series have the same least element and the same largest element,
then they are <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">Equivalent</a></code>.</p><h2 class="markdown-heading" id="TODO">TODO <a class="hover-link" href="#TODO">#</a></h2><p>Provide instances of <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a></code> for both submodules and subgroups, and potentially
for modular lattices.</p><p>It is not entirely clear how this should be done. Possibly there should be no global instances
of <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a></code>, and the instances should only be defined locally in order to prove
the Jordan-Hölder theorem for modules/groups and the API should be transferred because many of the
theorems in this file will have stronger versions for modules. There will also need to be an API for
mapping composition series across homomorphisms. It is also probably possible to
provide an instance of <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a></code> for any <code>ModularLattice</code>, and in this case the
Jordan-Hölder theorem will say that there is a well defined notion of length of a modular lattice.
However an instance of <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a></code> for a modular lattice will not be able to contain
the correct notion of isomorphism for modules, so a separate instance for modules will still be
required and this will clash with the instance for modular lattices, and so at least one of these
instances should not be a global instance.</p></div><div class="decl" id="JordanHolderLattice"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L81-L90">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice"><span class="name">JordanHolderLattice</span></a></span><span class="decl_args">
<span class="fn">(X : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> u</div></div><p>A <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a></code> is the class for which the Jordan Hölder theorem is proved. A
Jordan Hölder lattice is a lattice equipped with a notion of maximality, <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">IsMaximal</a></code>, and a notion
of isomorphism of pairs <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">Iso</a></code>. In the example of subgroups of a group, <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">IsMaximal</a> H K</code> means that
<code>H</code> is a maximal normal subgroup of <code>K</code>, and <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">Iso</a> (H₁, K₁) (H₂, K₂)</code> means that the quotient
<code>H₁ / K₁</code> is isomorphic to the quotient <code>H₂ / K₂</code>. <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">Iso</a></code> must be symmetric and transitive and must
satisfy the second isomorphism theorem <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">Iso</a> (H, H ⊔ K) (H ⊓ K, K)</code>.
Examples include <code>Subgroup G</code> if <code>G</code> is a group, and <code>Submodule R M</code> if <code>M</code> is an <code>R</code>-module.</p><ul class="structure_fields" id="JordanHolderLattice.mk"><li id="JordanHolderLattice.IsMaximal" class="structure_field"><div class="structure_field_info">IsMaximal : <span class="fn"><span class="fn">X</span> → <span class="fn">X</span> → <a href="../.././foundational_types.html">Prop</a></span></div></li><li id="JordanHolderLattice.lt_of_isMaximal" class="structure_field"><div class="structure_field_info">lt_of_isMaximal : <span class="fn">∀ {<span class="fn">x </span>y : <span class="fn">X</span>}, <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">y</span></span></span></span></div></li><li id="JordanHolderLattice.sup_eq_of_isMaximal" class="structure_field"><div class="structure_field_info">sup_eq_of_isMaximal : <span class="fn">∀ {<span class="fn">x </span>y z : <span class="fn">X</span>}, <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">x</span> <span class="fn">z</span></span> → <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">y</span> <span class="fn">z</span></span> → <span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span></span> → <span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Mathlib/Order/Notation.html#Sup.sup">⊔</a> <span class="fn">y</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">z</span></span></span></span></span></span></div></li><li id="JordanHolderLattice.isMaximal_inf_left_of_isMaximal_sup" class="structure_field"><div class="structure_field_info">isMaximal_inf_left_of_isMaximal_sup : <span class="fn">∀ {<span class="fn">x </span>y : <span class="fn">X</span>},
  <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">x</span> <span class="fn">(<span class="fn"><span class="fn">x</span> <a href="../.././Mathlib/Order/Notation.html#Sup.sup">⊔</a> <span class="fn">y</span></span>)</span></span> →
    <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">y</span> <span class="fn">(<span class="fn"><span class="fn">x</span> <a href="../.././Mathlib/Order/Notation.html#Sup.sup">⊔</a> <span class="fn">y</span></span>)</span></span> → <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">(<span class="fn"><span class="fn">x</span> <a href="../.././Mathlib/Order/Notation.html#Inf.inf">⊓</a> <span class="fn">y</span></span>)</span> <span class="fn">x</span></span></span></span></span></div></li><li id="JordanHolderLattice.Iso" class="structure_field"><div class="structure_field_info">Iso : <span class="fn"><span class="fn"><span class="fn">X</span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn">X</span></span> → <span class="fn"><span class="fn">X</span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn">X</span></span> → <a href="../.././foundational_types.html">Prop</a></span></div></li><li id="JordanHolderLattice.iso_symm" class="structure_field"><div class="structure_field_info">iso_symm : <span class="fn">∀ {<span class="fn">x </span>y : <span class="fn"><span class="fn">X</span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn">X</span></span>}, <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">JordanHolderLattice.Iso</a> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">JordanHolderLattice.Iso</a> <span class="fn">y</span> <span class="fn">x</span></span></span></span></div></li><li id="JordanHolderLattice.iso_trans" class="structure_field"><div class="structure_field_info">iso_trans : <span class="fn">∀ {<span class="fn">x </span>y z : <span class="fn"><span class="fn">X</span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn">X</span></span>}, <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">JordanHolderLattice.Iso</a> <span class="fn">x</span> <span class="fn">y</span></span> → <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">JordanHolderLattice.Iso</a> <span class="fn">y</span> <span class="fn">z</span></span> → <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">JordanHolderLattice.Iso</a> <span class="fn">x</span> <span class="fn">z</span></span></span></span></span></div></li><li id="JordanHolderLattice.second_iso" class="structure_field"><div class="structure_field_info">second_iso : <span class="fn">∀ {<span class="fn">x </span>y : <span class="fn">X</span>}, <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">x</span> <span class="fn">(<span class="fn"><span class="fn">x</span> <a href="../.././Mathlib/Order/Notation.html#Sup.sup">⊔</a> <span class="fn">y</span></span>)</span></span> → <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">JordanHolderLattice.Iso</a> <span class="fn">(<span class="fn">x</span>, <span class="fn"><span class="fn">x</span> <a href="../.././Mathlib/Order/Notation.html#Sup.sup">⊔</a> <span class="fn">y</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">x</span> <a href="../.././Mathlib/Order/Notation.html#Inf.inf">⊓</a> <span class="fn">y</span></span>, <span class="fn">y</span>)</span></span></span></span></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-JordanHolderLattice" class="instances-list"></ul></details></div></div><div class="decl" id="JordanHolderLattice.isMaximal_inf_right_of_isMaximal_sup"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L97-L101">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.isMaximal_inf_right_of_isMaximal_sup"><span class="name">JordanHolderLattice</span>.<span class="name">isMaximal_inf_right_of_isMaximal_sup</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">X</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">X</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hxz : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">x</span> <span class="fn">(<span class="fn"><span class="fn">x</span> <a href="../.././Mathlib/Order/Notation.html#Sup.sup">⊔</a> <span class="fn">y</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hyz : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">y</span> <span class="fn">(<span class="fn"><span class="fn">x</span> <a href="../.././Mathlib/Order/Notation.html#Sup.sup">⊔</a> <span class="fn">y</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">(<span class="fn"><span class="fn">x</span> <a href="../.././Mathlib/Order/Notation.html#Inf.inf">⊓</a> <span class="fn">y</span></span>)</span> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="JordanHolderLattice.isMaximal_of_eq_inf"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L104-L108">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.isMaximal_of_eq_inf"><span class="name">JordanHolderLattice</span>.<span class="name">isMaximal_of_eq_inf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">X</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">X</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">X</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">X</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(ha : <span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Mathlib/Order/Notation.html#Inf.inf">⊓</a> <span class="fn">y</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hxy : <span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hxb : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">x</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hyb : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">y</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">a</span> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="JordanHolderLattice.second_iso_of_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L111-L112">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.second_iso_of_eq"><span class="name">JordanHolderLattice</span>.<span class="name">second_iso_of_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">X</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">X</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">X</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">X</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hm : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">x</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ha : <span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Mathlib/Order/Notation.html#Sup.sup">⊔</a> <span class="fn">y</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hb : <span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Mathlib/Order/Notation.html#Inf.inf">⊓</a> <span class="fn">y</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">JordanHolderLattice.Iso</a> <span class="fn">(<span class="fn">x</span>, <span class="fn">a</span>)</span> <span class="fn">(<span class="fn">b</span>, <span class="fn">y</span>)</span></span></div></div></div></div><div class="decl" id="JordanHolderLattice.IsMaximal.iso_refl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L115-L117">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal.iso_refl"><span class="name">JordanHolderLattice</span>.<span class="name">IsMaximal</span>.<span class="name">iso_refl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">X</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">X</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">x</span> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">JordanHolderLattice.Iso</a> <span class="fn">(<span class="fn">x</span>, <span class="fn">y</span>)</span> <span class="fn">(<span class="fn">x</span>, <span class="fn">y</span>)</span></span></div></div></div></div><div class="decl" id="CompositionSeries"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L135-L138">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries"><span class="name">CompositionSeries</span></a></span><span class="decl_args">
<span class="fn">(X : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> u</div></div><p>A <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> X</code> is a finite nonempty series of elements of a
<code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a></code> such that each element is maximal inside the next. The length of a
<code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> X</code> is one less than the number of elements in the series.
Note that there is no stipulation that a series start from the bottom of the lattice and finish at
the top. For a composition series <code>s</code>, <code>s.<a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">top</a></code> is the largest element of the series,
and <code>s.<a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot">bot</a></code> is the least element.</p><ul class="structure_fields" id="CompositionSeries.mk"><li id="CompositionSeries.length" class="structure_field"><div class="structure_field_info">length : <a href="../.././Init/Prelude.html#Nat">ℕ</a></div></li><li id="CompositionSeries.series" class="structure_field"><div class="structure_field_info">series : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">self</span>.length</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></span>)</span></span> → <span class="fn">X</span></span></div></li><li id="CompositionSeries.step'" class="structure_field"><div class="structure_field_info">step' : <span class="fn">∀ (<span class="fn">i</span> : <span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn"><span class="fn">self</span>.length</span></span>),
  <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.series">CompositionSeries.series</a> <span class="fn">self</span> <span class="fn">(<span class="fn"><a href="../.././Std/Data/Fin/Basic.html#Fin.castSucc">Fin.castSucc</a> <span class="fn">i</span></span>)</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.series">CompositionSeries.series</a> <span class="fn">self</span> <span class="fn">(<span class="fn"><a href="../.././Init/Data/Fin/Basic.html#Fin.succ">Fin.succ</a> <span class="fn">i</span></span>)</span></span>)</span></span></span></div></li></ul><details id="instances-for-list-CompositionSeries" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CompositionSeries.coeFun"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L145-L146">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.coeFun"><span class="name">CompositionSeries</span>.<span class="name">coeFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Coe.html#CoeFun">CoeFun</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span> <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>) =&gt; <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">x</span>.length</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></span>)</span></span> → <span class="fn">X</span></span></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">CompositionSeries.coeFun</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">coe</span> := <span class="fn">CompositionSeries.series</span> }</span></span></li></ul></details></div></div><div class="decl" id="CompositionSeries.inhabited"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L149-L152">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.inhabited"><span class="name">CompositionSeries</span>.<span class="name">inhabited</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="CompositionSeries.step"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L155-L157">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.step"><span class="name">CompositionSeries</span>.<span class="name">step</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn"><span class="fn">s</span>.length</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.series">CompositionSeries.series</a> <span class="fn">s</span> <span class="fn">(<span class="fn"><a href="../.././Std/Data/Fin/Basic.html#Fin.castSucc">Fin.castSucc</a> <span class="fn">i</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.series">CompositionSeries.series</a> <span class="fn">s</span> <span class="fn">(<span class="fn"><a href="../.././Init/Data/Fin/Basic.html#Fin.succ">Fin.succ</a> <span class="fn">i</span></span>)</span></span>)</span></span></div></div></div></div><div class="decl" id="CompositionSeries.coeFn_mk"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L161-L163">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.coeFn_mk"><span class="name">CompositionSeries</span>.<span class="name">coeFn_mk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(length : <a href="../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(series : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">(<span class="fn"><span class="fn">length</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></span>)</span></span> → <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(step : <span class="fn">∀ (<span class="fn">i</span> : <span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">length</span></span>), <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">(<span class="fn"><span class="fn">series</span> <span class="fn">(<span class="fn"><a href="../.././Std/Data/Fin/Basic.html#Fin.castSucc">Fin.castSucc</a> <span class="fn">i</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">series</span> <span class="fn">(<span class="fn"><a href="../.././Init/Data/Fin/Basic.html#Fin.succ">Fin.succ</a> <span class="fn">i</span></span>)</span></span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">{ <span class="fn">length</span> := <span class="fn">length</span>, <span class="fn">series</span> := <span class="fn">series</span>, <span class="fn">step'</span> := <span class="fn">step</span> }</span>.series</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">series</span></span></div></div></div></div><div class="decl" id="CompositionSeries.lt_succ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L166-L168">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.lt_succ"><span class="name">CompositionSeries</span>.<span class="name">lt_succ</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn"><span class="fn">s</span>.length</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.series">CompositionSeries.series</a> <span class="fn">s</span> <span class="fn">(<span class="fn"><a href="../.././Std/Data/Fin/Basic.html#Fin.castSucc">Fin.castSucc</a> <span class="fn">i</span></span>)</span></span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.series">CompositionSeries.series</a> <span class="fn">s</span> <span class="fn">(<span class="fn"><a href="../.././Init/Data/Fin/Basic.html#Fin.succ">Fin.succ</a> <span class="fn">i</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.strictMono"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L171-L172">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.strictMono"><span class="name">CompositionSeries</span>.<span class="name">strictMono</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/Monotone/Basic.html#StrictMono">StrictMono</a> <span class="fn"><span class="fn">s</span>.series</span></span></div></div></div></div><div class="decl" id="CompositionSeries.injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L175-L176">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.injective"><span class="name">CompositionSeries</span>.<span class="name">injective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Init/Function.html#Function.Injective">Function.Injective</a> <span class="fn"><span class="fn">s</span>.series</span></span></div></div></div></div><div class="decl" id="CompositionSeries.inj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L180-L181">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.inj"><span class="name">CompositionSeries</span>.<span class="name">inj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn"><span class="fn">s</span>.length</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn"><span class="fn">s</span>.length</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.series">CompositionSeries.series</a> <span class="fn">s</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.series">CompositionSeries.series</a> <span class="fn">s</span> <span class="fn">j</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">i</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">j</span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.membership"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L184-L185">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.membership"><span class="name">CompositionSeries</span>.<span class="name">membership</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">X</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">CompositionSeries.membership</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">mem</span> := <span class="fn">fun (<span class="fn">x</span> : <span class="fn">X</span>) (<span class="fn">s</span> : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../.././Mathlib/Data/Set/Defs.html#Set.range">Set.range</a> <span class="fn"><span class="fn">s</span>.series</span></span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="CompositionSeries.mem_def"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L188-L189">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.mem_def"><span class="name">CompositionSeries</span>.<span class="name">mem_def</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">X</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../.././Mathlib/Data/Set/Defs.html#Set.range">Set.range</a> <span class="fn"><span class="fn">s</span>.series</span></span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.total"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L192-L196">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.total"><span class="name">CompositionSeries</span>.<span class="name">total</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">X</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">X</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hx : <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hy : <span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">y</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x</span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.toList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L200-L201">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.toList"><span class="name">CompositionSeries</span>.<span class="name">toList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">X</span></span></div></div><p>The ordered <code><a href="../.././Init/Prelude.html#List">List</a> X</code> of elements of a <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> X</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.toList">CompositionSeries.toList</a> <span class="fn">s</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Std/Data/List/Basic.html#List.ofFn">List.ofFn</a> <span class="fn"><span class="fn">s</span>.series</span></span></span></li></ul></details><details id="instances-for-list-CompositionSeries.toList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CompositionSeries.ext_fun"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L206-L212">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.ext_fun"><span class="name">CompositionSeries</span>.<span class="name">ext_fun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₁ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₂ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hl : <span class="fn"><span class="fn"><span class="fn">s₁</span>.length</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">s₂</span>.length</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">i</span> : <span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">s₁</span>.length</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></span>)</span></span>),
  <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.series">CompositionSeries.series</a> <span class="fn">s₁</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.series">CompositionSeries.series</a> <span class="fn">s₂</span> <span class="fn">(<span class="fn"><a href="../.././Std/Data/Fin/Basic.html#Fin.cast">Fin.cast</a> <span class="fn">(_ : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn"><span class="fn">s₁</span>.length</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn"><span class="fn">s₂</span>.length</span></span></span>)</span> <span class="fn">i</span></span>)</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">s₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">s₂</span></span></div></div><p>Two <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a></code> are equal if they are the same length and
have the same <code>i</code>th element for every <code>i</code></p></div></div><div class="decl" id="CompositionSeries.length_toList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L216-L217">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.length_toList"><span class="name">CompositionSeries</span>.<span class="name">length_toList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#List.length">List.length</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.toList">CompositionSeries.toList</a> <span class="fn">s</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">s</span>.length</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.toList_ne_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L220-L221">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.toList_ne_nil"><span class="name">CompositionSeries</span>.<span class="name">toList_ne_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.toList">CompositionSeries.toList</a> <span class="fn">s</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">[]</span></span></div></div></div></div><div class="decl" id="CompositionSeries.toList_injective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L224-L242">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.toList_injective"><span class="name">CompositionSeries</span>.<span class="name">toList_injective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Init/Function.html#Function.Injective">Function.Injective</a> <span class="fn">CompositionSeries.toList</span></span></div></div></div></div><div class="decl" id="CompositionSeries.chain'_toList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L245-L251">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.chain'_toList"><span class="name">CompositionSeries</span>.<span class="name">chain'_toList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Std/Data/List/Basic.html#List.Chain'">List.Chain'</a> <span class="fn">JordanHolderLattice.IsMaximal</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.toList">CompositionSeries.toList</a> <span class="fn">s</span></span>)</span></span></div></div></div></div><div class="decl" id="CompositionSeries.toList_sorted"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L254-L258">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.toList_sorted"><span class="name">CompositionSeries</span>.<span class="name">toList_sorted</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Data/List/Sort.html#List.Sorted">List.Sorted</a> <span class="fn">(<span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">X</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">x_1</span></span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.toList">CompositionSeries.toList</a> <span class="fn">s</span></span>)</span></span></div></div></div></div><div class="decl" id="CompositionSeries.toList_nodup"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L261-L262">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.toList_nodup"><span class="name">CompositionSeries</span>.<span class="name">toList_nodup</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Std/Data/List/Basic.html#List.Nodup">List.Nodup</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.toList">CompositionSeries.toList</a> <span class="fn">s</span></span>)</span></span></div></div></div></div><div class="decl" id="CompositionSeries.mem_toList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L266-L267">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.mem_toList"><span class="name">CompositionSeries</span>.<span class="name">mem_toList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">X</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.toList">CompositionSeries.toList</a> <span class="fn">s</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.ofList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L271-L279">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.ofList"><span class="name">CompositionSeries</span>.<span class="name">ofList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(l : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hl : <span class="fn"><span class="fn">l</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">[]</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hc : <span class="fn"><a href="../.././Std/Data/List/Basic.html#List.Chain'">List.Chain'</a> <span class="fn">JordanHolderLattice.IsMaximal</span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span></div></div><p>Make a <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> X</code> from the ordered list of its elements.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CompositionSeries.ofList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CompositionSeries.length_ofList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L282-L284">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.length_ofList"><span class="name">CompositionSeries</span>.<span class="name">length_ofList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(l : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hl : <span class="fn"><span class="fn">l</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">[]</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hc : <span class="fn"><a href="../.././Std/Data/List/Basic.html#List.Chain'">List.Chain'</a> <span class="fn">JordanHolderLattice.IsMaximal</span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.ofList">CompositionSeries.ofList</a> <span class="fn">l</span> <span class="fn">hl</span> <span class="fn">hc</span></span>)</span>.length</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#List.length">List.length</a> <span class="fn">l</span></span> <a href="../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.ofList_toList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L287-L293">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.ofList_toList"><span class="name">CompositionSeries</span>.<span class="name">ofList_toList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.ofList">CompositionSeries.ofList</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.toList">CompositionSeries.toList</a> <span class="fn">s</span></span>)</span> <span class="fn">(_ : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.toList">CompositionSeries.toList</a> <span class="fn">s</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">[]</span></span>)</span>
    <span class="fn">(_ : <span class="fn"><a href="../.././Std/Data/List/Basic.html#List.Chain'">List.Chain'</a> <span class="fn">JordanHolderLattice.IsMaximal</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.toList">CompositionSeries.toList</a> <span class="fn">s</span></span>)</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">s</span></span></div></div></div></div><div class="decl" id="CompositionSeries.ofList_toList'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L297-L299">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.ofList_toList'"><span class="name">CompositionSeries</span>.<span class="name">ofList_toList'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.ofList">CompositionSeries.ofList</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.toList">CompositionSeries.toList</a> <span class="fn">s</span></span>)</span> <span class="fn">(_ : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.toList">CompositionSeries.toList</a> <span class="fn">s</span></span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">[]</span></span>)</span>
    <span class="fn">(_ : <span class="fn"><a href="../.././Std/Data/List/Basic.html#List.Chain'">List.Chain'</a> <span class="fn">JordanHolderLattice.IsMaximal</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.toList">CompositionSeries.toList</a> <span class="fn">s</span></span>)</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">s</span></span></div></div></div></div><div class="decl" id="CompositionSeries.toList_ofList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L303-L311">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.toList_ofList"><span class="name">CompositionSeries</span>.<span class="name">toList_ofList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(l : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hl : <span class="fn"><span class="fn">l</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">[]</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hc : <span class="fn"><a href="../.././Std/Data/List/Basic.html#List.Chain'">List.Chain'</a> <span class="fn">JordanHolderLattice.IsMaximal</span> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.toList">CompositionSeries.toList</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.ofList">CompositionSeries.ofList</a> <span class="fn">l</span> <span class="fn">hl</span> <span class="fn">hc</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="CompositionSeries.ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L316-L323">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.ext"><span class="name">CompositionSeries</span>.<span class="name">ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₁ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₂ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">X</span>), <span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s₁</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s₂</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">s₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">s₂</span></span></div></div><p>Two <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a></code> are equal if they have the same elements. See also <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.ext_fun">ext_fun</a></code>.</p></div></div><div class="decl" id="CompositionSeries.top"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L327-L328">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top"><span class="name">CompositionSeries</span>.<span class="name">top</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">X</span></div></div><p>The largest element of a <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.series">CompositionSeries.series</a> <span class="fn">s</span> <span class="fn">(<span class="fn"><a href="../.././Std/Data/Fin/Basic.html#Fin.last">Fin.last</a> <span class="fn"><span class="fn">s</span>.length</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CompositionSeries.top" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CompositionSeries.top_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L331-L332">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top_mem"><span class="name">CompositionSeries</span>.<span class="name">top_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s</span></span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span></div></div></div></div><div class="decl" id="CompositionSeries.le_top"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L336-L337">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.le_top"><span class="name">CompositionSeries</span>.<span class="name">le_top</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">s</span>.length</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.series">CompositionSeries.series</a> <span class="fn">s</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s</span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.le_top_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L340-L342">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.le_top_of_mem"><span class="name">CompositionSeries</span>.<span class="name">le_top_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">X</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hx : <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s</span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.bot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L346-L347">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot"><span class="name">CompositionSeries</span>.<span class="name">bot</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">X</span></div></div><p>The smallest element of a <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot">CompositionSeries.bot</a> <span class="fn">s</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.series">CompositionSeries.series</a> <span class="fn">s</span> <span class="fn">0</span></span></span></li></ul></details><details id="instances-for-list-CompositionSeries.bot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CompositionSeries.bot_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L350-L351">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot_mem"><span class="name">CompositionSeries</span>.<span class="name">bot_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot">CompositionSeries.bot</a> <span class="fn">s</span></span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span></div></div></div></div><div class="decl" id="CompositionSeries.bot_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L355-L356">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot_le"><span class="name">CompositionSeries</span>.<span class="name">bot_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(i : <span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">s</span>.length</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot">CompositionSeries.bot</a> <span class="fn">s</span></span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.series">CompositionSeries.series</a> <span class="fn">s</span> <span class="fn">i</span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.bot_le_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L359-L361">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot_le_of_mem"><span class="name">CompositionSeries</span>.<span class="name">bot_le_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">X</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hx : <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot">CompositionSeries.bot</a> <span class="fn">s</span></span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="CompositionSeries.length_pos_of_mem_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L364-L371">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.length_pos_of_mem_ne"><span class="name">CompositionSeries</span>.<span class="name">length_pos_of_mem_ne</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">X</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">X</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hx : <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hy : <span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hxy : <span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">0</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">s</span>.length</span></span></div></div></div></div><div class="decl" id="CompositionSeries.forall_mem_eq_of_length_eq_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L374-L376">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.forall_mem_eq_of_length_eq_zero"><span class="name">CompositionSeries</span>.<span class="name">forall_mem_eq_of_length_eq_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hs : <span class="fn"><span class="fn"><span class="fn">s</span>.length</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">X</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">X</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hx : <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hy : <span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">y</span></span></div></div></div></div><div class="decl" id="CompositionSeries.eraseTop_series"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L381-L381">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.eraseTop_series"><span class="name">CompositionSeries</span>.<span class="name">eraseTop_series</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><span class="fn">s</span>.length</span> <a href="../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span></span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.series">CompositionSeries.series</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.eraseTop">CompositionSeries.eraseTop</a> <span class="fn">s</span></span>)</span> <span class="fn">i</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.series">CompositionSeries.series</a> <span class="fn">s</span> <span class="fn">{ <span class="fn">val</span> := <span class="fn">↑<span class="fn">i</span></span>, <span class="fn">isLt</span> := <span class="fn">(_ : <span class="fn"><span class="fn">↑<span class="fn">i</span></span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">s</span>.length</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></span></span>)</span> }</span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.eraseTop_length"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L381-L381">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.eraseTop_length"><span class="name">CompositionSeries</span>.<span class="name">eraseTop_length</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.eraseTop">CompositionSeries.eraseTop</a> <span class="fn">s</span></span>)</span>.length</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">s</span>.length</span> <a href="../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.eraseTop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L382-L388">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.eraseTop"><span class="name">CompositionSeries</span>.<span class="name">eraseTop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span></div></div><p>Remove the largest element from a <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a></code>. If the series <code>s</code>
has length zero, then <code>s.<a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.eraseTop">eraseTop</a> = s</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CompositionSeries.eraseTop" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CompositionSeries.top_eraseTop"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L391-L398">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top_eraseTop"><span class="name">CompositionSeries</span>.<span class="name">top_eraseTop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.eraseTop">CompositionSeries.eraseTop</a> <span class="fn">s</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.series">CompositionSeries.series</a> <span class="fn">s</span> <span class="fn">{ <span class="fn">val</span> := <span class="fn"><span class="fn"><span class="fn">s</span>.length</span> <a href="../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span></span>, <span class="fn">isLt</span> := <span class="fn">(_ : <span class="fn"><span class="fn"><span class="fn"><span class="fn">s</span>.length</span> <a href="../.././Init/Prelude.html#HSub.hSub">-</a> <span class="fn">1</span></span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn"><span class="fn">s</span>.length</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></span></span>)</span> }</span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.eraseTop_top_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L401-L402">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.eraseTop_top_le"><span class="name">CompositionSeries</span>.<span class="name">eraseTop_top_le</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.eraseTop">CompositionSeries.eraseTop</a> <span class="fn">s</span></span>)</span></span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s</span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.bot_eraseTop"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L406-L407">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot_eraseTop"><span class="name">CompositionSeries</span>.<span class="name">bot_eraseTop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot">CompositionSeries.bot</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.eraseTop">CompositionSeries.eraseTop</a> <span class="fn">s</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot">CompositionSeries.bot</a> <span class="fn">s</span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.mem_eraseTop_of_ne_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L410-L418">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.mem_eraseTop_of_ne_of_mem"><span class="name">CompositionSeries</span>.<span class="name">mem_eraseTop_of_ne_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">X</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hx : <span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hxs : <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.eraseTop">CompositionSeries.eraseTop</a> <span class="fn">s</span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.mem_eraseTop"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L421-L433">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.mem_eraseTop"><span class="name">CompositionSeries</span>.<span class="name">mem_eraseTop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">X</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">0</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">s</span>.length</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.eraseTop">CompositionSeries.eraseTop</a> <span class="fn">s</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s</span></span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.lt_top_of_mem_eraseTop"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L436-L438">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.lt_top_of_mem_eraseTop"><span class="name">CompositionSeries</span>.<span class="name">lt_top_of_mem_eraseTop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">X</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">0</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">s</span>.length</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hx : <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.eraseTop">CompositionSeries.eraseTop</a> <span class="fn">s</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s</span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.isMaximal_eraseTop_top"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L441-L446">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.isMaximal_eraseTop_top"><span class="name">CompositionSeries</span>.<span class="name">isMaximal_eraseTop_top</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">0</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">s</span>.length</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.eraseTop">CompositionSeries.eraseTop</a> <span class="fn">s</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s</span></span>)</span></span></div></div></div></div><div class="decl" id="CompositionSeries.append_castAdd_aux"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L454-L459">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.append_castAdd_aux"><span class="name">CompositionSeries</span>.<span class="name">append_castAdd_aux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <a href="../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href="../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">m</span></span>)</span></span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">n</span></span>)</span></span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">m</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Fin/VecNotation.html#Matrix.vecAppend">Matrix.vecAppend</a> <span class="fn">(_ : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">(<span class="fn"><span class="fn">m</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">n</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">m</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><a href="../.././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">n</span></span></span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">Fin.castSucc</span></span>)</span> <span class="fn">b</span> <span class="fn">(<span class="fn"><a href="../.././Std/Data/Fin/Basic.html#Fin.castSucc">Fin.castSucc</a> <span class="fn">(<span class="fn"><a href="../.././Std/Data/Fin/Basic.html#Fin.castAdd">Fin.castAdd</a> <span class="fn">n</span> <span class="fn">i</span></span>)</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">a</span> <span class="fn">(<span class="fn"><a href="../.././Std/Data/Fin/Basic.html#Fin.castSucc">Fin.castSucc</a> <span class="fn">i</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.append_succ_castAdd_aux"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L462-L474">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.append_succ_castAdd_aux"><span class="name">CompositionSeries</span>.<span class="name">append_succ_castAdd_aux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <a href="../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href="../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">m</span></span>)</span></span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">n</span></span>)</span></span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">m</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">a</span> <span class="fn">(<span class="fn"><a href="../.././Std/Data/Fin/Basic.html#Fin.last">Fin.last</a> <span class="fn">m</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">b</span> <span class="fn">0</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Fin/VecNotation.html#Matrix.vecAppend">Matrix.vecAppend</a> <span class="fn">(_ : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">(<span class="fn"><span class="fn">m</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">n</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">m</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><a href="../.././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">n</span></span></span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">Fin.castSucc</span></span>)</span> <span class="fn">b</span> <span class="fn">(<span class="fn"><a href="../.././Init/Data/Fin/Basic.html#Fin.succ">Fin.succ</a> <span class="fn">(<span class="fn"><a href="../.././Std/Data/Fin/Basic.html#Fin.castAdd">Fin.castAdd</a> <span class="fn">n</span> <span class="fn">i</span></span>)</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">a</span> <span class="fn">(<span class="fn"><a href="../.././Init/Data/Fin/Basic.html#Fin.succ">Fin.succ</a> <span class="fn">i</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.append_natAdd_aux"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L477-L483">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.append_natAdd_aux"><span class="name">CompositionSeries</span>.<span class="name">append_natAdd_aux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <a href="../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href="../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">m</span></span>)</span></span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">n</span></span>)</span></span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Fin/VecNotation.html#Matrix.vecAppend">Matrix.vecAppend</a> <span class="fn">(_ : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">(<span class="fn"><span class="fn">m</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">n</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">m</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><a href="../.././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">n</span></span></span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">Fin.castSucc</span></span>)</span> <span class="fn">b</span> <span class="fn">(<span class="fn"><a href="../.././Std/Data/Fin/Basic.html#Fin.castSucc">Fin.castSucc</a> <span class="fn">(<span class="fn"><a href="../.././Std/Data/Fin/Basic.html#Fin.natAdd">Fin.natAdd</a> <span class="fn">m</span> <span class="fn">i</span></span>)</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">b</span> <span class="fn">(<span class="fn"><a href="../.././Std/Data/Fin/Basic.html#Fin.castSucc">Fin.castSucc</a> <span class="fn">i</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.append_succ_natAdd_aux"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L486-L491">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.append_succ_natAdd_aux"><span class="name">CompositionSeries</span>.<span class="name">append_succ_natAdd_aux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <a href="../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href="../.././Init/Prelude.html#Nat">ℕ</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">m</span></span>)</span></span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">n</span></span>)</span></span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Fin/VecNotation.html#Matrix.vecAppend">Matrix.vecAppend</a> <span class="fn">(_ : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">(<span class="fn"><span class="fn">m</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">n</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">m</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><a href="../.././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">n</span></span></span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">Fin.castSucc</span></span>)</span> <span class="fn">b</span> <span class="fn">(<span class="fn"><a href="../.././Init/Data/Fin/Basic.html#Fin.succ">Fin.succ</a> <span class="fn">(<span class="fn"><a href="../.././Std/Data/Fin/Basic.html#Fin.natAdd">Fin.natAdd</a> <span class="fn">m</span> <span class="fn">i</span></span>)</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">b</span> <span class="fn">(<span class="fn"><a href="../.././Init/Data/Fin/Basic.html#Fin.succ">Fin.succ</a> <span class="fn">i</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.append_length"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L498-L498">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.append_length"><span class="name">CompositionSeries</span>.<span class="name">append_length</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s₁ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(s₂ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot">CompositionSeries.bot</a> <span class="fn">s₂</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.append">CompositionSeries.append</a> <span class="fn">s₁</span> <span class="fn">s₂</span> <span class="fn">h</span></span>)</span>.length</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">s₁</span>.length</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">s₂</span>.length</span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.append"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L499-L509">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.append"><span class="name">CompositionSeries</span>.<span class="name">append</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s₁ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(s₂ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot">CompositionSeries.bot</a> <span class="fn">s₂</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span></div></div><p>Append two composition series <code>s₁</code> and <code>s₂</code> such that
the least element of <code>s₁</code> is the maximum element of <code>s₂</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CompositionSeries.append" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CompositionSeries.coe_append"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L512-L514">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.coe_append"><span class="name">CompositionSeries</span>.<span class="name">coe_append</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s₁ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(s₂ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot">CompositionSeries.bot</a> <span class="fn">s₂</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.append">CompositionSeries.append</a> <span class="fn">s₁</span> <span class="fn">s₂</span> <span class="fn">h</span></span>)</span>.series</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/Data/Fin/VecNotation.html#Matrix.vecAppend">Matrix.vecAppend</a> <span class="fn">(_ : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">s₁</span>.length</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">s₂</span>.length</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">s₁</span>.length</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><a href="../.././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn"><span class="fn">s₂</span>.length</span></span></span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">s₁</span>.series</span> <a href="../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">Fin.castSucc</span></span>)</span>
    <span class="fn"><span class="fn">s₂</span>.series</span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.append_castAdd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L518-L520">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.append_castAdd"><span class="name">CompositionSeries</span>.<span class="name">append_castAdd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₁ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₂ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot">CompositionSeries.bot</a> <span class="fn">s₂</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn"><span class="fn">s₁</span>.length</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.series">CompositionSeries.series</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.append">CompositionSeries.append</a> <span class="fn">s₁</span> <span class="fn">s₂</span> <span class="fn">h</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Std/Data/Fin/Basic.html#Fin.castSucc">Fin.castSucc</a> <span class="fn">(<span class="fn"><a href="../.././Std/Data/Fin/Basic.html#Fin.castAdd">Fin.castAdd</a> <span class="fn"><span class="fn">s₂</span>.length</span> <span class="fn">i</span></span>)</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.series">CompositionSeries.series</a> <span class="fn">s₁</span> <span class="fn">(<span class="fn"><a href="../.././Std/Data/Fin/Basic.html#Fin.castSucc">Fin.castSucc</a> <span class="fn">i</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.append_succ_castAdd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L524-L526">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.append_succ_castAdd"><span class="name">CompositionSeries</span>.<span class="name">append_succ_castAdd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₁ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₂ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot">CompositionSeries.bot</a> <span class="fn">s₂</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn"><span class="fn">s₁</span>.length</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.series">CompositionSeries.series</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.append">CompositionSeries.append</a> <span class="fn">s₁</span> <span class="fn">s₂</span> <span class="fn">h</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Init/Data/Fin/Basic.html#Fin.succ">Fin.succ</a> <span class="fn">(<span class="fn"><a href="../.././Std/Data/Fin/Basic.html#Fin.castAdd">Fin.castAdd</a> <span class="fn"><span class="fn">s₂</span>.length</span> <span class="fn">i</span></span>)</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.series">CompositionSeries.series</a> <span class="fn">s₁</span> <span class="fn">(<span class="fn"><a href="../.././Init/Data/Fin/Basic.html#Fin.succ">Fin.succ</a> <span class="fn">i</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.append_natAdd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L530-L532">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.append_natAdd"><span class="name">CompositionSeries</span>.<span class="name">append_natAdd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₁ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₂ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot">CompositionSeries.bot</a> <span class="fn">s₂</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn"><span class="fn">s₂</span>.length</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.series">CompositionSeries.series</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.append">CompositionSeries.append</a> <span class="fn">s₁</span> <span class="fn">s₂</span> <span class="fn">h</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Std/Data/Fin/Basic.html#Fin.castSucc">Fin.castSucc</a> <span class="fn">(<span class="fn"><a href="../.././Std/Data/Fin/Basic.html#Fin.natAdd">Fin.natAdd</a> <span class="fn"><span class="fn">s₁</span>.length</span> <span class="fn">i</span></span>)</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.series">CompositionSeries.series</a> <span class="fn">s₂</span> <span class="fn">(<span class="fn"><a href="../.././Std/Data/Fin/Basic.html#Fin.castSucc">Fin.castSucc</a> <span class="fn">i</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.append_succ_natAdd"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L536-L538">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.append_succ_natAdd"><span class="name">CompositionSeries</span>.<span class="name">append_succ_natAdd</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₁ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₂ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot">CompositionSeries.bot</a> <span class="fn">s₂</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn"><span class="fn">s₂</span>.length</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.series">CompositionSeries.series</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.append">CompositionSeries.append</a> <span class="fn">s₁</span> <span class="fn">s₂</span> <span class="fn">h</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Init/Data/Fin/Basic.html#Fin.succ">Fin.succ</a> <span class="fn">(<span class="fn"><a href="../.././Std/Data/Fin/Basic.html#Fin.natAdd">Fin.natAdd</a> <span class="fn"><span class="fn">s₁</span>.length</span> <span class="fn">i</span></span>)</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.series">CompositionSeries.series</a> <span class="fn">s₂</span> <span class="fn">(<span class="fn"><a href="../.././Init/Data/Fin/Basic.html#Fin.succ">Fin.succ</a> <span class="fn">i</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.snoc_length"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L542-L542">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.snoc_length"><span class="name">CompositionSeries</span>.<span class="name">snoc_length</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">X</span>)</span></span>
<span class="decl_args">
<span class="fn">(hsat : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s</span></span>)</span> <span class="fn">x</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.snoc">CompositionSeries.snoc</a> <span class="fn">s</span> <span class="fn">x</span> <span class="fn">hsat</span></span>)</span>.length</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">s</span>.length</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.snoc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L543-L551">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.snoc"><span class="name">CompositionSeries</span>.<span class="name">snoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">X</span>)</span></span>
<span class="decl_args">
<span class="fn">(hsat : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s</span></span>)</span> <span class="fn">x</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span></div></div><p>Add an element to the top of a <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CompositionSeries.snoc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CompositionSeries.top_snoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L555-L557">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top_snoc"><span class="name">CompositionSeries</span>.<span class="name">top_snoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">X</span>)</span></span>
<span class="decl_args">
<span class="fn">(hsat : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s</span></span>)</span> <span class="fn">x</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.snoc">CompositionSeries.snoc</a> <span class="fn">s</span> <span class="fn">x</span> <span class="fn">hsat</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="CompositionSeries.snoc_last"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L561-L563">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.snoc_last"><span class="name">CompositionSeries</span>.<span class="name">snoc_last</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">X</span>)</span></span>
<span class="decl_args">
<span class="fn">(hsat : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s</span></span>)</span> <span class="fn">x</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.series">CompositionSeries.series</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.snoc">CompositionSeries.snoc</a> <span class="fn">s</span> <span class="fn">x</span> <span class="fn">hsat</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Std/Data/Fin/Basic.html#Fin.last">Fin.last</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">s</span>.length</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></span>)</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></span></div></div></div></div><div class="decl" id="CompositionSeries.snoc_castSucc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L567-L569">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.snoc_castSucc"><span class="name">CompositionSeries</span>.<span class="name">snoc_castSucc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">X</span>)</span></span>
<span class="decl_args">
<span class="fn">(hsat : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s</span></span>)</span> <span class="fn">x</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <span class="fn"><a href="../.././Init/Prelude.html#Fin">Fin</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">s</span>.length</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.series">CompositionSeries.series</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.snoc">CompositionSeries.snoc</a> <span class="fn">s</span> <span class="fn">x</span> <span class="fn">hsat</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Std/Data/Fin/Basic.html#Fin.castSucc">Fin.castSucc</a> <span class="fn">i</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.series">CompositionSeries.series</a> <span class="fn">s</span> <span class="fn">i</span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.bot_snoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L573-L575">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot_snoc"><span class="name">CompositionSeries</span>.<span class="name">bot_snoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">X</span>)</span></span>
<span class="decl_args">
<span class="fn">(hsat : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s</span></span>)</span> <span class="fn">x</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot">CompositionSeries.bot</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.snoc">CompositionSeries.snoc</a> <span class="fn">s</span> <span class="fn">x</span> <span class="fn">hsat</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot">CompositionSeries.bot</a> <span class="fn">s</span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.mem_snoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L578-L593">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.mem_snoc"><span class="name">CompositionSeries</span>.<span class="name">mem_snoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">X</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn">X</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{hsat : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s</span></span>)</span> <span class="fn">x</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.snoc">CompositionSeries.snoc</a> <span class="fn">s</span> <span class="fn">x</span> <span class="fn">hsat</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">y</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.eq_snoc_eraseTop"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L596-L600">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.eq_snoc_eraseTop"><span class="name">CompositionSeries</span>.<span class="name">eq_snoc_eraseTop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">0</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">s</span>.length</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">s</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.snoc">CompositionSeries.snoc</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.eraseTop">CompositionSeries.eraseTop</a> <span class="fn">s</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s</span></span>)</span>
    <span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.eraseTop">CompositionSeries.eraseTop</a> <span class="fn">s</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s</span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.snoc_eraseTop_top"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L604-L612">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.snoc_eraseTop_top"><span class="name">CompositionSeries</span>.<span class="name">snoc_eraseTop_top</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.eraseTop">CompositionSeries.eraseTop</a> <span class="fn">s</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.snoc">CompositionSeries.snoc</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.eraseTop">CompositionSeries.eraseTop</a> <span class="fn">s</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s</span></span>)</span> <span class="fn">h</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">s</span></span></div></div></div></div><div class="decl" id="CompositionSeries.Equivalent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L618-L621">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent"><span class="name">CompositionSeries</span>.<span class="name">Equivalent</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s₁ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(s₂ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Prop</a></div></div><p>Two <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> X</code>, <code>s₁</code> and <code>s₂</code> are equivalent if there is a bijection
<code>e : <a href="../.././Init/Prelude.html#Fin">Fin</a> s₁.<a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.length">length</a> ≃ <a href="../.././Init/Prelude.html#Fin">Fin</a> s₂.<a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.length">length</a></code> such that for any <code>i</code>,
<code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">Iso</a> (s₁ i) (s₁ i.succ) (s₂ (e i), s₂ (e i.succ))</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CompositionSeries.Equivalent" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CompositionSeries.Equivalent.refl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L627-L628">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent.refl"><span class="name">CompositionSeries</span>.<span class="name">Equivalent</span>.<span class="name">refl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">CompositionSeries.Equivalent</a> <span class="fn">s</span> <span class="fn">s</span></span></div></div></div></div><div class="decl" id="CompositionSeries.Equivalent.symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L632-L633">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent.symm"><span class="name">CompositionSeries</span>.<span class="name">Equivalent</span>.<span class="name">symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₁ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₂ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">CompositionSeries.Equivalent</a> <span class="fn">s₁</span> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">CompositionSeries.Equivalent</a> <span class="fn">s₂</span> <span class="fn">s₁</span></span></div></div></div></div><div class="decl" id="CompositionSeries.Equivalent.trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L637-L640">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent.trans"><span class="name">CompositionSeries</span>.<span class="name">Equivalent</span>.<span class="name">trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₁ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₂ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₃ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">CompositionSeries.Equivalent</a> <span class="fn">s₁</span> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">CompositionSeries.Equivalent</a> <span class="fn">s₂</span> <span class="fn">s₃</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">CompositionSeries.Equivalent</a> <span class="fn">s₁</span> <span class="fn">s₃</span></span></div></div></div></div><div class="decl" id="CompositionSeries.Equivalent.append"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L643-L658">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent.append"><span class="name">CompositionSeries</span>.<span class="name">Equivalent</span>.<span class="name">append</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₁ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₂ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t₁ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t₂ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hs : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot">CompositionSeries.bot</a> <span class="fn">s₂</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ht : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">t₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot">CompositionSeries.bot</a> <span class="fn">t₂</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">CompositionSeries.Equivalent</a> <span class="fn">s₁</span> <span class="fn">t₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">CompositionSeries.Equivalent</a> <span class="fn">s₂</span> <span class="fn">t₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">CompositionSeries.Equivalent</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.append">CompositionSeries.append</a> <span class="fn">s₁</span> <span class="fn">s₂</span> <span class="fn">hs</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.append">CompositionSeries.append</a> <span class="fn">t₁</span> <span class="fn">t₂</span> <span class="fn">ht</span></span>)</span></span></div></div></div></div><div class="decl" id="CompositionSeries.Equivalent.snoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L661-L674">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent.snoc"><span class="name">CompositionSeries</span>.<span class="name">Equivalent</span>.<span class="name">snoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₁ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₂ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x₁ : <span class="fn">X</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x₂ : <span class="fn">X</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{hsat₁ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s₁</span></span>)</span> <span class="fn">x₁</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{hsat₂ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s₂</span></span>)</span> <span class="fn">x₂</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hequiv : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">CompositionSeries.Equivalent</a> <span class="fn">s₁</span> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(htop : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">JordanHolderLattice.Iso</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s₁</span></span>, <span class="fn">x₁</span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s₂</span></span>, <span class="fn">x₂</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">CompositionSeries.Equivalent</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.snoc">CompositionSeries.snoc</a> <span class="fn">s₁</span> <span class="fn">x₁</span> <span class="fn">hsat₁</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.snoc">CompositionSeries.snoc</a> <span class="fn">s₂</span> <span class="fn">x₂</span> <span class="fn">hsat₂</span></span>)</span></span></div></div></div></div><div class="decl" id="CompositionSeries.Equivalent.length_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L677-L678">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent.length_eq"><span class="name">CompositionSeries</span>.<span class="name">Equivalent</span>.<span class="name">length_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₁ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₂ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">CompositionSeries.Equivalent</a> <span class="fn">s₁</span> <span class="fn">s₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">s₁</span>.length</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">s₂</span>.length</span></span></div></div></div></div><div class="decl" id="CompositionSeries.Equivalent.snoc_snoc_swap"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L681-L710">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent.snoc_snoc_swap"><span class="name">CompositionSeries</span>.<span class="name">Equivalent</span>.<span class="name">snoc_snoc_swap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x₁ : <span class="fn">X</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x₂ : <span class="fn">X</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y₁ : <span class="fn">X</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y₂ : <span class="fn">X</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{hsat₁ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s</span></span>)</span> <span class="fn">x₁</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{hsat₂ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s</span></span>)</span> <span class="fn">x₂</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{hsaty₁ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.snoc">CompositionSeries.snoc</a> <span class="fn">s</span> <span class="fn">x₁</span> <span class="fn">hsat₁</span></span>)</span></span>)</span> <span class="fn">y₁</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{hsaty₂ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.snoc">CompositionSeries.snoc</a> <span class="fn">s</span> <span class="fn">x₂</span> <span class="fn">hsat₂</span></span>)</span></span>)</span> <span class="fn">y₂</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr₁ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">JordanHolderLattice.Iso</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s</span></span>, <span class="fn">x₁</span>)</span> <span class="fn">(<span class="fn">x₂</span>, <span class="fn">y₂</span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hr₂ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.Iso">JordanHolderLattice.Iso</a> <span class="fn">(<span class="fn">x₁</span>, <span class="fn">y₁</span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s</span></span>, <span class="fn">x₂</span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">CompositionSeries.Equivalent</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.snoc">CompositionSeries.snoc</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.snoc">CompositionSeries.snoc</a> <span class="fn">s</span> <span class="fn">x₁</span> <span class="fn">hsat₁</span></span>)</span> <span class="fn">y₁</span> <span class="fn">hsaty₁</span></span>)</span>
  <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.snoc">CompositionSeries.snoc</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.snoc">CompositionSeries.snoc</a> <span class="fn">s</span> <span class="fn">x₂</span> <span class="fn">hsat₂</span></span>)</span> <span class="fn">y₂</span> <span class="fn">hsaty₂</span></span>)</span></span></div></div></div></div><div class="decl" id="CompositionSeries.length_eq_zero_of_bot_eq_bot_of_top_eq_top_of_length_eq_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L715-L722">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.length_eq_zero_of_bot_eq_bot_of_top_eq_top_of_length_eq_zero"><span class="name">CompositionSeries</span>.<span class="name">length_eq_zero_of_bot_eq_bot_of_top_eq_top_of_length_eq_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₁ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₂ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hb : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot">CompositionSeries.bot</a> <span class="fn">s₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot">CompositionSeries.bot</a> <span class="fn">s₂</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ht : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s₂</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hs₁ : <span class="fn"><span class="fn"><span class="fn">s₁</span>.length</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">s₂</span>.length</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></span></div></div></div></div><div class="decl" id="CompositionSeries.length_pos_of_bot_eq_bot_of_top_eq_top_of_length_pos"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L725-L730">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.length_pos_of_bot_eq_bot_of_top_eq_top_of_length_pos"><span class="name">CompositionSeries</span>.<span class="name">length_pos_of_bot_eq_bot_of_top_eq_top_of_length_pos</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₁ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₂ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hb : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot">CompositionSeries.bot</a> <span class="fn">s₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot">CompositionSeries.bot</a> <span class="fn">s₂</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ht : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s₂</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">0</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">s₁</span>.length</span></span> → <span class="fn"><span class="fn">0</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><span class="fn">s₂</span>.length</span></span></span></div></div></div></div><div class="decl" id="CompositionSeries.eq_of_bot_eq_bot_of_top_eq_top_of_length_eq_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L733-L743">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.eq_of_bot_eq_bot_of_top_eq_top_of_length_eq_zero"><span class="name">CompositionSeries</span>.<span class="name">eq_of_bot_eq_bot_of_top_eq_top_of_length_eq_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₁ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s₂ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hb : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot">CompositionSeries.bot</a> <span class="fn">s₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot">CompositionSeries.bot</a> <span class="fn">s₂</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ht : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s₂</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hs₁0 : <span class="fn"><span class="fn"><span class="fn">s₁</span>.length</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">s₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">s₂</span></span></div></div></div></div><div class="decl" id="CompositionSeries.exists_top_eq_snoc_equivalant"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L750-L786">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.exists_top_eq_snoc_equivalant"><span class="name">CompositionSeries</span>.<span class="name">exists_top_eq_snoc_equivalant</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">X</span>)</span></span>
<span class="decl_args">
<span class="fn">(hm : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">x</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hb : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot">CompositionSeries.bot</a> <span class="fn">s</span></span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (t : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>),
  <span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot">CompositionSeries.bot</a> <span class="fn">t</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot">CompositionSeries.bot</a> <span class="fn">s</span></span></span> <a href="../.././Init/Prelude.html#And">∧</a>     <span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">t</span>.length</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">s</span>.length</span></span> <a href="../.././Init/Prelude.html#And">∧</a>       <span class="fn">∃ (htx : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">t</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></span>),
        <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">CompositionSeries.Equivalent</a> <span class="fn">s</span>
          <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.snoc">CompositionSeries.snoc</a> <span class="fn">t</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s</span></span>)</span>
            <span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice.IsMaximal">JordanHolderLattice.IsMaximal</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">t</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s</span></span>)</span></span>)</span></span>)</span></span></span></span></span></span></div></div><p>Given a <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a></code>, <code>s</code>, and an element <code>x</code>
such that <code>x</code> is maximal inside <code>s.<a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">top</a></code> there is a series, <code>t</code>,
such that <code>t.<a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">top</a> = x</code>, <code>t.<a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot">bot</a> = s.<a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot">bot</a></code>
and <code><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.snoc">snoc</a> t s.<a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">top</a> _</code> is equivalent to <code>s</code>.</p></div></div><div class="decl" id="CompositionSeries.jordan_holder"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Order/JordanHolder.lean#L791-L805">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.jordan_holder"><span class="name">CompositionSeries</span>.<span class="name">jordan_holder</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/Lattice.html#Lattice">Lattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s₁ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(s₂ : <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries">CompositionSeries</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hb : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot">CompositionSeries.bot</a> <span class="fn">s₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.bot">CompositionSeries.bot</a> <span class="fn">s₂</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ht : <span class="fn"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.top">CompositionSeries.top</a> <span class="fn">s₂</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Order/JordanHolder.html#CompositionSeries.Equivalent">CompositionSeries.Equivalent</a> <span class="fn">s₁</span> <span class="fn">s₂</span></span></div></div><p>The <strong>Jordan-Hölder</strong> theorem, stated for any <code><a href="../.././Mathlib/Order/JordanHolder.html#JordanHolderLattice">JordanHolderLattice</a></code>.
If two composition series start and finish at the same place, they are equivalent.</p></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>