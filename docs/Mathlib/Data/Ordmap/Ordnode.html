<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="stylesheet" href="../../.././src/pygments.css"></link><link rel="shortcut icon" href="../../.././favicon.ico"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Data.Ordmap.Ordnode</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.Data.Ordmap.Ordnode";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Data</span>.<span class="name">Ordmap</span>.<span class="name">Ordnode</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;
            <button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/Order/Compare.html">Mathlib.Order.Compare</a></li><li><a href="../../.././Mathlib/Data/List/Defs.html">Mathlib.Data.List.Defs</a></li><li><a href="../../.././Mathlib/Data/Nat/PSub.html">Mathlib.Data.Nat.PSub</a></li><li><a href="../../.././Mathlib/Data/Option/Basic.html">Mathlib.Data.Option.Basic</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Data.Ordmap.Ordnode" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Ordnode"><span class="name">Ordnode</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.instEmptyCollectionOrdnode"><span class="name">Ordnode</span>.<span class="name">instEmptyCollectionOrdnode</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.instInhabitedOrdnode"><span class="name">Ordnode</span>.<span class="name">instInhabitedOrdnode</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.delta"><span class="name">Ordnode</span>.<span class="name">delta</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.ratio"><span class="name">Ordnode</span>.<span class="name">ratio</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.singleton"><span class="name">Ordnode</span>.<span class="name">singleton</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.instSingletonOrdnode"><span class="name">Ordnode</span>.<span class="name">instSingletonOrdnode</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.size"><span class="name">Ordnode</span>.<span class="name">size</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.size_nil"><span class="name">Ordnode</span>.<span class="name">size_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.size_node"><span class="name">Ordnode</span>.<span class="name">size_node</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.empty"><span class="name">Ordnode</span>.<span class="name">empty</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.dual"><span class="name">Ordnode</span>.<span class="name">dual</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.node'"><span class="name">Ordnode</span>.<span class="name">node'</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.repr"><span class="name">Ordnode</span>.<span class="name">repr</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.instReprOrdnode"><span class="name">Ordnode</span>.<span class="name">instReprOrdnode</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.balanceL"><span class="name">Ordnode</span>.<span class="name">balanceL</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.balanceR"><span class="name">Ordnode</span>.<span class="name">balanceR</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.balance"><span class="name">Ordnode</span>.<span class="name">balance</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.All"><span class="name">Ordnode</span>.<span class="name">All</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.All.decidable"><span class="name">Ordnode</span>.<span class="name">All</span>.<span class="name">decidable</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.Any"><span class="name">Ordnode</span>.<span class="name">Any</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.Any.decidable"><span class="name">Ordnode</span>.<span class="name">Any</span>.<span class="name">decidable</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.Emem"><span class="name">Ordnode</span>.<span class="name">Emem</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.Emem.decidable"><span class="name">Ordnode</span>.<span class="name">Emem</span>.<span class="name">decidable</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.Amem"><span class="name">Ordnode</span>.<span class="name">Amem</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.Amem.decidable"><span class="name">Ordnode</span>.<span class="name">Amem</span>.<span class="name">decidable</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findMin'"><span class="name">Ordnode</span>.<span class="name">findMin'</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findMin"><span class="name">Ordnode</span>.<span class="name">findMin</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findMax'"><span class="name">Ordnode</span>.<span class="name">findMax'</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findMax"><span class="name">Ordnode</span>.<span class="name">findMax</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.eraseMin"><span class="name">Ordnode</span>.<span class="name">eraseMin</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.eraseMax"><span class="name">Ordnode</span>.<span class="name">eraseMax</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.splitMin'"><span class="name">Ordnode</span>.<span class="name">splitMin'</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.splitMin"><span class="name">Ordnode</span>.<span class="name">splitMin</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.splitMax'"><span class="name">Ordnode</span>.<span class="name">splitMax'</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.splitMax"><span class="name">Ordnode</span>.<span class="name">splitMax</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.glue"><span class="name">Ordnode</span>.<span class="name">glue</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.merge"><span class="name">Ordnode</span>.<span class="name">merge</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.insertMax"><span class="name">Ordnode</span>.<span class="name">insertMax</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.insertMin"><span class="name">Ordnode</span>.<span class="name">insertMin</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.link"><span class="name">Ordnode</span>.<span class="name">link</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.filter"><span class="name">Ordnode</span>.<span class="name">filter</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.partition"><span class="name">Ordnode</span>.<span class="name">partition</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.map"><span class="name">Ordnode</span>.<span class="name">map</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.fold"><span class="name">Ordnode</span>.<span class="name">fold</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.foldl"><span class="name">Ordnode</span>.<span class="name">foldl</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.foldr"><span class="name">Ordnode</span>.<span class="name">foldr</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.toList"><span class="name">Ordnode</span>.<span class="name">toList</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.toRevList"><span class="name">Ordnode</span>.<span class="name">toRevList</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.instToStringOrdnode"><span class="name">Ordnode</span>.<span class="name">instToStringOrdnode</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.instToFormatOrdnode"><span class="name">Ordnode</span>.<span class="name">instToFormatOrdnode</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.Equiv"><span class="name">Ordnode</span>.<span class="name">Equiv</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.instDecidableRelOrdnodeEquiv"><span class="name">Ordnode</span>.<span class="name">instDecidableRelOrdnodeEquiv</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.powerset"><span class="name">Ordnode</span>.<span class="name">powerset</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.prod"><span class="name">Ordnode</span>.<span class="name">prod</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.copair"><span class="name">Ordnode</span>.<span class="name">copair</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.pmap"><span class="name">Ordnode</span>.<span class="name">pmap</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.attach'"><span class="name">Ordnode</span>.<span class="name">attach'</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.nth"><span class="name">Ordnode</span>.<span class="name">nth</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.removeNth"><span class="name">Ordnode</span>.<span class="name">removeNth</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.takeAux"><span class="name">Ordnode</span>.<span class="name">takeAux</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.take"><span class="name">Ordnode</span>.<span class="name">take</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.dropAux"><span class="name">Ordnode</span>.<span class="name">dropAux</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.drop"><span class="name">Ordnode</span>.<span class="name">drop</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.splitAtAux"><span class="name">Ordnode</span>.<span class="name">splitAtAux</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.splitAt"><span class="name">Ordnode</span>.<span class="name">splitAt</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.takeWhile"><span class="name">Ordnode</span>.<span class="name">takeWhile</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.dropWhile"><span class="name">Ordnode</span>.<span class="name">dropWhile</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.span"><span class="name">Ordnode</span>.<span class="name">span</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.ofAscListAux₁"><span class="name">Ordnode</span>.<span class="name">ofAscListAux₁</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.ofAscListAux₂"><span class="name">Ordnode</span>.<span class="name">ofAscListAux₂</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.ofAscList"><span class="name">Ordnode</span>.<span class="name">ofAscList</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.mem"><span class="name">Ordnode</span>.<span class="name">mem</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.find"><span class="name">Ordnode</span>.<span class="name">find</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.instMembershipOrdnode"><span class="name">Ordnode</span>.<span class="name">instMembershipOrdnode</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.mem.decidable"><span class="name">Ordnode</span>.<span class="name">mem</span>.<span class="name">decidable</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.insertWith"><span class="name">Ordnode</span>.<span class="name">insertWith</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.adjustWith"><span class="name">Ordnode</span>.<span class="name">adjustWith</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.updateWith"><span class="name">Ordnode</span>.<span class="name">updateWith</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.alter"><span class="name">Ordnode</span>.<span class="name">alter</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.insert"><span class="name">Ordnode</span>.<span class="name">insert</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.instInsertOrdnode"><span class="name">Ordnode</span>.<span class="name">instInsertOrdnode</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.insert'"><span class="name">Ordnode</span>.<span class="name">insert'</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.split"><span class="name">Ordnode</span>.<span class="name">split</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.split3"><span class="name">Ordnode</span>.<span class="name">split3</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.erase"><span class="name">Ordnode</span>.<span class="name">erase</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findLtAux"><span class="name">Ordnode</span>.<span class="name">findLtAux</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findLt"><span class="name">Ordnode</span>.<span class="name">findLt</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findGtAux"><span class="name">Ordnode</span>.<span class="name">findGtAux</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findGt"><span class="name">Ordnode</span>.<span class="name">findGt</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findLeAux"><span class="name">Ordnode</span>.<span class="name">findLeAux</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findLe"><span class="name">Ordnode</span>.<span class="name">findLe</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findGeAux"><span class="name">Ordnode</span>.<span class="name">findGeAux</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findGe"><span class="name">Ordnode</span>.<span class="name">findGe</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findIndexAux"><span class="name">Ordnode</span>.<span class="name">findIndexAux</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.findIndex"><span class="name">Ordnode</span>.<span class="name">findIndex</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.isSubsetAux"><span class="name">Ordnode</span>.<span class="name">isSubsetAux</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.isSubset"><span class="name">Ordnode</span>.<span class="name">isSubset</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.disjoint"><span class="name">Ordnode</span>.<span class="name">disjoint</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.union"><span class="name">Ordnode</span>.<span class="name">union</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.diff"><span class="name">Ordnode</span>.<span class="name">diff</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.inter"><span class="name">Ordnode</span>.<span class="name">inter</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.ofList"><span class="name">Ordnode</span>.<span class="name">ofList</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.ofList'"><span class="name">Ordnode</span>.<span class="name">ofList'</span></a></div><div class="nav_link"><a class="break_within" href="#Ordnode.image"><span class="name">Ordnode</span>.<span class="name">image</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Ordered-sets">Ordered sets <a class="hover-link" href="#Ordered-sets">#</a></h1><p>This file defines a data structure for ordered sets, supporting a
variety of useful operations including insertion and deletion,
logarithmic time lookup, set operations, folds,
and conversion from lists.</p><p>The <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> α</code> operations all assume that <code>α</code> has the structure of
a total preorder, meaning a <code>≤</code> operation that is</p><ul>
<li>Transitive: <code>x ≤ y → y ≤ z → x ≤ z</code></li>
<li>Reflexive: <code>x ≤ x</code></li>
<li>Total: <code>x ≤ y ∨ y ≤ x</code></li>
</ul><p>For example, in order to use this data structure as a map type, one
can store pairs <code>(k, v)</code> where <code>(k, v) ≤ (k', v')</code> is defined to mean
<code>k ≤ k'</code> (assuming that the key values are linearly ordered).</p><p>Two values <code>x,y</code> are equivalent if <code>x ≤ y</code> and <code>y ≤ x</code>. An <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> α</code>
maintains the invariant that it never stores two equivalent nodes;
the insertion operation comes with two variants depending on whether
you want to keep the old value or the new value in case you insert a value
that is equivalent to one in the set.</p><p>The operations in this file are not verified, in the sense that they provide
"raw operations" that work for programming purposes but the invariants
are not explicitly in the structure. See <code>Ordset</code> for a verified version
of this data structure.</p><h2 class="markdown-heading" id="Main-definitions">Main definitions <a class="hover-link" href="#Main-definitions">#</a></h2><ul>
<li><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> α</code>: A set of values of type <code>α</code></li>
</ul><h2 class="markdown-heading" id="Implementation-notes">Implementation notes <a class="hover-link" href="#Implementation-notes">#</a></h2><p>Based on weight balanced trees:</p><ul>
<li>Stephen Adams, "Efficient sets: a balancing act",
Journal of Functional Programming 3(4):553-562, October 1993,
<http://www.swiss.ai.mit.edu/~adams/BB/>.</li>
<li>J. Nievergelt and E.M. Reingold,
"Binary search trees of bounded balance",
SIAM journal of computing 2(1), March 1973.</li>
</ul><p>Ported from Haskell's <code>Data.<a href="../../.././Mathlib/Init/Set.html#Set">Set</a></code>.</p><h2 class="markdown-heading" id="Tags">Tags <a class="hover-link" href="#Tags">#</a></h2><p>ordered map, ordered set, data structure</p></div><div class="decl" id="Ordnode"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L75-L77">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode"><span class="name">Ordnode</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> u</div></div><p>An <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> α</code> is a finite set of values, represented as a tree.
The operations on this type maintain that the tree is balanced
and correctly stores subtree sizes at each level.</p><ul class="constructors"><li class="constructor" id="Ordnode.nil">nil: <span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u} → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></li><li class="constructor" id="Ordnode.node">node: <span class="fn">{<span class="fn">α</span> : <a href="../../.././foundational_types.html">Type</a> u} → <span class="fn"><a href="../../.././Init/Prelude.html#Nat">ℕ</a> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></span></span></span></span></li></ul><details id="instances-for-list-Ordnode" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.instEmptyCollectionOrdnode"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L87-L88">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instEmptyCollectionOrdnode"><span class="name">Ordnode</span>.<span class="name">instEmptyCollectionOrdnode</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Core.html#EmptyCollection">EmptyCollection</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Ordnode.instEmptyCollectionOrdnode</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">emptyCollection</span> := <span class="fn">Ordnode.nil</span> }</span></span></li></ul></details></div></div><div class="decl" id="Ordnode.instInhabitedOrdnode"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L90-L91">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instInhabitedOrdnode"><span class="name">Ordnode</span>.<span class="name">instInhabitedOrdnode</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Ordnode.instInhabitedOrdnode</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">Ordnode.nil</span> }</span></span></li></ul></details></div></div><div class="decl" id="Ordnode.delta"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L102-L103">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.delta"><span class="name">Ordnode</span>.<span class="name">delta</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Nat">ℕ</a></div></div><p><strong>Internal use only</strong></p><p>The maximal relative difference between the sizes of
two trees, it corresponds with the <code>w</code> in Adams' paper.</p><p>According to the Haskell comment, only <code>(delta, ratio)</code> settings
of <code>(3, 2)</code> and <code>(4, 2)</code> will work, and the proofs in
<code>Ordset.lean</code> assume <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.delta">delta</a> := 3</code> and <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ratio">ratio</a> := 2</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.delta">Ordnode.delta</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">3</span></span></li></ul></details><details id="instances-for-list-Ordnode.delta" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.ratio"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L114-L115">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ratio"><span class="name">Ordnode</span>.<span class="name">ratio</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Nat">ℕ</a></div></div><p><strong>Internal use only</strong></p><p>The ratio between an outer and inner sibling of the
heavier subtree in an unbalanced setting. It determines
whether a double or single rotation should be performed
to restore balance. It is corresponds with the inverse
of <code>α</code> in Adam's article.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ratio">Ordnode.ratio</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">2</span></span></li></ul></details><details id="instances-for-list-Ordnode.ratio" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.singleton"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L122-L123">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.singleton"><span class="name">Ordnode</span>.<span class="name">singleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></div></div><p>O(1). Construct a singleton set containing value <code>a</code>.</p><p>singleton 3 = {3}</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.singleton">Ordnode.singleton</a> <span class="fn">a</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">1</span> <span class="fn">Ordnode.nil</span> <span class="fn">a</span> <span class="fn">Ordnode.nil</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.singleton" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.instSingletonOrdnode"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L129-L130">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instSingletonOrdnode"><span class="name">Ordnode</span>.<span class="name">instSingletonOrdnode</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Classes/SetNotation.html#Singleton">Singleton</a> <span class="fn">α</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Ordnode.instSingletonOrdnode</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">singleton</span> := <span class="fn">Ordnode.singleton</span> }</span></span></li></ul></details></div></div><div class="decl" id="Ordnode.size"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L136-L138">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size"><span class="name">Ordnode</span>.<span class="name">size</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <a href="../../.././Init/Prelude.html#Nat">ℕ</a></span></div></div><p>O(1). Get the size of the set.</p><p>size {2, 1, 1, 4} = 3</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">Ordnode.size</a> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">x</span> with
  | <span class="fn">Ordnode.nil</span> =&gt; <span class="fn">0</span>
  | <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x</span> <span class="fn">r</span></span> =&gt; <span class="fn">sz</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.size" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.size_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L141-L142">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size_nil"><span class="name">Ordnode</span>.<span class="name">size_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">Ordnode.size</a> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></span></div></div></div></div><div class="decl" id="Ordnode.size_node"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L143-L144">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size_node"><span class="name">Ordnode</span>.<span class="name">size_node</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(sz : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(l : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(r : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">Ordnode.size</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x</span> <span class="fn">r</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">sz</span></span></div></div></div></div><div class="decl" id="Ordnode.empty"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L154-L156">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.empty"><span class="name">Ordnode</span>.<span class="name">empty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>O(1). Is the set empty?</p><p>empty ∅ = tt
empty {1, 2, 3} = ff</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.empty">Ordnode.empty</a> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">x</span> with
  | <span class="fn">Ordnode.nil</span> =&gt; <a href="../../.././Init/Prelude.html#Bool.true">true</a>
  | <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x</span> <span class="fn">r</span></span> =&gt; <span class="fn">false</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.empty" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.dual"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L165-L167">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dual"><span class="name">Ordnode</span>.<span class="name">dual</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p><strong>Internal use only</strong>, because it violates the BST property on the original order.</p><p>O(n). The dual of a tree is a tree with its left and right sides reversed throughout.
The dual of a valid BST is valid under the dual order. This is convenient for exploiting
symmetries in the algorithms.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dual">Ordnode.dual</a> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">Ordnode.nil</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dual">Ordnode.dual</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">r</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dual">Ordnode.dual</a> <span class="fn">r</span></span>)</span> <span class="fn">x_1</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dual">Ordnode.dual</a> <span class="fn">l</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.dual" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.node'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L174-L175">source</a></div><div class="attributes">@[inline, reducible]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node'"><span class="name">Ordnode</span>.<span class="name">node'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(l : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(r : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></div></div><p><strong>Internal use only</strong></p><p>O(1). Construct a node with the correct size information, without rebalancing.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node'">Ordnode.node'</a> <span class="fn">l</span> <span class="fn">x</span> <span class="fn">r</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">Ordnode.size</a> <span class="fn">l</span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">Ordnode.size</a> <span class="fn">r</span></span></span> <a href="../../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></span>)</span> <span class="fn">l</span> <span class="fn">x</span> <span class="fn">r</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.node'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.repr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L181-L188">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.repr"><span class="name">Ordnode</span>.<span class="name">repr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Data/Repr.html#Repr">Repr</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(o : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(n : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Data/Format/Basic.html#Std.Format">Lean.Format</a></div></div><p>Basic pretty printing for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> α</code> that shows the structure of the tree.</p><p>repr {3, 1, 2, 4} = ((∅ 1 ∅) 2 ((∅ 3 ∅) 4 ∅))</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.repr">Ordnode.repr</a> <span class="fn">Ordnode.nil</span> <span class="fn">n</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Data/Format/Basic.html#Std.Format.text">Std.Format.text</a> <span class="fn">&quot;∅&quot;</span></span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.repr">Ordnode.repr</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">r</span></span>)</span> <span class="fn">n</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">let fmt := <span class="fn"><a href="../../.././Init/Data/Format/Basic.html#Std.Format.joinSep">Lean.Format.joinSep</a> <span class="fn">[<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.repr">Ordnode.repr</a> <span class="fn">l</span> <span class="fn">n</span></span>, <span class="fn"><a href="../../.././Init/Data/Repr.html#Repr.reprPrec">reprPrec</a> <span class="fn">x_1</span> <span class="fn">n</span></span>, <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.repr">Ordnode.repr</a> <span class="fn">r</span> <span class="fn">n</span></span>]</span> <span class="fn">(<span class="fn"><a href="../../.././Init/Data/Format/Basic.html#Std.Format.text">Std.Format.text</a> <span class="fn">&quot; &quot;</span></span>)</span></span>;
  <span class="fn"><a href="../../.././Init/Data/Format/Basic.html#Std.Format.paren">Lean.Format.paren</a> <span class="fn">fmt</span></span></span></span></li></ul></details><details id="instances-for-list-Ordnode.repr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.instReprOrdnode"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L191-L192">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instReprOrdnode"><span class="name">Ordnode</span>.<span class="name">instReprOrdnode</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Data/Repr.html#Repr">Repr</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/Repr.html#Repr">Repr</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Ordnode.instReprOrdnode</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">reprPrec</span> := <span class="fn">Ordnode.repr</span> }</span></span></li></ul></details></div></div><div class="decl" id="Ordnode.balanceL"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L199-L228">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceL"><span class="name">Ordnode</span>.<span class="name">balanceL</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(l : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(r : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></div></div><p><strong>Internal use only</strong></p><p>O(1). Rebalance a tree which was previously balanced but has had its left
side grow by 1, or its right side shrink by 1.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Ordnode.balanceL" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.balanceR"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L235-L264">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceR"><span class="name">Ordnode</span>.<span class="name">balanceR</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(l : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(r : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></div></div><p><strong>Internal use only</strong></p><p>O(1). Rebalance a tree which was previously balanced but has had its right
side grow by 1, or its left side shrink by 1.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Ordnode.balanceR" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.balance"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L271-L322">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balance"><span class="name">Ordnode</span>.<span class="name">balance</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(l : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(r : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></div></div><p><strong>Internal use only</strong></p><p>O(1). Rebalance a tree which was previously balanced but has had one side change
by at most 1.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Ordnode.balance" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.All"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L329-L331">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All"><span class="name">Ordnode</span>.<span class="name">All</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(P : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span></div></div><p>O(n). Does every element of the map satisfy property <code>P</code>?</p><p>All (fun x ↦ x < 5) {1, 2, 3} = True
All (fun x ↦ x < 5) {1, 2, 3, 5} = False</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All">Ordnode.All</a> <span class="fn">P</span> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#True">True</a></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All">Ordnode.All</a> <span class="fn">P</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">r</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All">Ordnode.All</a> <span class="fn">P</span> <span class="fn">l</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">x_1</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All">Ordnode.All</a> <span class="fn">P</span> <span class="fn">r</span></span></span></span>)</span></span></li></ul></details><details id="instances-for-list-Ordnode.All" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.All.decidable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L334-L339">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All.decidable"><span class="name">Ordnode</span>.<span class="name">All</span>.<span class="name">decidable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(t : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidablePred">DecidablePred</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All">Ordnode.All</a> <span class="fn">P</span> <span class="fn">t</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All.decidable">Ordnode.All.decidable</a> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Init/Logic.html#decidableTrue">decidableTrue</a></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All.decidable">Ordnode.All.decidable</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">r</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">let_fun this := <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All.decidable">Ordnode.All.decidable</a> <span class="fn">l</span></span>;
  <span class="fn">let_fun this_1 := <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All.decidable">Ordnode.All.decidable</a> <span class="fn">r</span></span>;
  <span class="fn">And.decidable</span></span></span></span></li></ul></details></div></div><div class="decl" id="Ordnode.Any"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L346-L348">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any"><span class="name">Ordnode</span>.<span class="name">Any</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(P : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span></div></div><p>O(n). Does any element of the map satisfy property <code>P</code>?</p><p>Any (fun x ↦ x < 2) {1, 2, 3} = True
Any (fun x ↦ x < 2) {2, 3, 5} = False</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any">Ordnode.Any</a> <span class="fn">P</span> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#False">False</a></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any">Ordnode.Any</a> <span class="fn">P</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">r</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any">Ordnode.Any</a> <span class="fn">P</span> <span class="fn">l</span></span> <a href="../../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">x_1</span></span> <a href="../../.././Init/Prelude.html#Or">∨</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any">Ordnode.Any</a> <span class="fn">P</span> <span class="fn">r</span></span></span></span>)</span></span></li></ul></details><details id="instances-for-list-Ordnode.Any" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.Any.decidable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L351-L356">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any.decidable"><span class="name">Ordnode</span>.<span class="name">Any</span>.<span class="name">decidable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(t : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidablePred">DecidablePred</a> <span class="fn">P</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any">Ordnode.Any</a> <span class="fn">P</span> <span class="fn">t</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any.decidable">Ordnode.Any.decidable</a> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Mathlib/Init/Logic.html#decidableFalse">decidableFalse</a></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any.decidable">Ordnode.Any.decidable</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">r</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">let_fun this := <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any.decidable">Ordnode.Any.decidable</a> <span class="fn">l</span></span>;
  <span class="fn">let_fun this_1 := <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any.decidable">Ordnode.Any.decidable</a> <span class="fn">r</span></span>;
  <span class="fn">Or.decidable</span></span></span></span></li></ul></details></div></div><div class="decl" id="Ordnode.Emem"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L365-L366">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem"><span class="name">Ordnode</span>.<span class="name">Emem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span></div></div><p>O(n). Exact membership in the set. This is useful primarily for stating
correctness properties; use <code>∈</code> for a version that actually uses the BST property
of the tree.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem">Emem</a> 2 {1, 2, 3} = true
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem">Emem</a> 4 {1, 2, 3} = false 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem">Ordnode.Emem</a> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any">Ordnode.Any</a> <span class="fn">(<span class="fn"><a href="../../.././Init/Prelude.html#Eq">Eq</a> <span class="fn">x</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.Emem" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.Emem.decidable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L369-L370">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem.decidable"><span class="name">Ordnode</span>.<span class="name">Emem</span>.<span class="name">decidable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(t : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem">Ordnode.Emem</a> <span class="fn">x</span> <span class="fn">t</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem.decidable">Ordnode.Emem.decidable</a> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#id">id</a> <span class="fn">inferInstance</span></span></span></li></ul></details></div></div><div class="decl" id="Ordnode.Amem"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L390-L391">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem"><span class="name">Ordnode</span>.<span class="name">Amem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <a href="../../.././foundational_types.html">Prop</a></span></div></div><p>O(n). Approximate membership in the set, that is, whether some element in the
set is equivalent to this one in the preorder. This is useful primarily for stating
correctness properties; use <code>∈</code> for a version that actually uses the BST property
of the tree.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem">Amem</a> 2 {1, 2, 3} = true
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem">Amem</a> 4 {1, 2, 3} = false
</code></pre><p>To see the difference with <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem">Emem</a></code>, we need a preorder that is not a partial order.
For example, suppose we compare pairs of numbers using only their first coordinate. Then:
-- Porting note: Verify below example
emem (0, 1) {(0, 0), (1, 2)} = false
amem (0, 1) {(0, 0), (1, 2)} = true
(0, 1) ∈ {(0, 0), (1, 2)} = true</p><p>The <code>∈</code> relation is equivalent to <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem">Amem</a></code> as long as the <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a></code> is well formed,
and should always be used instead of <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem">Amem</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem">Ordnode.Amem</a> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any">Ordnode.Any</a> <span class="fn">fun (<span class="fn">y</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">y</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">y</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x</span></span></span></span></span></span></li></ul></details><details id="instances-for-list-Ordnode.Amem" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.Amem.decidable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L394-L396">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem.decidable"><span class="name">Ordnode</span>.<span class="name">Amem</span>.<span class="name">decidable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(t : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem">Ordnode.Amem</a> <span class="fn">x</span> <span class="fn">t</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem.decidable">Ordnode.Amem.decidable</a> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#id">id</a> <span class="fn">inferInstance</span></span></span></li></ul></details></div></div><div class="decl" id="Ordnode.findMin'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L403-L405">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMin'"><span class="name">Ordnode</span>.<span class="name">findMin'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><span class="fn">α</span> → <span class="fn">α</span></span></span></div></div><p>O(log n). Return the minimum element of the tree, or the provided default value.</p><p>findMin' 37 {1, 2, 3} = 1
findMin' 37 ∅ = 37</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMin'">Ordnode.findMin'</a> <span class="fn">Ordnode.nil</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMin'">Ordnode.findMin'</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span></span>)</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMin'">Ordnode.findMin'</a> <span class="fn">l</span> <span class="fn">x_2</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.findMin'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findMin"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L412-L414">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMin"><span class="name">Ordnode</span>.<span class="name">findMin</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Return the minimum element of the tree, if it exists.</p><p>findMin {1, 2, 3} = some 1
findMin ∅ = none</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMin">Ordnode.findMin</a> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">x</span> with
  | <span class="fn">Ordnode.nil</span> =&gt; <span class="fn">none</span>
  | <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x</span> <span class="fn">r</span></span> =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMin'">Ordnode.findMin'</a> <span class="fn">l</span> <span class="fn">x</span></span>)</span></span></span></span></li></ul></details><details id="instances-for-list-Ordnode.findMin" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findMax'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L421-L423">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMax'"><span class="name">Ordnode</span>.<span class="name">findMax'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn">α</span></span></span></div></div><p>O(log n). Return the maximum element of the tree, or the provided default value.</p><p>findMax' 37 {1, 2, 3} = 3
findMax' 37 ∅ = 37</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMax'">Ordnode.findMax'</a> <span class="fn">x</span> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMax'">Ordnode.findMax'</a> <span class="fn">x</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x_3</span> <span class="fn">r</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMax'">Ordnode.findMax'</a> <span class="fn">x_3</span> <span class="fn">r</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.findMax'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findMax"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L430-L432">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMax"><span class="name">Ordnode</span>.<span class="name">findMax</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Return the maximum element of the tree, if it exists.</p><p>findMax {1, 2, 3} = some 3
findMax ∅ = none</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMax">Ordnode.findMax</a> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">x</span> with
  | <span class="fn">Ordnode.nil</span> =&gt; <span class="fn">none</span>
  | <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x</span> <span class="fn">r</span></span> =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMax'">Ordnode.findMax'</a> <span class="fn">x</span> <span class="fn">r</span></span>)</span></span></span></span></li></ul></details><details id="instances-for-list-Ordnode.findMax" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.eraseMin"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L439-L442">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMin"><span class="name">Ordnode</span>.<span class="name">eraseMin</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Remove the minimum element from the tree, or do nothing if it is already empty.</p><p>eraseMin {1, 2, 3} = {2, 3}
eraseMin ∅ = ∅</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMin">Ordnode.eraseMin</a> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">Ordnode.nil</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMin">Ordnode.eraseMin</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">Ordnode.nil</span> <span class="fn">x_1</span> <span class="fn">r</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">r</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMin">Ordnode.eraseMin</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l'</span> <span class="fn">y</span> <span class="fn">r'</span></span>)</span> <span class="fn">x_1</span> <span class="fn">r</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceR">Ordnode.balanceR</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMin">Ordnode.eraseMin</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l'</span> <span class="fn">y</span> <span class="fn">r'</span></span>)</span></span>)</span> <span class="fn">x_1</span> <span class="fn">r</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.eraseMin" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.eraseMax"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L449-L452">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMax"><span class="name">Ordnode</span>.<span class="name">eraseMax</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Remove the maximum element from the tree, or do nothing if it is already empty.</p><p>eraseMax {1, 2, 3} = {1, 2}
eraseMax ∅ = ∅</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMax">Ordnode.eraseMax</a> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">Ordnode.nil</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMax">Ordnode.eraseMax</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">Ordnode.nil</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMax">Ordnode.eraseMax</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l'</span> <span class="fn">y</span> <span class="fn">r'</span></span>)</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceL">Ordnode.balanceL</a> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMax">Ordnode.eraseMax</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l'</span> <span class="fn">y</span> <span class="fn">r'</span></span>)</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.eraseMax" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.splitMin'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L458-L462">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMin'"><span class="name">Ordnode</span>.<span class="name">splitMin'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></span></span></span></div></div><p><strong>Internal use only</strong>, because it requires a balancing constraint on the inputs.</p><p>O(log n). Extract and remove the minimum element from a nonempty tree.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMin'">Ordnode.splitMin'</a> <span class="fn">Ordnode.nil</span> <span class="fn">x✝</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">x✝</span>, <span class="fn">x</span>)</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMin'">Ordnode.splitMin'</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">ll</span> <span class="fn">lx</span> <span class="fn">lr</span></span>)</span> <span class="fn">x✝</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMin'">Ordnode.splitMin'</a> <span class="fn">ll</span> <span class="fn">lx</span> <span class="fn">lr</span></span> with
  | <span class="fn">(<span class="fn">xm</span>, <span class="fn">l'</span>)</span> =&gt; <span class="fn">(<span class="fn">xm</span>, <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceR">Ordnode.balanceR</a> <span class="fn">l'</span> <span class="fn">x✝</span> <span class="fn">x</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.splitMin'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.splitMin"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L469-L471">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMin"><span class="name">Ordnode</span>.<span class="name">splitMin</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn"><span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span>)</span></span></span></div></div><p>O(log n). Extract and remove the minimum element from the tree, if it exists.</p><p>split_min {1, 2, 3} = some (1, {2, 3})
split_min ∅ = none</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMin">Ordnode.splitMin</a> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">x</span> with
  | <span class="fn">Ordnode.nil</span> =&gt; <span class="fn">none</span>
  | <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x</span> <span class="fn">r</span></span> =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMin'">Ordnode.splitMin'</a> <span class="fn">l</span> <span class="fn">x</span> <span class="fn">r</span></span>)</span></span></span></span></li></ul></details><details id="instances-for-list-Ordnode.splitMin" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.splitMax'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L477-L481">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMax'"><span class="name">Ordnode</span>.<span class="name">splitMax'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">α</span></span></span></span></span></div></div><p><strong>Internal use only</strong>, because it requires a balancing constraint on the inputs.</p><p>O(log n). Extract and remove the maximum element from a nonempty tree.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMax'">Ordnode.splitMax'</a> <span class="fn">x✝</span> <span class="fn">x</span> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">x✝</span>, <span class="fn">x</span>)</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMax'">Ordnode.splitMax'</a> <span class="fn">x✝</span> <span class="fn">x</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">rl</span> <span class="fn">rx</span> <span class="fn">rr</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMax'">Ordnode.splitMax'</a> <span class="fn">rl</span> <span class="fn">rx</span> <span class="fn">rr</span></span> with
  | <span class="fn">(<span class="fn">r'</span>, <span class="fn">xm</span>)</span> =&gt; <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceL">Ordnode.balanceL</a> <span class="fn">x✝</span> <span class="fn">x</span> <span class="fn">r'</span></span>, <span class="fn">xm</span>)</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.splitMax'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.splitMax"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L488-L490">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMax"><span class="name">Ordnode</span>.<span class="name">splitMax</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">α</span></span>)</span></span></span></div></div><p>O(log n). Extract and remove the maximum element from the tree, if it exists.</p><p>split_max {1, 2, 3} = some ({1, 2}, 3)
split_max ∅ = none</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMax">Ordnode.splitMax</a> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">x</span> with
  | <span class="fn">Ordnode.nil</span> =&gt; <span class="fn">none</span>
  | <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">r</span></span> =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMax'">Ordnode.splitMax'</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">r</span></span>)</span></span></span></span></li></ul></details><details id="instances-for-list-Ordnode.splitMax" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.glue"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L496-L505">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.glue"><span class="name">Ordnode</span>.<span class="name">glue</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p><strong>Internal use only</strong></p><p>O(log(m + n)). Concatenate two trees that are balanced and ordered with respect to each other.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Ordnode.glue" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.merge"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L512-L520">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.merge"><span class="name">Ordnode</span>.<span class="name">merge</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(l : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(log(m + n)). Concatenate two trees that are ordered with respect to each other.</p><p>merge {1, 2} {3, 4} = {1, 2, 3, 4}
merge {3, 4} {1, 2} = precondition violation</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Ordnode.merge" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.insertMax"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L528-L530">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMax"><span class="name">Ordnode</span>.<span class="name">insertMax</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><span class="fn">α</span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></span></div></div><p>O(log n). Insert an element above all the others, without any comparisons.
(Assumes that the element is in fact above all the others).</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMax">insertMax</a> {1, 2} 4 = {1, 2, 4}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMax">insertMax</a> {1, 2} 0 = precondition violation 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMax">Ordnode.insertMax</a> <span class="fn">Ordnode.nil</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.singleton">Ordnode.singleton</a> <span class="fn">x</span></span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMax">Ordnode.insertMax</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span></span>)</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceR">Ordnode.balanceR</a> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMax">Ordnode.insertMax</a> <span class="fn">r</span> <span class="fn">x</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.insertMax" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.insertMin"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L538-L540">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMin"><span class="name">Ordnode</span>.<span class="name">insertMin</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Insert an element below all the others, without any comparisons.
(Assumes that the element is in fact below all the others).</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMin">insertMin</a> {1, 2} 0 = {0, 1, 2}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMin">insertMin</a> {1, 2} 4 = precondition violation 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMin">Ordnode.insertMin</a> <span class="fn">x</span> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.singleton">Ordnode.singleton</a> <span class="fn">x</span></span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMin">Ordnode.insertMin</a> <span class="fn">x</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceR">Ordnode.balanceR</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMin">Ordnode.insertMin</a> <span class="fn">x</span> <span class="fn">l</span></span>)</span> <span class="fn">x_2</span> <span class="fn">r</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.insertMin" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.link"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L548-L564">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.link"><span class="name">Ordnode</span>.<span class="name">link</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(l : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(log(m+n)). Build a tree from an element between two trees, without any
assumption on the relative sizes.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.link">link</a> {1, 2} 4 {5, 6} = {1, 2, 4, 5, 6}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.link">link</a> {1, 3} 2 {5} = precondition violation 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.link">Ordnode.link</a> <span class="fn">Ordnode.nil</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMin">Ordnode.insertMin</a> <span class="fn">x</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.link" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.filter"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L571-L575">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.filter"><span class="name">Ordnode</span>.<span class="name">filter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidablePred">DecidablePred</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(n). Filter the elements of a tree satisfying a predicate.</p><p>filter (fun x ↦ x < 3) {1, 2, 4} = {1, 2}
filter (fun x ↦ x > 5) {1, 2, 4} = ∅</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.filter">Ordnode.filter</a> <span class="fn">p</span> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">Ordnode.nil</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.filter">Ordnode.filter</a> <span class="fn">p</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">r</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if <span class="fn"><span class="fn">p</span> <span class="fn">x_1</span></span> then <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.link">Ordnode.link</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.filter">Ordnode.filter</a> <span class="fn">p</span> <span class="fn">l</span></span>)</span> <span class="fn">x_1</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.filter">Ordnode.filter</a> <span class="fn">p</span> <span class="fn">r</span></span>)</span></span>
  else <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.merge">Ordnode.merge</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.filter">Ordnode.filter</a> <span class="fn">p</span> <span class="fn">l</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.filter">Ordnode.filter</a> <span class="fn">p</span> <span class="fn">r</span></span>)</span></span></span></span></li></ul></details><details id="instances-for-list-Ordnode.filter" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.partition"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L581-L586">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.partition"><span class="name">Ordnode</span>.<span class="name">partition</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidablePred">DecidablePred</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></span></div></div><p>O(n). Split the elements of a tree into those satisfying, and not satisfying, a predicate.</p><p>partition (fun x ↦ x < 3) {1, 2, 4} = ({1, 2}, {3})</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.partition">Ordnode.partition</a> <span class="fn">p</span> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">Ordnode.nil</span>, <span class="fn">Ordnode.nil</span>)</span></span></li></ul></details><details id="instances-for-list-Ordnode.partition" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L600-L602">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.map"><span class="name">Ordnode</span>.<span class="name">map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">β</span></span></span></div></div><p>O(n). Map a function across a tree, without changing the structure. Only valid when
the function is strictly monotone, i.e. <code>x &lt; y → f x &lt; f y</code>.</p><pre><code> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.partition">partition</a> (fun x ↦ x + 2) {1, 2, 4} = {2, 3, 6}
 <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.partition">partition</a> (λ x : ℕ, x - 2) {1, 2, 4} = precondition violation 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.map">Ordnode.map</a> <span class="fn">f</span> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">Ordnode.nil</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.map">Ordnode.map</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">r</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.map">Ordnode.map</a> <span class="fn">f</span> <span class="fn">l</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">x_1</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.map">Ordnode.map</a> <span class="fn">f</span> <span class="fn">r</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.map" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.fold"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L617-L619">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.fold"><span class="name">Ordnode</span>.<span class="name">fold</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(z : <span class="fn">β</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn">β</span></span></div></div><p>O(n). Fold a function across the structure of a tree.</p><pre><code> <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.fold">fold</a> z f {1, 2, 4} = f (f z 1 z) 2 (f z 4 z)
</code></pre><p>The exact structure of function applications depends on the tree and so
is unspecified.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.fold">Ordnode.fold</a> <span class="fn">z</span> <span class="fn">f</span> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">z</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.fold">Ordnode.fold</a> <span class="fn">z</span> <span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">r</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.fold">Ordnode.fold</a> <span class="fn">z</span> <span class="fn">f</span> <span class="fn">l</span></span>)</span> <span class="fn">x_1</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.fold">Ordnode.fold</a> <span class="fn">z</span> <span class="fn">f</span> <span class="fn">r</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.fold" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.foldl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L631-L633">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldl"><span class="name">Ordnode</span>.<span class="name">foldl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn">β</span></span></span></div></div><p>O(n). Fold a function from left to right (in increasing order) across the tree.</p><p>foldl f z {1, 2, 4} = f (f (f z 1) 2) 4</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldl">Ordnode.foldl</a> <span class="fn">f</span> <span class="fn">x</span> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldl">Ordnode.foldl</a> <span class="fn">f</span> <span class="fn">x</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldl">Ordnode.foldl</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldl">Ordnode.foldl</a> <span class="fn">f</span> <span class="fn">x</span> <span class="fn">l</span></span>)</span> <span class="fn">x_2</span></span>)</span> <span class="fn">r</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.foldl" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.foldr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L645-L647">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldr"><span class="name">Ordnode</span>.<span class="name">foldr</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Sort</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><span class="fn">β</span> → <span class="fn">β</span></span></span></div></div><p>O(n). Fold a function from right to left (in decreasing order) across the tree.</p><p>foldr f {1, 2, 4} z = f 1 (f 2 (f 4 z))</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldr">Ordnode.foldr</a> <span class="fn">f</span> <span class="fn">Ordnode.nil</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldr">Ordnode.foldr</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span></span>)</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldr">Ordnode.foldr</a> <span class="fn">f</span> <span class="fn">l</span> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">x_2</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldr">Ordnode.foldr</a> <span class="fn">f</span> <span class="fn">r</span> <span class="fn">x</span></span>)</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.foldr" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.toList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L654-L655">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toList"><span class="name">Ordnode</span>.<span class="name">toList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(t : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span></div></div><p>O(n). Build a list of elements in ascending order from the tree.</p><p>toList {1, 2, 4} = [1, 2, 4]
toList {2, 1, 1, 4} = [1, 2, 4]</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toList">Ordnode.toList</a> <span class="fn">t</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldr">Ordnode.foldr</a> <span class="fn">List.cons</span> <span class="fn">t</span> <span class="fn">[]</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.toList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.toRevList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L662-L663">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toRevList"><span class="name">Ordnode</span>.<span class="name">toRevList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(t : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span></div></div><p>O(n). Build a list of elements in descending order from the tree.</p><p>toRevList {1, 2, 4} = [4, 2, 1]
toRevList {2, 1, 1, 4} = [4, 2, 1]</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toRevList">Ordnode.toRevList</a> <span class="fn">t</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldl">Ordnode.foldl</a> <span class="fn">(<span class="fn"><a href="../../.././Init/Core.html#flip">flip</a> <span class="fn">List.cons</span></span>)</span> <span class="fn">[]</span> <span class="fn">t</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.toRevList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.instToStringOrdnode"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L666-L667">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instToStringOrdnode"><span class="name">Ordnode</span>.<span class="name">instToStringOrdnode</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Data/ToString/Basic.html#ToString">ToString</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/ToString/Basic.html#ToString">ToString</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Ordnode.instToStringOrdnode</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">toString</span> := <span class="fn">fun (<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>) =&gt; <span class="fn"><span class="fn"><span class="fn">&quot;{&quot;</span> <a href="../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn"><a href="../../.././Init/Data/String/Basic.html#String.intercalate">String.intercalate</a> <span class="fn">&quot;, &quot;</span> <span class="fn">(<span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">toString</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toList">Ordnode.toList</a> <span class="fn">t</span></span>)</span></span>)</span></span></span> <a href="../../.././Init/Prelude.html#HAppend.hAppend">++</a> <span class="fn">&quot;}&quot;</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Ordnode.instToFormatOrdnode"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L670-L671">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instToFormatOrdnode"><span class="name">Ordnode</span>.<span class="name">instToFormatOrdnode</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Data/Format/Basic.html#Std.ToFormat">Lean.ToFormat</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/Format/Basic.html#Std.ToFormat">Lean.ToFormat</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Ordnode.instToFormatOrdnode</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{
    <span class="fn">format</span> := <span class="fn">fun (<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>) =&gt;
      <span class="fn"><a href="../../.././Init/Data/Format/Basic.html#Std.Format.joinSep">Lean.Format.joinSep</a> <span class="fn">(<span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">Std.format</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toList">Ordnode.toList</a> <span class="fn">t</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Init/Data/Format/Basic.html#Std.Format.text">Std.Format.text</a> <span class="fn">&quot;, &quot;</span></span>)</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Ordnode.Equiv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L677-L678">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Equiv"><span class="name">Ordnode</span>.<span class="name">Equiv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(t₁ : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(t₂ : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>O(n). True if the trees have the same elements, ignoring structural differences.</p><p>Equiv {1, 2, 4} {2, 1, 1, 4} = true
Equiv {1, 2, 4} {1, 2, 3} = false</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Equiv">Ordnode.Equiv</a> <span class="fn">t₁</span> <span class="fn">t₂</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">Ordnode.size</a> <span class="fn">t₁</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">Ordnode.size</a> <span class="fn">t₂</span></span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toList">Ordnode.toList</a> <span class="fn">t₁</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toList">Ordnode.toList</a> <span class="fn">t₂</span></span></span></span>)</span></span></li></ul></details><details id="instances-for-list-Ordnode.Equiv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.instDecidableRelOrdnodeEquiv"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L681-L681">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instDecidableRelOrdnodeEquiv"><span class="name">Ordnode</span>.<span class="name">instDecidableRelOrdnodeEquiv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">Ordnode.Equiv</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instDecidableRelOrdnodeEquiv">Ordnode.instDecidableRelOrdnodeEquiv</a> <span class="fn">x✝</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">And.decidable</span></span></li></ul></details></div></div><div class="decl" id="Ordnode.powerset"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L686-L687">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.powerset"><span class="name">Ordnode</span>.<span class="name">powerset</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(t : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span></div></div><p>O(2^n). Constructs the powerset of a given set, that is, the set of all subsets.</p><p>powerset {1, 2, 3} = {∅, {1}, {2}, {3}, {1,2}, {1,3}, {2,3}, {1,2,3}}</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Ordnode.powerset" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.prod"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L693-L694">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.prod"><span class="name">Ordnode</span>.<span class="name">prod</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(t₁ : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(t₂ : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">(<span class="fn"><span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span></div></div><p>O(m * n). The cartesian product of two sets: <code>(a, b) ∈ s.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.prod">prod</a> t</code> iff <code>a ∈ s</code> and <code>b ∈ t</code>.</p><p>prod {1, 2} {2, 3} = {(1, 2), (1, 3), (2, 2), (2, 3)}</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.prod">Ordnode.prod</a> <span class="fn">t₁</span> <span class="fn">t₂</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.fold">Ordnode.fold</a> <span class="fn">Ordnode.nil</span>
    <span class="fn">(<span class="fn">fun (<span class="fn">s₁</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">(<span class="fn"><span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span>) (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">s₂</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">(<span class="fn"><span class="fn">α</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span>) =&gt;
      <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.merge">Ordnode.merge</a> <span class="fn">s₁</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.merge">Ordnode.merge</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.map">Ordnode.map</a> <span class="fn">(<span class="fn"><a href="../../.././Init/Prelude.html#Prod.mk">Prod.mk</a> <span class="fn">a</span></span>)</span> <span class="fn">t₂</span></span>)</span> <span class="fn">s₂</span></span>)</span></span></span>)</span>
    <span class="fn">t₁</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.prod" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.copair"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L701-L702">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.copair"><span class="name">Ordnode</span>.<span class="name">copair</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(t₁ : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(t₂ : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">(<span class="fn"><span class="fn">α</span> <a href="../../.././Init/Core.html#Sum">⊕</a> <span class="fn">β</span></span>)</span></span></div></div><p>O(m + n). Build a set on the disjoint union by combining sets on the factors.
<code><a href="../../.././Init/Prelude.html#Or.inl">Or.inl</a> a ∈ s.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.copair">copair</a> t</code> iff <code>a ∈ s</code>, and <code><a href="../../.././Init/Prelude.html#Or.inr">Or.inr</a> b ∈ s.<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.copair">copair</a> t</code> iff <code>b ∈ t</code>.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.copair">copair</a> {1, 2} {2, 3} = {inl 1, inl 2, inr 2, inr 3} 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.copair">Ordnode.copair</a> <span class="fn">t₁</span> <span class="fn">t₂</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.merge">Ordnode.merge</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.map">Ordnode.map</a> <span class="fn">Sum.inl</span> <span class="fn">t₁</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.map">Ordnode.map</a> <span class="fn">Sum.inr</span> <span class="fn">t₂</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.copair" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.pmap"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L717-L719">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.pmap"><span class="name">Ordnode</span>.<span class="name">pmap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">a</span></span> → <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(t : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All">Ordnode.All</a> <span class="fn">P</span> <span class="fn">t</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">β</span></span></span></div></div><p>O(n). Map a partial function across a set. The result depends on a proof
that the function is defined on all members of the set.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.pmap">pmap</a> (fin.mk : ∀ n, n &lt; 4 → fin 4) {1, 2} H = {(1 : fin 4), (2 : fin 4)} 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.pmap">Ordnode.pmap</a> <span class="fn">f</span> <span class="fn">Ordnode.nil</span> <span class="fn">x_2</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">Ordnode.nil</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.pmap">Ordnode.pmap</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">s</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span></span>)</span> <span class="fn">(_ : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All">Ordnode.All</a> <span class="fn">P</span> <span class="fn">l</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn">P</span> <span class="fn">x_2</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All">Ordnode.All</a> <span class="fn">P</span> <span class="fn">r</span></span></span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">s</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.pmap">Ordnode.pmap</a> <span class="fn">f</span> <span class="fn">l</span> <span class="fn">hl</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">x_2</span> <span class="fn">hx</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.pmap">Ordnode.pmap</a> <span class="fn">f</span> <span class="fn">r</span> <span class="fn">hr</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.pmap" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.attach'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L726-L727">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.attach'"><span class="name">Ordnode</span>.<span class="name">attach'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{P : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(t : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All">Ordnode.All</a> <span class="fn">P</span> <span class="fn">t</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">{ <span class="fn">a</span> : <span class="fn">α</span> // <span class="fn"><span class="fn">P</span> <span class="fn">a</span></span> }</span></span></span></div></div><p>O(n). "Attach" the information that every element of <code>t</code> satisfies property
P to these elements inside the set, producing a set in the subtype.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.attach'">attach'</a> (fun x ↦ x &lt; 4) {1, 2} H = ({1, 2} : <a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> {x // x&lt;4}) 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Ordnode.attach'</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.pmap">Ordnode.pmap</a> <span class="fn">Subtype.mk</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.attach'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.nth"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L734-L740">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nth"><span class="name">Ordnode</span>.<span class="name">nth</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Nat">ℕ</a> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></span></span></div></div><p>O(log n). Get the <code>i</code>th element of the set, by its index from left to right.</p><p>nth {a, b, c, d} 2 = some c
nth {a, b, c, d} 5 = none</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nth">Ordnode.nth</a> <span class="fn">Ordnode.nil</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">none</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nth">Ordnode.nth</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span></span>)</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href="../../.././Mathlib/Data/Nat/PSub.html#Nat.psub'">Nat.psub'</a> <span class="fn">x</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">Ordnode.size</a> <span class="fn">l</span></span>)</span></span> with
  | <span class="fn">none</span> =&gt; <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nth">Ordnode.nth</a> <span class="fn">l</span> <span class="fn">x</span></span>
  | <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">0</span></span> =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x_2</span></span>
  | <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<span class="fn"><a href="../../.././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">j</span></span>)</span></span> =&gt; <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nth">Ordnode.nth</a> <span class="fn">r</span> <span class="fn">j</span></span></span></span></li></ul></details><details id="instances-for-list-Ordnode.nth" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.removeNth"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L747-L753">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.removeNth"><span class="name">Ordnode</span>.<span class="name">removeNth</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Nat">ℕ</a> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></span></div></div><p>O(log n). Remove the <code>i</code>th element of the set, by its index from left to right.</p><p>remove_nth {a, b, c, d} 2 = {a, b, d}
remove_nth {a, b, c, d} 5 = {a, b, c, d}</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.removeNth">Ordnode.removeNth</a> <span class="fn">Ordnode.nil</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">Ordnode.nil</span></span></li></ul></details><details id="instances-for-list-Ordnode.removeNth" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.takeAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L761-L769">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeAux"><span class="name">Ordnode</span>.<span class="name">takeAux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Nat">ℕ</a> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.take">take</a></code>. (Can also be used in lieu of <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.take">take</a></code> if you know the
index is within the range of the data structure.)</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeAux">takeAux</a> {a, b, c, d} 2 = {a, b}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeAux">takeAux</a> {a, b, c, d} 5 = {a, b, c, d} 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeAux">Ordnode.takeAux</a> <span class="fn">Ordnode.nil</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">Ordnode.nil</span></span></li></ul></details><details id="instances-for-list-Ordnode.takeAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.take"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L776-L777">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.take"><span class="name">Ordnode</span>.<span class="name">take</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(i : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(t : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></div></div><p>O(log n). Get the first <code>i</code> elements of the set, counted from the left.</p><p>take 2 {a, b, c, d} = {a, b}
take 5 {a, b, c, d} = {a, b, c, d}</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.take">Ordnode.take</a> <span class="fn">i</span> <span class="fn">t</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">Ordnode.size</a> <span class="fn">t</span></span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">i</span></span> then <span class="fn">t</span> else <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeAux">Ordnode.takeAux</a> <span class="fn">t</span> <span class="fn">i</span></span></span></span></li></ul></details><details id="instances-for-list-Ordnode.take" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.dropAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L785-L793">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropAux"><span class="name">Ordnode</span>.<span class="name">dropAux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Nat">ℕ</a> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.drop">drop</a></code>. (Can also be used in lieu of <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.drop">drop</a></code> if you know the
index is within the range of the data structure.)</p><pre><code>drop_aux {a, b, c, d} 2 = {c, d}
drop_aux {a, b, c, d} 5 = ∅ 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropAux">Ordnode.dropAux</a> <span class="fn">Ordnode.nil</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">Ordnode.nil</span></span></li></ul></details><details id="instances-for-list-Ordnode.dropAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.drop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L800-L801">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.drop"><span class="name">Ordnode</span>.<span class="name">drop</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(i : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(t : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></div></div><p>O(log n). Remove the first <code>i</code> elements of the set, counted from the left.</p><p>drop 2 {a, b, c, d} = {c, d}
drop 5 {a, b, c, d} = ∅</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.drop">Ordnode.drop</a> <span class="fn">i</span> <span class="fn">t</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">Ordnode.size</a> <span class="fn">t</span></span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">i</span></span> then <span class="fn">Ordnode.nil</span> else <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropAux">Ordnode.dropAux</a> <span class="fn">t</span> <span class="fn">i</span></span></span></span></li></ul></details><details id="instances-for-list-Ordnode.drop" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.splitAtAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L809-L821">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAtAux"><span class="name">Ordnode</span>.<span class="name">splitAtAux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Nat">ℕ</a> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></span></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAt">splitAt</a></code>. (Can also be used in lieu of <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAt">splitAt</a></code> if you know the
index is within the range of the data structure.)</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAtAux">splitAtAux</a> {a, b, c, d} 2 = ({a, b}, {c, d})
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAtAux">splitAtAux</a> {a, b, c, d} 5 = ({a, b, c, d}, ∅) 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAtAux">Ordnode.splitAtAux</a> <span class="fn">Ordnode.nil</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">Ordnode.nil</span>, <span class="fn">Ordnode.nil</span>)</span></span></li></ul></details><details id="instances-for-list-Ordnode.splitAtAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.splitAt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L828-L829">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAt"><span class="name">Ordnode</span>.<span class="name">splitAt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(i : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>)</span></span>
<span class="decl_args">
<span class="fn">(t : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Split a set at the <code>i</code>th element, getting the first <code>i</code> and everything else.</p><p>splitAt 2 {a, b, c, d} = ({a, b}, {c, d})
splitAt 5 {a, b, c, d} = ({a, b, c, d}, ∅)</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAt">Ordnode.splitAt</a> <span class="fn">i</span> <span class="fn">t</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">Ordnode.size</a> <span class="fn">t</span></span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">i</span></span> then <span class="fn">(<span class="fn">t</span>, <span class="fn">Ordnode.nil</span>)</span> else <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAtAux">Ordnode.splitAtAux</a> <span class="fn">t</span> <span class="fn">i</span></span></span></span></li></ul></details><details id="instances-for-list-Ordnode.splitAt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.takeWhile"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L837-L839">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeWhile"><span class="name">Ordnode</span>.<span class="name">takeWhile</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidablePred">DecidablePred</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Get an initial segment of the set that satisfies the predicate <code>p</code>.
<code>p</code> is required to be antitone, that is, <code>x &lt; y → p y → p x</code>.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeWhile">takeWhile</a> (fun x ↦ x &lt; 4) {1, 2, 3, 4, 5} = {1, 2, 3}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeWhile">takeWhile</a> (fun x ↦ x &gt; 4) {1, 2, 3, 4, 5} = precondition violation 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeWhile">Ordnode.takeWhile</a> <span class="fn">p</span> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">Ordnode.nil</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeWhile">Ordnode.takeWhile</a> <span class="fn">p</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">r</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if <span class="fn"><span class="fn">p</span> <span class="fn">x_1</span></span> then <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.link">Ordnode.link</a> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeWhile">Ordnode.takeWhile</a> <span class="fn">p</span> <span class="fn">r</span></span>)</span></span> else <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeWhile">Ordnode.takeWhile</a> <span class="fn">p</span> <span class="fn">l</span></span></span></span></li></ul></details><details id="instances-for-list-Ordnode.takeWhile" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.dropWhile"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L847-L849">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropWhile"><span class="name">Ordnode</span>.<span class="name">dropWhile</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidablePred">DecidablePred</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Remove an initial segment of the set that satisfies the predicate <code>p</code>.
<code>p</code> is required to be antitone, that is, <code>x &lt; y → p y → p x</code>.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropWhile">dropWhile</a> (fun x ↦ x &lt; 4) {1, 2, 3, 4, 5} = {4, 5}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropWhile">dropWhile</a> (fun x ↦ x &gt; 4) {1, 2, 3, 4, 5} = precondition violation 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropWhile">Ordnode.dropWhile</a> <span class="fn">p</span> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">Ordnode.nil</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropWhile">Ordnode.dropWhile</a> <span class="fn">p</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_1</span> <span class="fn">r</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if <span class="fn"><span class="fn">p</span> <span class="fn">x_1</span></span> then <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropWhile">Ordnode.dropWhile</a> <span class="fn">p</span> <span class="fn">r</span></span> else <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.link">Ordnode.link</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropWhile">Ordnode.dropWhile</a> <span class="fn">p</span> <span class="fn">l</span></span>)</span> <span class="fn">x_1</span> <span class="fn">r</span></span></span></span></li></ul></details><details id="instances-for-list-Ordnode.dropWhile" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.span"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L857-L865">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.span"><span class="name">Ordnode</span>.<span class="name">span</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">α</span> → <a href="../../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidablePred">DecidablePred</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></span></div></div><p>O(log n). Split the set into those satisfying and not satisfying the predicate <code>p</code>.
<code>p</code> is required to be antitone, that is, <code>x &lt; y → p y → p x</code>.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.span">span</a> (fun x ↦ x &lt; 4) {1, 2, 3, 4, 5} = ({1, 2, 3}, {4, 5})
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.span">span</a> (fun x ↦ x &gt; 4) {1, 2, 3, 4, 5} = precondition violation 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.span">Ordnode.span</a> <span class="fn">p</span> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">Ordnode.nil</span>, <span class="fn">Ordnode.nil</span>)</span></span></li></ul></details><details id="instances-for-list-Ordnode.span" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.ofAscListAux₁"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L874-L885">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscListAux₁"><span class="name">Ordnode</span>.<span class="name">ofAscListAux₁</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(l : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Nat">ℕ</a> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">{ <span class="fn">l'</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span> // <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#List.length">List.length</a> <span class="fn">l'</span></span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../../.././Init/Prelude.html#List.length">List.length</a> <span class="fn">l</span></span></span> }</span></span></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscList">ofAscList</a></code>.</p><p><strong>Note:</strong> This function is defined by well founded recursion, so it will probably not compute
in the kernel, meaning that you probably can't prove things like
<code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscList">ofAscList</a> [1, 2, 3] = {1, 2, 3}</code> by <code><a href="../../.././Init/Prelude.html#rfl">rfl</a></code>.
This implementation is optimized for VM evaluation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscListAux₁">Ordnode.ofAscListAux₁</a> <span class="fn">[]</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fun (<span class="fn">x</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>) =&gt;
  <span class="fn">(<span class="fn">Ordnode.nil</span>, <span class="fn">{ <span class="fn">val</span> := <span class="fn">[]</span>, <span class="fn">property</span> := <span class="fn">(_ : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#List.length">List.length</a> <span class="fn">[]</span></span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../../.././Init/Prelude.html#List.length">List.length</a> <span class="fn">[]</span></span></span>)</span> }</span>)</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.ofAscListAux₁" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.ofAscListAux₂"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L889-L896">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscListAux₂"><span class="name">Ordnode</span>.<span class="name">ofAscListAux₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Nat">ℕ</a> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></span></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscList">ofAscList</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscListAux₂">Ordnode.ofAscListAux₂</a> <span class="fn">[]</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">fun (<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>) (<span class="fn">x</span> : <a href="../../.././Init/Prelude.html#Nat">ℕ</a>) =&gt; <span class="fn">t</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.ofAscListAux₂" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.ofAscList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L903-L905">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscList"><span class="name">Ordnode</span>.<span class="name">ofAscList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(n). Build a set from a list which is already sorted. Performs no comparisons.</p><p>ofAscList [1, 2, 3] = {1, 2, 3}
ofAscList [3, 2, 1] = precondition violation</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscList">Ordnode.ofAscList</a> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">x</span> with
  | <span class="fn">[]</span> =&gt; <span class="fn">Ordnode.nil</span>
  | <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">xs</span></span> =&gt; <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscListAux₂">Ordnode.ofAscListAux₂</a> <span class="fn">xs</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.singleton">Ordnode.singleton</a> <span class="fn">x</span></span>)</span> <span class="fn">1</span></span></span></span></li></ul></details><details id="instances-for-list-Ordnode.ofAscList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.mem"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L922-L928">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem"><span class="name">Ordnode</span>.<span class="name">mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>O(log n). Does the set (approximately) contain the element <code>x</code>? That is,
is there an element that is equivalent to <code>x</code> in the order?</p><pre><code>1 ∈ {1, 2, 3} = true
4 ∈ {1, 2, 3} = false
</code></pre><p>Using a preorder on <code>ℕ × ℕ</code> that only compares the first coordinate:</p><pre><code>(1, 1) ∈ {(0, 1), (1, 2)} = true
(3, 1) ∈ {(0, 1), (1, 2)} = false 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem">Ordnode.mem</a> <span class="fn">x</span> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.false">false</a></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem">Ordnode.mem</a> <span class="fn">x</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href="../../.././Mathlib/Order/Compare.html#cmpLE">cmpLE</a> <span class="fn">x</span> <span class="fn">x_2</span></span> with
  | <a href="../../.././Init/Data/Ord.html#Ordering.gt">Ordering.lt</a> =&gt; <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem">Ordnode.mem</a> <span class="fn">x</span> <span class="fn">l</span></span>
  | <a href="../../.././Init/Data/Ord.html#Ordering.gt">Ordering.eq</a> =&gt; <a href="../../.././Init/Prelude.html#Bool.true">true</a>
  | <a href="../../.././Init/Data/Ord.html#Ordering.gt">Ordering.gt</a> =&gt; <a href="../../.././Init/Data/Ord.html#Ordering.gt"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem">Ordnode.mem</a> <span class="fn">x</span> <span class="fn">r</span></a></span></span></li></ul></details><details id="instances-for-list-Ordnode.mem" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.find"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L941-L947">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.find"><span class="name">Ordnode</span>.<span class="name">find</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Retrieve an element in the set that is equivalent to <code>x</code> in the order,
if it exists.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.find">find</a> 1 {1, 2, 3} = some 1
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.find">find</a> 4 {1, 2, 3} = none
</code></pre><p>Using a preorder on <code>ℕ × ℕ</code> that only compares the first coordinate:</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.find">find</a> (1, 1) {(0, 1), (1, 2)} = some (1, 2)
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.find">find</a> (3, 1) {(0, 1), (1, 2)} = none 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.find">Ordnode.find</a> <span class="fn">x</span> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">none</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.find">Ordnode.find</a> <span class="fn">x</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href="../../.././Mathlib/Order/Compare.html#cmpLE">cmpLE</a> <span class="fn">x</span> <span class="fn">x_2</span></span> with
  | <a href="../../.././Init/Data/Ord.html#Ordering.gt">Ordering.lt</a> =&gt; <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.find">Ordnode.find</a> <span class="fn">x</span> <span class="fn">l</span></span>
  | <a href="../../.././Init/Data/Ord.html#Ordering.gt">Ordering.eq</a> =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x_2</span></span>
  | <a href="../../.././Init/Data/Ord.html#Ordering.gt">Ordering.gt</a> =&gt; <a href="../../.././Init/Data/Ord.html#Ordering.gt"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.find">Ordnode.find</a> <span class="fn">x</span> <span class="fn">r</span></a></span></span></li></ul></details><details id="instances-for-list-Ordnode.find" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.instMembershipOrdnode"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L950-L951">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instMembershipOrdnode"><span class="name">Ordnode</span>.<span class="name">instMembershipOrdnode</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">α</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Ordnode.instMembershipOrdnode</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">mem</span> := <span class="fn">fun (<span class="fn">x</span> : <span class="fn">α</span>) (<span class="fn">t</span> : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>) =&gt; <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem">Ordnode.mem</a> <span class="fn">x</span> <span class="fn">t</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Ordnode.mem.decidable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L953-L954">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem.decidable"><span class="name">Ordnode</span>.<span class="name">mem</span>.<span class="name">decidable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(t : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">t</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem.decidable">Ordnode.mem.decidable</a> <span class="fn">x</span> <span class="fn">t</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#Bool.decEq">Bool.decEq</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem">Ordnode.mem</a> <span class="fn">x</span> <span class="fn">t</span></span>)</span> <a href="../../.././Init/Prelude.html#Bool.true">true</a></span></span></li></ul></details></div></div><div class="decl" id="Ordnode.insertWith"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L968-L974">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertWith"><span class="name">Ordnode</span>.<span class="name">insertWith</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Insert an element into the set, preserving balance and the BST property.
If an equivalent element is already in the set, the function <code>f</code> is used to generate
the element to insert (being passed the current value in the set).</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertWith">insertWith</a> f 0 {1, 2, 3} = {0, 1, 2, 3}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertWith">insertWith</a> f 1 {1, 2, 3} = {f 1, 2, 3}
</code></pre><p>Using a preorder on <code>ℕ × ℕ</code> that only compares the first coordinate:</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertWith">insertWith</a> f (1, 1) {(0, 1), (1, 2)} = {(0, 1), f (1, 2)}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertWith">insertWith</a> f (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2), (3, 1)} 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertWith">Ordnode.insertWith</a> <span class="fn">f</span> <span class="fn">x</span> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.singleton">Ordnode.singleton</a> <span class="fn">x</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.insertWith" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.adjustWith"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L988-L994">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.adjustWith"><span class="name">Ordnode</span>.<span class="name">adjustWith</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Modify an element in the set with the given function,
doing nothing if the key is not found.
Note that the element returned by <code>f</code> must be equivalent to <code>x</code>.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.adjustWith">adjustWith</a> f 0 {1, 2, 3} = {1, 2, 3}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.adjustWith">adjustWith</a> f 1 {1, 2, 3} = {f 1, 2, 3}
</code></pre><p>Using a preorder on <code>ℕ × ℕ</code> that only compares the first coordinate:</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.adjustWith">adjustWith</a> f (1, 1) {(0, 1), (1, 2)} = {(0, 1), f (1, 2)}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.adjustWith">adjustWith</a> f (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2)} 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.adjustWith">Ordnode.adjustWith</a> <span class="fn">f</span> <span class="fn">x</span> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">Ordnode.nil</span></span></li></ul></details><details id="instances-for-list-Ordnode.adjustWith" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.updateWith"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L1004-L1013">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.updateWith"><span class="name">Ordnode</span>.<span class="name">updateWith</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Modify an element in the set with the given function,
doing nothing if the key is not found.
Note that the element returned by <code>f</code> must be equivalent to <code>x</code>.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.updateWith">updateWith</a> f 0 {1, 2, 3} = {1, 2, 3}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.updateWith">updateWith</a> f 1 {1, 2, 3} = {2, 3}     if f 1 = none
                          = {a, 2, 3}  if f 1 = some a 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.updateWith">Ordnode.updateWith</a> <span class="fn">f</span> <span class="fn">x</span> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">Ordnode.nil</span></span></li></ul></details><details id="instances-for-list-Ordnode.updateWith" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.alter"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L1024-L1033">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.alter"><span class="name">Ordnode</span>.<span class="name">alter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Modify an element in the set with the given function,
doing nothing if the key is not found.
Note that the element returned by <code>f</code> must be equivalent to <code>x</code>.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.alter">alter</a> f 0 {1, 2, 3} = {1, 2, 3}     if f none = none
                    = {a, 1, 2, 3}  if f none = some a
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.alter">alter</a> f 1 {1, 2, 3} = {2, 3}     if f 1 = none
                    = {a, 2, 3}  if f 1 = some a 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.alter">Ordnode.alter</a> <span class="fn">f</span> <span class="fn">x</span> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#Option.recOn">Option.recOn</a> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">none</span></span>)</span> <span class="fn">Ordnode.nil</span> <span class="fn">Ordnode.singleton</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.alter" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.insert"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L1046-L1052">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert"><span class="name">Ordnode</span>.<span class="name">insert</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Insert an element into the set, preserving balance and the BST property.
If an equivalent element is already in the set, this replaces it.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert">insert</a> 1 {1, 2, 3} = {1, 2, 3}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert">insert</a> 4 {1, 2, 3} = {1, 2, 3, 4}
</code></pre><p>Using a preorder on <code>ℕ × ℕ</code> that only compares the first coordinate:</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert">insert</a> (1, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 1)}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert">insert</a> (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2), (3, 1)} 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert">Ordnode.insert</a> <span class="fn">x</span> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.singleton">Ordnode.singleton</a> <span class="fn">x</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.insert" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.instInsertOrdnode"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L1055-L1056">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instInsertOrdnode"><span class="name">Ordnode</span>.<span class="name">instInsertOrdnode</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Std/Classes/SetNotation.html#Insert">Insert</a> <span class="fn">α</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Ordnode.instInsertOrdnode</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">insert</span> := <span class="fn">Ordnode.insert</span> }</span></span></li></ul></details></div></div><div class="decl" id="Ordnode.insert'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L1068-L1074">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert'"><span class="name">Ordnode</span>.<span class="name">insert'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Insert an element into the set, preserving balance and the BST property.
If an equivalent element is already in the set, the set is returned as is.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert'">insert'</a> 1 {1, 2, 3} = {1, 2, 3}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert'">insert'</a> 4 {1, 2, 3} = {1, 2, 3, 4}
</code></pre><p>Using a preorder on <code>ℕ × ℕ</code> that only compares the first coordinate:</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert'">insert'</a> (1, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2)}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert'">insert'</a> (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2), (3, 1)} 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert'">Ordnode.insert'</a> <span class="fn">x</span> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.singleton">Ordnode.singleton</a> <span class="fn">x</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.insert'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.split"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L1088-L1098">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split"><span class="name">Ordnode</span>.<span class="name">split</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></span></div></div><p>O(log n). Split the tree into those smaller than <code>x</code> and those greater than it.
If an element equivalent to <code>x</code> is in the set, it is discarded.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split">split</a> 2 {1, 2, 4} = ({1}, {4})
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split">split</a> 3 {1, 2, 4} = ({1, 2}, {4})
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split">split</a> 4 {1, 2, 4} = ({1, 2}, ∅)
</code></pre><p>Using a preorder on <code>ℕ × ℕ</code> that only compares the first coordinate:</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split">split</a> (1, 1) {(0, 1), (1, 2)} = ({(0, 1)}, ∅)
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split">split</a> (3, 1) {(0, 1), (1, 2)} = ({(0, 1), (1, 2)}, ∅) 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split">Ordnode.split</a> <span class="fn">x</span> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">Ordnode.nil</span>, <span class="fn">Ordnode.nil</span>)</span></span></li></ul></details><details id="instances-for-list-Ordnode.split" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.split3"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L1112-L1122">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split3"><span class="name">Ordnode</span>.<span class="name">split3</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></span></span></div></div><p>O(log n). Split the tree into those smaller than <code>x</code> and those greater than it,
plus an element equivalent to <code>x</code>, if it exists.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split3">split3</a> 2 {1, 2, 4} = ({1}, some 2, {4})
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split3">split3</a> 3 {1, 2, 4} = ({1, 2}, none, {4})
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split3">split3</a> 4 {1, 2, 4} = ({1, 2}, some 4, ∅)
</code></pre><p>Using a preorder on <code>ℕ × ℕ</code> that only compares the first coordinate:</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split3">split3</a> (1, 1) {(0, 1), (1, 2)} = ({(0, 1)}, some (1, 2), ∅)
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split3">split3</a> (3, 1) {(0, 1), (1, 2)} = ({(0, 1), (1, 2)}, none, ∅) 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split3">Ordnode.split3</a> <span class="fn">x</span> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">Ordnode.nil</span>, <span class="fn">none</span>, <span class="fn">Ordnode.nil</span>)</span></span></li></ul></details><details id="instances-for-list-Ordnode.split3" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.erase"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L1135-L1141">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.erase"><span class="name">Ordnode</span>.<span class="name">erase</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Remove an element from the set equivalent to <code>x</code>. Does nothing if there
is no such element.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.erase">erase</a> 1 {1, 2, 3} = {2, 3}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.erase">erase</a> 4 {1, 2, 3} = {1, 2, 3}
</code></pre><p>Using a preorder on <code>ℕ × ℕ</code> that only compares the first coordinate:</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.erase">erase</a> (1, 1) {(0, 1), (1, 2)} = {(0, 1)}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.erase">erase</a> (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2)} 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.erase">Ordnode.erase</a> <span class="fn">x</span> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">Ordnode.nil</span></span></li></ul></details><details id="instances-for-list-Ordnode.erase" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findLtAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L1145-L1147">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLtAux"><span class="name">Ordnode</span>.<span class="name">findLtAux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><span class="fn">α</span> → <span class="fn">α</span></span></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLt">findLt</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLtAux">Ordnode.findLtAux</a> <span class="fn">x✝</span> <span class="fn">Ordnode.nil</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLtAux">Ordnode.findLtAux</a> <span class="fn">x✝</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x_3</span> <span class="fn">r</span></span>)</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if <span class="fn"><span class="fn">x✝</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_3</span></span> then <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLtAux">Ordnode.findLtAux</a> <span class="fn">x✝</span> <span class="fn">l</span> <span class="fn">x</span></span> else <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLtAux">Ordnode.findLtAux</a> <span class="fn">x✝</span> <span class="fn">r</span> <span class="fn">x_3</span></span></span></span></li></ul></details><details id="instances-for-list-Ordnode.findLtAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findLt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L1155-L1157">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLt"><span class="name">Ordnode</span>.<span class="name">findLt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Get the largest element in the tree that is <code>&lt; x</code>.</p><p>findLt 2 {1, 2, 4} = some 1
findLt 3 {1, 2, 4} = some 2
findLt 0 {1, 2, 4} = none</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLt">Ordnode.findLt</a> <span class="fn">x</span> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">none</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLt">Ordnode.findLt</a> <span class="fn">x</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_2</span></span> then <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLt">Ordnode.findLt</a> <span class="fn">x</span> <span class="fn">l</span></span> else <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLtAux">Ordnode.findLtAux</a> <span class="fn">x</span> <span class="fn">r</span> <span class="fn">x_2</span></span>)</span></span></span></span></li></ul></details><details id="instances-for-list-Ordnode.findLt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findGtAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L1161-L1163">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGtAux"><span class="name">Ordnode</span>.<span class="name">findGtAux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><span class="fn">α</span> → <span class="fn">α</span></span></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGt">findGt</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGtAux">Ordnode.findGtAux</a> <span class="fn">x✝</span> <span class="fn">Ordnode.nil</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGtAux">Ordnode.findGtAux</a> <span class="fn">x✝</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x_3</span> <span class="fn">r</span></span>)</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">if <span class="fn"><span class="fn">x_3</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x✝</span></span> then <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGtAux">Ordnode.findGtAux</a> <span class="fn">x✝</span> <span class="fn">r</span> <span class="fn">x</span></span> else <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGtAux">Ordnode.findGtAux</a> <span class="fn">x✝</span> <span class="fn">l</span> <span class="fn">x_3</span></span></span></span></li></ul></details><details id="instances-for-list-Ordnode.findGtAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findGt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L1171-L1173">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGt"><span class="name">Ordnode</span>.<span class="name">findGt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Get the smallest element in the tree that is <code>&gt; x</code>.</p><p>findGt 2 {1, 2, 4} = some 4
findGt 3 {1, 2, 4} = some 4
findGt 4 {1, 2, 4} = none</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGt">Ordnode.findGt</a> <span class="fn">x</span> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">none</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGt">Ordnode.findGt</a> <span class="fn">x</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">if <span class="fn"><span class="fn">x_2</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x</span></span> then <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGt">Ordnode.findGt</a> <span class="fn">x</span> <span class="fn">r</span></span> else <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGtAux">Ordnode.findGtAux</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">x_2</span></span>)</span></span></span></span></li></ul></details><details id="instances-for-list-Ordnode.findGt" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findLeAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L1177-L1183">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLeAux"><span class="name">Ordnode</span>.<span class="name">findLeAux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><span class="fn">α</span> → <span class="fn">α</span></span></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLe">findLe</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLeAux">Ordnode.findLeAux</a> <span class="fn">x✝</span> <span class="fn">Ordnode.nil</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></span></li></ul></details><details id="instances-for-list-Ordnode.findLeAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findLe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L1191-L1197">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLe"><span class="name">Ordnode</span>.<span class="name">findLe</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Get the largest element in the tree that is <code>≤ x</code>.</p><p>findLe 2 {1, 2, 4} = some 2
findLe 3 {1, 2, 4} = some 2
findLe 0 {1, 2, 4} = none</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLe">Ordnode.findLe</a> <span class="fn">x</span> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">none</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLe">Ordnode.findLe</a> <span class="fn">x</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href="../../.././Mathlib/Order/Compare.html#cmpLE">cmpLE</a> <span class="fn">x</span> <span class="fn">x_2</span></span> with
  | <a href="../../.././Init/Data/Ord.html#Ordering.gt">Ordering.lt</a> =&gt; <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLe">Ordnode.findLe</a> <span class="fn">x</span> <span class="fn">l</span></span>
  | <a href="../../.././Init/Data/Ord.html#Ordering.gt">Ordering.eq</a> =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x_2</span></span>
  | <a href="../../.././Init/Data/Ord.html#Ordering.gt">Ordering.gt</a> =&gt; <a href="../../.././Init/Data/Ord.html#Ordering.gt"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLeAux">Ordnode.findLeAux</a> <span class="fn">x</span> <span class="fn">r</span> <span class="fn">x_2</span></span>)</span></a></span></span></li></ul></details><details id="instances-for-list-Ordnode.findLe" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findGeAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L1201-L1207">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGeAux"><span class="name">Ordnode</span>.<span class="name">findGeAux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><span class="fn">α</span> → <span class="fn">α</span></span></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGe">findGe</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGeAux">Ordnode.findGeAux</a> <span class="fn">x✝</span> <span class="fn">Ordnode.nil</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></span></li></ul></details><details id="instances-for-list-Ordnode.findGeAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findGe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L1216-L1222">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGe"><span class="name">Ordnode</span>.<span class="name">findGe</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></span></div></div><p>O(log n). Get the smallest element in the tree that is <code>≥ x</code>.</p><p>findGe 2 {1, 2, 4} = some 2
findGe 3 {1, 2, 4} = some 4
findGe 5 {1, 2, 4} = none</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGe">Ordnode.findGe</a> <span class="fn">x</span> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">none</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGe">Ordnode.findGe</a> <span class="fn">x</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">sz</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href="../../.././Mathlib/Order/Compare.html#cmpLE">cmpLE</a> <span class="fn">x</span> <span class="fn">x_2</span></span> with
  | <a href="../../.././Init/Data/Ord.html#Ordering.gt">Ordering.lt</a> =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGeAux">Ordnode.findGeAux</a> <span class="fn">x</span> <span class="fn">l</span> <span class="fn">x_2</span></span>)</span></span>
  | <a href="../../.././Init/Data/Ord.html#Ordering.gt">Ordering.eq</a> =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Option.some">some</a> <span class="fn">x_2</span></span>
  | <a href="../../.././Init/Data/Ord.html#Ordering.gt">Ordering.gt</a> =&gt; <a href="../../.././Init/Data/Ord.html#Ordering.gt"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGe">Ordnode.findGe</a> <span class="fn">x</span> <span class="fn">r</span></a></span></span></li></ul></details><details id="instances-for-list-Ordnode.findGe" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findIndexAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L1226-L1232">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndexAux"><span class="name">Ordnode</span>.<span class="name">findIndexAux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Nat">ℕ</a> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <a href="../../.././Init/Prelude.html#Nat">ℕ</a></span></span></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndex">findIndex</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndexAux">Ordnode.findIndexAux</a> <span class="fn">x✝</span> <span class="fn">Ordnode.nil</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">none</span></span></li></ul></details><details id="instances-for-list-Ordnode.findIndexAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.findIndex"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L1241-L1242">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndex"><span class="name">Ordnode</span>.<span class="name">findIndex</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(t : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <a href="../../.././Init/Prelude.html#Nat">ℕ</a></span></div></div><p>O(log n). Get the index, counting from the left,
of an element equivalent to <code>x</code> if it exists.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndex">findIndex</a> 2 {1, 2, 4} = some 1
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndex">findIndex</a> 4 {1, 2, 4} = some 2
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndex">findIndex</a> 5 {1, 2, 4} = none 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndex">Ordnode.findIndex</a> <span class="fn">x</span> <span class="fn">t</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndexAux">Ordnode.findIndexAux</a> <span class="fn">x</span> <span class="fn">t</span> <span class="fn">0</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.findIndex" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.isSubsetAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L1246-L1251">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubsetAux"><span class="name">Ordnode</span>.<span class="name">isSubsetAux</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Auxiliary definition for <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubset">isSubset</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubsetAux">Ordnode.isSubsetAux</a> <span class="fn">Ordnode.nil</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubsetAux">Ordnode.isSubsetAux</a> <span class="fn">x</span> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.false">false</a></span></li></ul></details><details id="instances-for-list-Ordnode.isSubsetAux" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.isSubset"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L1258-L1259">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubset"><span class="name">Ordnode</span>.<span class="name">isSubset</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(t₁ : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(t₂ : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Bool">Bool</a></div></div><p>O(m + n). Is every element of <code>t₁</code> equivalent to some element of <code>t₂</code>?</p><p>is_subset {1, 4} {1, 2, 4} = tt
is_subset {1, 3} {1, 2, 4} = ff</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubset">Ordnode.isSubset</a> <span class="fn">t₁</span> <span class="fn">t₂</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">Ordnode.size</a> <span class="fn">t₁</span></span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size">Ordnode.size</a> <span class="fn">t₂</span></span></span>)</span></span> <a href="../../.././Init/Prelude.html#and">&amp;&amp;</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubsetAux">Ordnode.isSubsetAux</a> <span class="fn">t₁</span> <span class="fn">t₂</span></span></span>)</span></span></li></ul></details><details id="instances-for-list-Ordnode.isSubset" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.disjoint"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L1266-L1271">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.disjoint"><span class="name">Ordnode</span>.<span class="name">disjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <a href="../../.././Init/Prelude.html#Bool">Bool</a></span></div></div><p>O(m + n). Is every element of <code>t₁</code> not equivalent to any element of <code>t₂</code>?</p><p>disjoint {1, 3} {2, 4} = tt
disjoint {1, 2} {2, 4} = ff</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.disjoint">Ordnode.disjoint</a> <span class="fn">Ordnode.nil</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.disjoint">Ordnode.disjoint</a> <span class="fn">x</span> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Bool.true">true</a></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.disjoint">Ordnode.disjoint</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node">Ordnode.node</a> <span class="fn">size</span> <span class="fn">l</span> <span class="fn">x_2</span> <span class="fn">r</span></span>)</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split3">Ordnode.split3</a> <span class="fn">x_2</span> <span class="fn">x</span></span> with
  | <span class="fn">(<span class="fn">lt</span>, <span class="fn">found</span>, <span class="fn">gt</span>)</span> =&gt; <span class="fn"><span class="fn"><span class="fn"><a href="../../.././Init/Data/Option/Basic.html#Option.isNone">Option.isNone</a> <span class="fn">found</span></span> <a href="../../.././Init/Prelude.html#and">&amp;&amp;</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.disjoint">Ordnode.disjoint</a> <span class="fn">l</span> <span class="fn">lt</span></span></span> <a href="../../.././Init/Prelude.html#and">&amp;&amp;</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.disjoint">Ordnode.disjoint</a> <span class="fn">r</span> <span class="fn">gt</span></span></span></span></span></li></ul></details><details id="instances-for-list-Ordnode.disjoint" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.union"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L1283-L1292">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.union"><span class="name">Ordnode</span>.<span class="name">union</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(m * log(|m ∪ n| + 1)), m ≤ n. The union of two sets, preferring members of
<code>t₁</code> over those of <code>t₂</code> when equivalent elements are encountered.</p><p>union {1, 2} {2, 3} = {1, 2, 3}
union {1, 3} {2} = {1, 2, 3}</p><p>Using a preorder on <code>ℕ × ℕ</code> that only compares the first coordinate:</p><p>union {(1, 1)} {(0, 1), (1, 2)} = {(0, 1), (1, 1)}</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.union">Ordnode.union</a> <span class="fn">x</span> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.union">Ordnode.union</a> <span class="fn">Ordnode.nil</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></span></li></ul></details><details id="instances-for-list-Ordnode.union" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.diff"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L1299-L1306">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.diff"><span class="name">Ordnode</span>.<span class="name">diff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(m * log(|m ∪ n| + 1)), m ≤ n. Difference of two sets.</p><p>diff {1, 2} {2, 3} = {1}
diff {1, 2, 3} {2} = {1, 3}</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.diff">Ordnode.diff</a> <span class="fn">x</span> <span class="fn">Ordnode.nil</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">x</span></span></li></ul></details><details id="instances-for-list-Ordnode.diff" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.inter"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L1314-L1321">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.inter"><span class="name">Ordnode</span>.<span class="name">inter</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(m * log(|m ∪ n| + 1)), m ≤ n. Intersection of two sets, preferring members of
<code>t₁</code> over those of <code>t₂</code> when equivalent elements are encountered.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.inter">inter</a> {1, 2} {2, 3} = {2}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.inter">inter</a> {1, 3} {2} = ∅ 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.inter">Ordnode.inter</a> <span class="fn">Ordnode.nil</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">Ordnode.nil</span></span></li></ul></details><details id="instances-for-list-Ordnode.inter" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.ofList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L1333-L1334">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList"><span class="name">Ordnode</span>.<span class="name">ofList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(l : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></div></div><p>O(n * log n). Build a set from a list, preferring elements that appear earlier in the list
in the case of equivalent elements.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList">ofList</a> [1, 2, 3] = {1, 2, 3}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList">ofList</a> [2, 1, 1, 3] = {1, 2, 3}
</code></pre><p>Using a preorder on <code>ℕ × ℕ</code> that only compares the first coordinate:</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList">ofList</a> [(1, 1), (0, 1), (1, 2)] = {(0, 1), (1, 1)} 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList">Ordnode.ofList</a> <span class="fn">l</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.foldr">List.foldr</a> <span class="fn">insert</span> <span class="fn">Ordnode.nil</span> <span class="fn">l</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.ofList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.ofList'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L1342-L1344">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList'"><span class="name">Ordnode</span>.<span class="name">ofList'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <span class="fn">α</span></span> → <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span></span></div></div><p>O(n * log n). Adaptively chooses between the linear and log-linear algorithm depending
on whether the input list is already sorted.</p><p>ofList' [1, 2, 3] = {1, 2, 3}
ofList' [2, 1, 1, 3] = {1, 2, 3}</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList'">Ordnode.ofList'</a> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">x</span> with
  | <span class="fn">[]</span> =&gt; <span class="fn">Ordnode.nil</span>
  | <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">xs</span></span> =&gt;
    <span class="fn">if <span class="fn"><a href="../../.././Std/Data/List/Basic.html#List.Chain">List.Chain</a> <span class="fn">(<span class="fn">fun (<span class="fn">a</span> b : <span class="fn">α</span>) =&gt; <span class="fn"><a href="../../.././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">b</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></span></span></span>)</span> <span class="fn">x</span> <span class="fn">xs</span></span> then <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscList">Ordnode.ofAscList</a> <span class="fn">(<span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">xs</span></span>)</span></span> else <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList">Ordnode.ofList</a> <span class="fn">(<span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#List.cons">::</a> <span class="fn">xs</span></span>)</span></span></span></span></span></li></ul></details><details id="instances-for-list-Ordnode.ofList'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Ordnode.image"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/Ordmap/Ordnode.lean#L1353-L1354">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.image"><span class="name">Ordnode</span>.<span class="name">image</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#LE">LE</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">β</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(t : <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode">Ordnode</a> <span class="fn">β</span></span></div></div><p>O(n * log n). Map a function on a set. Unlike <code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.map">map</a></code> this has no requirements on
<code>f</code>, and the resulting set may be smaller than the input if <code>f</code> is noninjective.
Equivalent elements are selected with a preference for smaller source elements.</p><pre><code><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.image">image</a> (fun x ↦ x + 2) {1, 2, 4} = {3, 4, 6}
<a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.image">image</a> (λ x : ℕ, x - 2) {1, 2, 4} = {0, 2} 
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.image">Ordnode.image</a> <span class="fn">f</span> <span class="fn">t</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList">Ordnode.ofList</a> <span class="fn">(<span class="fn"><a href="../../.././Init/Data/List/Basic.html#List.map">List.map</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toList">Ordnode.toList</a> <span class="fn">t</span></span>)</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-Ordnode.image" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>