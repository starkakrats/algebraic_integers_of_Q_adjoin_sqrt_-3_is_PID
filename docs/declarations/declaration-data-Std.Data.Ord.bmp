{"name":"Std.Data.Ord","instances":[{"typeNames":["Eq"],"name":"Ordering.instDecidableEqOrdering","className":"Decidable"}],"imports":["Init"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Data/Ord.lean#L133-L134","name":"Ord.lex'","line":133,"kind":"def","docLink":"./Std/Data/Ord.html#Ord.lex'","doc":"Create an order which compares elements first by `ord₁` and then, if this\nreturns 'equal', by `ord₂`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Ord.html#Ord.lex'\"><span class=\"name\">Ord</span>.<span class=\"name\">lex'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ord₁ : <span class=\"fn\"><a href=\"./Init/Data/Ord.html#Ord\">Ord</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ord₂ : <span class=\"fn\"><a href=\"./Init/Data/Ord.html#Ord\">Ord</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Ord.html#Ord\">Ord</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Data/Ord.lean#L126-L127","name":"Ord.lex","line":126,"kind":"def","docLink":"./Std/Data/Ord.html#Ord.lex","doc":"Derive the lexicographic order on products `α × β` from orders for `α` and `β`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Ord.html#Ord.lex\"><span class=\"name\">Ord</span>.<span class=\"name\">lex</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Data/Ord.html#Ord\">Ord</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Data/Ord.html#Ord\">Ord</a> <span class=\"fn\">β</span></span> → <span class=\"fn\"><a href=\"./Init/Data/Ord.html#Ord\">Ord</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">β</span></span>)</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Data/Ord.lean#L120-L121","name":"Ord.on","line":120,"kind":"def","docLink":"./Std/Data/Ord.html#Ord.on","doc":"`ord.on f` compares `x` and `y` by comparing `f x` and `f y` according to `ord`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Ord.html#Ord.on\"><span class=\"name\">Ord</span>.<span class=\"name\">on</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ord : <span class=\"fn\"><a href=\"./Init/Data/Ord.html#Ord\">Ord</a> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Ord.html#Ord\">Ord</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Data/Ord.lean#L114-L115","name":"Ord.opposite","line":114,"kind":"def","docLink":"./Std/Data/Ord.html#Ord.opposite","doc":"Invert the order of an `Ord` instance.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Ord.html#Ord.opposite\"><span class=\"name\">Ord</span>.<span class=\"name\">opposite</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ord : <span class=\"fn\"><a href=\"./Init/Data/Ord.html#Ord\">Ord</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Ord.html#Ord\">Ord</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Data/Ord.lean#L108-L109","name":"Ord.toLE","line":108,"kind":"def","docLink":"./Std/Data/Ord.html#Ord.toLE","doc":"Derive an `LE` instance from an `Ord` instance.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Ord.html#Ord.toLE\"><span class=\"name\">Ord</span>.<span class=\"name\">toLE</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Data/Ord.html#Ord\">Ord</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Data/Ord.lean#L102-L103","name":"Ord.toLT","line":102,"kind":"def","docLink":"./Std/Data/Ord.html#Ord.toLT","doc":"Derive an `LT` instance from an `Ord` instance.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Ord.html#Ord.toLT\"><span class=\"name\">Ord</span>.<span class=\"name\">toLT</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Data/Ord.html#Ord\">Ord</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#LT\">LT</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Data/Ord.lean#L96-L97","name":"Ord.toBEq","line":96,"kind":"def","docLink":"./Std/Data/Ord.html#Ord.toBEq","doc":"Derive a `BEq` instance from an `Ord` instance.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Ord.html#Ord.toBEq\"><span class=\"name\">Ord</span>.<span class=\"name\">toBEq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ord : <span class=\"fn\"><a href=\"./Init/Data/Ord.html#Ord\">Ord</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Data/Ord.lean#L87-L88","name":"compareOn","line":87,"kind":"def","docLink":"./Std/Data/Ord.html#compareOn","doc":"Compare `x` and `y` by comparing `f x` and `f y`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Ord.html#compareOn\"><span class=\"name\">compareOn</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[ord : <span class=\"fn\"><a href=\"./Init/Data/Ord.html#Ord\">Ord</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(y : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/Ord.html#Ordering\">Ordering</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Data/Ord.lean#L81-L82","name":"compareLex","line":81,"kind":"def","docLink":"./Std/Data/Ord.html#compareLex","doc":"Compare `a` and `b` lexicographically by `cmp₁` and `cmp₂`. `a` and `b` are\nfirst compared by `cmp₁`. If this returns 'equal', `a` and `b` are compared\nby `cmp₂` to break the tie.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Ord.html#compareLex\"><span class=\"name\">compareLex</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(cmp₁ : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\">β</span> → <a href=\"./Init/Data/Ord.html#Ordering\">Ordering</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(cmp₂ : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\">β</span> → <a href=\"./Init/Data/Ord.html#Ordering\">Ordering</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <span class=\"fn\">β</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/Ord.html#Ordering\">Ordering</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Data/Ord.lean#L70-L72","name":"Ordering.isGE","line":70,"kind":"def","docLink":"./Std/Data/Ord.html#Ordering.isGE","doc":"Check whether the ordering is 'greater than or equal'.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Ord.html#Ordering.isGE\"><span class=\"name\">Ordering</span>.<span class=\"name\">isGE</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Ord.html#Ordering\">Ordering</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Data/Ord.lean#L63-L65","name":"Ordering.isGT","line":63,"kind":"def","docLink":"./Std/Data/Ord.html#Ordering.isGT","doc":"Check whether the ordering is 'greater than'.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Ord.html#Ordering.isGT\"><span class=\"name\">Ordering</span>.<span class=\"name\">isGT</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Ord.html#Ordering\">Ordering</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Data/Ord.lean#L56-L58","name":"Ordering.isLT","line":56,"kind":"def","docLink":"./Std/Data/Ord.html#Ordering.isLT","doc":"Check whether the ordering is 'less than'.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Ord.html#Ordering.isLT\"><span class=\"name\">Ordering</span>.<span class=\"name\">isLT</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Ord.html#Ordering\">Ordering</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Data/Ord.lean#L49-L51","name":"Ordering.isNe","line":49,"kind":"def","docLink":"./Std/Data/Ord.html#Ordering.isNe","doc":"Check whether the ordering is 'not equal'.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Ord.html#Ordering.isNe\"><span class=\"name\">Ordering</span>.<span class=\"name\">isNe</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Ord.html#Ordering\">Ordering</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Data/Ord.lean#L42-L44","name":"Ordering.isEq","line":42,"kind":"def","docLink":"./Std/Data/Ord.html#Ordering.isEq","doc":"Check whether the ordering is 'equal'.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Ord.html#Ordering.isEq\"><span class=\"name\">Ordering</span>.<span class=\"name\">isEq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Ord.html#Ordering\">Ordering</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Data/Ord.lean#L35-L37","name":"Ordering.then","line":35,"kind":"def","docLink":"./Std/Data/Ord.html#Ordering.then","doc":"If `o₁` and `o₂` are `Ordering`, then `o₁.then o₂` returns `o₁` unless it is `.eq`,\nin which case it returns `o₂`. Additionally, it has \"short-circuiting\" semantics similar to\nboolean `x && y`: if `o₁` is not `.eq` then the expression for `o₂` is not evaluated.\nThis is a useful primitive for constructing lexicographic comparator functions:\n```\nstructure Person where\n  name : String\n  age : Nat\n\ninstance : Ord Person where\n  compare a b := (compare a.name b.name).then (compare b.age a.age)\n```\nThis example will sort people first by name (in ascending order) and will sort people with\nthe same name by age (in descending order). (If all fields are sorted ascending and in the same\norder as they are listed in the structure, you can also use `deriving Ord` on the structure\ndefinition for the same effect.)\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Ord.html#Ordering.then\"><span class=\"name\">Ordering</span>.<span class=\"name\">then</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Ord.html#Ordering\">Ordering</a> → <a href=\"./Init/Data/Ord.html#Ordering\">Ordering</a> → <a href=\"./Init/Data/Ord.html#Ordering\">Ordering</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Data/Ord.lean#L12-L15","name":"Ordering.swap","line":12,"kind":"def","docLink":"./Std/Data/Ord.html#Ordering.swap","doc":"Swaps less and greater ordering results "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Ord.html#Ordering.swap\"><span class=\"name\">Ordering</span>.<span class=\"name\">swap</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Ord.html#Ordering\">Ordering</a> → <a href=\"./Init/Data/Ord.html#Ordering\">Ordering</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Data/Ord.lean#L9-L9","name":"Ordering.instDecidableEqOrdering","line":9,"kind":"instance","docLink":"./Std/Data/Ord.html#Ordering.instDecidableEqOrdering","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Data/Ord.html#Ordering.instDecidableEqOrdering\"><span class=\"name\">Ordering</span>.<span class=\"name\">instDecidableEqOrdering</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <a href=\"./Init/Data/Ord.html#Ordering\">Ordering</a></span></div></div>"}]}