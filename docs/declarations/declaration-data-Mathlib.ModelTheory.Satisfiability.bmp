{"name":"Mathlib.ModelTheory.Satisfiability","instances":[{"typeNames":["FirstOrder.Language.BoundedFormula","FirstOrder.Language.Theory.SemanticallyEquivalent"],"name":"FirstOrder.Language.Theory.instIsReflBoundedFormulaSemanticallyEquivalent","className":"IsRefl"}],"imports":["Init","Mathlib.ModelTheory.Ultraproducts","Mathlib.ModelTheory.Bundled","Mathlib.ModelTheory.Skolem"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L704-L708","name":"Cardinal.empty_infinite_Theory_isComplete","line":704,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#Cardinal.empty_infinite_Theory_isComplete","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#Cardinal.empty_infinite_Theory_isComplete\"><span class=\"name\">Cardinal</span>.<span class=\"name\">empty_infinite_Theory_isComplete</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsComplete\">FirstOrder.Language.Theory.IsComplete</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.infiniteTheory\">FirstOrder.Language.infiniteTheory</a> <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language.empty\">FirstOrder.Language.empty</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L700-L701","name":"Cardinal.empty_theory_categorical","line":700,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#Cardinal.empty_theory_categorical","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#Cardinal.empty_theory_categorical\"><span class=\"name\">Cardinal</span>.<span class=\"name\">empty_theory_categorical</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(κ : <a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal\">Cardinal.{w}</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language.empty\">FirstOrder.Language.empty</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#Cardinal.Categorical\">Cardinal.Categorical</a> <span class=\"fn\">κ</span> <span class=\"fn\">T</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L680-L697","name":"Cardinal.Categorical.isComplete","line":680,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#Cardinal.Categorical.isComplete","doc":"The Łoś–Vaught Test : a criterion for categorical theories to be complete. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#Cardinal.Categorical.isComplete\"><span class=\"name\">Cardinal</span>.<span class=\"name\">Categorical</span>.<span class=\"name\">isComplete</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(κ : <a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal\">Cardinal.{w}</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#Cardinal.Categorical\">Cardinal.Categorical</a> <span class=\"fn\">κ</span> <span class=\"fn\">T</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h1 : <span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.aleph0\">Cardinal.aleph0</a> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">κ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h2 : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{w, max u v}</a>          <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language.card\">FirstOrder.Language.card</a> <span class=\"fn\">L</span></span>)</span></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{max u v, w}</a>         <span class=\"fn\">κ</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hS : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable\">FirstOrder.Language.Theory.IsSatisfiable</a> <span class=\"fn\">T</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hT : <span class=\"fn\">∀ (<span class=\"fn\">M</span> : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Bundled.html#FirstOrder.Language.Theory.ModelType\">FirstOrder.Language.Theory.ModelType</a> <span class=\"fn\">T</span></span>), <span class=\"fn\"><a href=\"./Mathlib/Data/Finite/Defs.html#Infinite\">Infinite</a> <span class=\"fn\">↑<span class=\"fn\">M</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsComplete\">FirstOrder.Language.Theory.IsComplete</a> <span class=\"fn\">T</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L675-L676","name":"Cardinal.Categorical","line":675,"kind":"def","docLink":"./Mathlib/ModelTheory/Satisfiability.html#Cardinal.Categorical","doc":"A theory is `κ`-categorical if all models of size `κ` are isomorphic. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#Cardinal.Categorical\"><span class=\"name\">Cardinal</span>.<span class=\"name\">Categorical</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(κ : <a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal\">Cardinal.{w}</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L650-L659","name":"FirstOrder.Language.BoundedFormula.induction_on_exists_not","line":650,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.induction_on_exists_not","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.induction_on_exists_not\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">BoundedFormula</span>.<span class=\"name\">induction_on_exists_not</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">{<span class=\"fn\">m</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>} → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">m</span></span> → <a href=\"./foundational_types.html\">Prop</a></span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hqf : <span class=\"fn\">∀ {<span class=\"fn\">m</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>} {<span class=\"fn\">ψ</span> : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">m</span></span>}, <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.IsQF\">FirstOrder.Language.BoundedFormula.IsQF</a> <span class=\"fn\">ψ</span></span> → <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">ψ</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hnot : <span class=\"fn\">∀ {<span class=\"fn\">m</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>} {<span class=\"fn\">φ</span> : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">m</span></span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ</span></span> → <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.not\">FirstOrder.Language.BoundedFormula.not</a> <span class=\"fn\">φ</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hex : <span class=\"fn\">∀ {<span class=\"fn\">m</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>} {<span class=\"fn\">φ</span> : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span></span>)</span></span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ</span></span> → <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.ex\">FirstOrder.Language.BoundedFormula.ex</a> <span class=\"fn\">φ</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hse : <span class=\"fn\">∀ {<span class=\"fn\">m</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>} {<span class=\"fn\">φ₁ </span>φ₂ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">m</span></span>},\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <a href=\"./Init/Core.html#EmptyCollection.emptyCollection\">∅</a> <span class=\"fn\">φ₁</span> <span class=\"fn\">φ₂</span></span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ₁</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ₂</span></span></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L634-L647","name":"FirstOrder.Language.BoundedFormula.induction_on_all_ex","line":634,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.induction_on_all_ex","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.induction_on_all_ex\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">BoundedFormula</span>.<span class=\"name\">induction_on_all_ex</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">{<span class=\"fn\">m</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>} → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">m</span></span> → <a href=\"./foundational_types.html\">Prop</a></span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hqf : <span class=\"fn\">∀ {<span class=\"fn\">m</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>} {<span class=\"fn\">ψ</span> : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">m</span></span>}, <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.IsQF\">FirstOrder.Language.BoundedFormula.IsQF</a> <span class=\"fn\">ψ</span></span> → <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">ψ</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hall : <span class=\"fn\">∀ {<span class=\"fn\">m</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>} {<span class=\"fn\">ψ</span> : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span></span>)</span></span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">ψ</span></span> → <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.all\">FirstOrder.Language.BoundedFormula.all</a> <span class=\"fn\">ψ</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hex : <span class=\"fn\">∀ {<span class=\"fn\">m</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>} {<span class=\"fn\">φ</span> : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span></span>)</span></span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ</span></span> → <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.ex\">FirstOrder.Language.BoundedFormula.ex</a> <span class=\"fn\">φ</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hse : <span class=\"fn\">∀ {<span class=\"fn\">m</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>} {<span class=\"fn\">φ₁ </span>φ₂ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">m</span></span>},\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <a href=\"./Init/Core.html#EmptyCollection.emptyCollection\">∅</a> <span class=\"fn\">φ₁</span> <span class=\"fn\">φ₂</span></span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ₁</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ₂</span></span></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L629-L631","name":"FirstOrder.Language.BoundedFormula.semanticallyEquivalent_toPrenex","line":629,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.semanticallyEquivalent_toPrenex","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.semanticallyEquivalent_toPrenex\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">BoundedFormula</span>.<span class=\"name\">semanticallyEquivalent_toPrenex</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <a href=\"./Init/Core.html#EmptyCollection.emptyCollection\">∅</a> <span class=\"fn\">φ</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.toPrenex\">FirstOrder.Language.BoundedFormula.toPrenex</a> <span class=\"fn\">φ</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L616-L626","name":"FirstOrder.Language.BoundedFormula.IsQF.induction_on_inf_not","line":616,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.IsQF.induction_on_inf_not","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.IsQF.induction_on_inf_not\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">BoundedFormula</span>.<span class=\"name\">IsQF</span>.<span class=\"name\">induction_on_inf_not</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span> → <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.IsQF\">FirstOrder.Language.BoundedFormula.IsQF</a> <span class=\"fn\">φ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Order/Notation.html#Bot.bot\">⊥</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ha : <span class=\"fn\">∀ (<span class=\"fn\">ψ</span> : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.IsAtomic\">FirstOrder.Language.BoundedFormula.IsAtomic</a> <span class=\"fn\">ψ</span></span> → <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">ψ</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hinf : <span class=\"fn\">∀ {<span class=\"fn\">φ₁ </span>φ₂ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ₁</span></span> → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ₂</span></span> → <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">φ₁</span> <a href=\"./Mathlib/Order/Notation.html#Inf.inf\">⊓</a> <span class=\"fn\">φ₂</span></span>)</span></span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hnot : <span class=\"fn\">∀ {<span class=\"fn\">φ</span> : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ</span></span> → <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.not\">FirstOrder.Language.BoundedFormula.not</a> <span class=\"fn\">φ</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hse : <span class=\"fn\">∀ {<span class=\"fn\">φ₁ </span>φ₂ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>},\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <a href=\"./Init/Core.html#EmptyCollection.emptyCollection\">∅</a> <span class=\"fn\">φ₁</span> <span class=\"fn\">φ₂</span></span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ₁</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ₂</span></span></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L605-L613","name":"FirstOrder.Language.BoundedFormula.IsQF.induction_on_sup_not","line":605,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.IsQF.induction_on_sup_not","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.IsQF.induction_on_sup_not\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">BoundedFormula</span>.<span class=\"name\">IsQF</span>.<span class=\"name\">induction_on_sup_not</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span> → <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.IsQF\">FirstOrder.Language.BoundedFormula.IsQF</a> <span class=\"fn\">φ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Order/Notation.html#Bot.bot\">⊥</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ha : <span class=\"fn\">∀ (<span class=\"fn\">ψ</span> : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.IsAtomic\">FirstOrder.Language.BoundedFormula.IsAtomic</a> <span class=\"fn\">ψ</span></span> → <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">ψ</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hsup : <span class=\"fn\">∀ {<span class=\"fn\">φ₁ </span>φ₂ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ₁</span></span> → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ₂</span></span> → <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">φ₁</span> <a href=\"./Mathlib/Order/Notation.html#Sup.sup\">⊔</a> <span class=\"fn\">φ₂</span></span>)</span></span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hnot : <span class=\"fn\">∀ {<span class=\"fn\">φ</span> : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ</span></span> → <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.not\">FirstOrder.Language.BoundedFormula.not</a> <span class=\"fn\">φ</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hse : <span class=\"fn\">∀ {<span class=\"fn\">φ₁ </span>φ₂ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>},\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <a href=\"./Init/Core.html#EmptyCollection.emptyCollection\">∅</a> <span class=\"fn\">φ₁</span> <span class=\"fn\">φ₂</span></span> → <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ₁</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ₂</span></span></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">φ</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L596-L598","name":"FirstOrder.Language.Formula.inf_semanticallyEquivalent_not_sup_not","line":596,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Formula.inf_semanticallyEquivalent_not_sup_not","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Formula.inf_semanticallyEquivalent_not_sup_not\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Formula</span>.<span class=\"name\">inf_semanticallyEquivalent_not_sup_not</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Formula\">FirstOrder.Language.Formula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ψ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Formula\">FirstOrder.Language.Formula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <span class=\"fn\">T</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">φ</span> <a href=\"./Mathlib/Order/Notation.html#Inf.inf\">⊓</a> <span class=\"fn\">ψ</span></span>)</span>\n  <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Formula.not\">FirstOrder.Language.Formula.not</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Formula.not\">FirstOrder.Language.Formula.not</a> <span class=\"fn\">φ</span></span> <a href=\"./Mathlib/Order/Notation.html#Sup.sup\">⊔</a> <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Formula.not\">FirstOrder.Language.Formula.not</a> <span class=\"fn\">ψ</span></span></span>)</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L591-L593","name":"FirstOrder.Language.Formula.sup_semanticallyEquivalent_not_inf_not","line":591,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Formula.sup_semanticallyEquivalent_not_inf_not","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Formula.sup_semanticallyEquivalent_not_inf_not\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Formula</span>.<span class=\"name\">sup_semanticallyEquivalent_not_inf_not</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Formula\">FirstOrder.Language.Formula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ψ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Formula\">FirstOrder.Language.Formula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <span class=\"fn\">T</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">φ</span> <a href=\"./Mathlib/Order/Notation.html#Sup.sup\">⊔</a> <span class=\"fn\">ψ</span></span>)</span>\n  <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Formula.not\">FirstOrder.Language.Formula.not</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Formula.not\">FirstOrder.Language.Formula.not</a> <span class=\"fn\">φ</span></span> <a href=\"./Mathlib/Order/Notation.html#Inf.inf\">⊓</a> <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Formula.not\">FirstOrder.Language.Formula.not</a> <span class=\"fn\">ψ</span></span></span>)</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L587-L588","name":"FirstOrder.Language.Formula.imp_semanticallyEquivalent_not_sup","line":587,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Formula.imp_semanticallyEquivalent_not_sup","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Formula.imp_semanticallyEquivalent_not_sup\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Formula</span>.<span class=\"name\">imp_semanticallyEquivalent_not_sup</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Formula\">FirstOrder.Language.Formula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ψ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Formula\">FirstOrder.Language.Formula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <span class=\"fn\">T</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Formula.imp\">FirstOrder.Language.Formula.imp</a> <span class=\"fn\">φ</span> <span class=\"fn\">ψ</span></span>)</span>\n  <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Formula.not\">FirstOrder.Language.Formula.not</a> <span class=\"fn\">φ</span></span> <a href=\"./Mathlib/Order/Notation.html#Sup.sup\">⊔</a> <span class=\"fn\">ψ</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L583-L584","name":"FirstOrder.Language.Formula.semanticallyEquivalent_not_not","line":583,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Formula.semanticallyEquivalent_not_not","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Formula.semanticallyEquivalent_not_not\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Formula</span>.<span class=\"name\">semanticallyEquivalent_not_not</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Formula\">FirstOrder.Language.Formula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <span class=\"fn\">T</span> <span class=\"fn\">φ</span>\n  <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Formula.not\">FirstOrder.Language.Formula.not</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Formula.not\">FirstOrder.Language.Formula.not</a> <span class=\"fn\">φ</span></span>)</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L571-L574","name":"FirstOrder.Language.BoundedFormula.semanticallyEquivalent_all_liftAt","line":571,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.semanticallyEquivalent_all_liftAt","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.semanticallyEquivalent_all_liftAt\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">BoundedFormula</span>.<span class=\"name\">semanticallyEquivalent_all_liftAt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <span class=\"fn\">T</span> <span class=\"fn\">φ</span>\n  <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.all\">FirstOrder.Language.BoundedFormula.all</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.liftAt\">FirstOrder.Language.BoundedFormula.liftAt</a> <span class=\"fn\">1</span> <span class=\"fn\">n</span> <span class=\"fn\">φ</span></span>)</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L567-L568","name":"FirstOrder.Language.BoundedFormula.ex_semanticallyEquivalent_not_all_not","line":567,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.ex_semanticallyEquivalent_not_all_not","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.ex_semanticallyEquivalent_not_all_not\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">BoundedFormula</span>.<span class=\"name\">ex_semanticallyEquivalent_not_all_not</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">n</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <span class=\"fn\">T</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.ex\">FirstOrder.Language.BoundedFormula.ex</a> <span class=\"fn\">φ</span></span>)</span>\n  <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.not\">FirstOrder.Language.BoundedFormula.not</a>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.all\">FirstOrder.Language.BoundedFormula.all</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.not\">FirstOrder.Language.BoundedFormula.not</a> <span class=\"fn\">φ</span></span>)</span></span>)</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L563-L564","name":"FirstOrder.Language.BoundedFormula.all_semanticallyEquivalent_not_ex_not","line":563,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.all_semanticallyEquivalent_not_ex_not","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.all_semanticallyEquivalent_not_ex_not\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">BoundedFormula</span>.<span class=\"name\">all_semanticallyEquivalent_not_ex_not</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">n</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <span class=\"fn\">T</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.all\">FirstOrder.Language.BoundedFormula.all</a> <span class=\"fn\">φ</span></span>)</span>\n  <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.not\">FirstOrder.Language.BoundedFormula.not</a>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.ex\">FirstOrder.Language.BoundedFormula.ex</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.not\">FirstOrder.Language.BoundedFormula.not</a> <span class=\"fn\">φ</span></span>)</span></span>)</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L558-L560","name":"FirstOrder.Language.BoundedFormula.inf_semanticallyEquivalent_not_sup_not","line":558,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.inf_semanticallyEquivalent_not_sup_not","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.inf_semanticallyEquivalent_not_sup_not\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">BoundedFormula</span>.<span class=\"name\">inf_semanticallyEquivalent_not_sup_not</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ψ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <span class=\"fn\">T</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">φ</span> <a href=\"./Mathlib/Order/Notation.html#Inf.inf\">⊓</a> <span class=\"fn\">ψ</span></span>)</span>\n  <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.not\">FirstOrder.Language.BoundedFormula.not</a>\n    <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.not\">FirstOrder.Language.BoundedFormula.not</a> <span class=\"fn\">φ</span></span> <a href=\"./Mathlib/Order/Notation.html#Sup.sup\">⊔</a> <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.not\">FirstOrder.Language.BoundedFormula.not</a> <span class=\"fn\">ψ</span></span></span>)</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L554-L555","name":"FirstOrder.Language.BoundedFormula.sup_semanticallyEquivalent_not_inf_not","line":554,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.sup_semanticallyEquivalent_not_inf_not","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.sup_semanticallyEquivalent_not_inf_not\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">BoundedFormula</span>.<span class=\"name\">sup_semanticallyEquivalent_not_inf_not</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ψ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <span class=\"fn\">T</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">φ</span> <a href=\"./Mathlib/Order/Notation.html#Sup.sup\">⊔</a> <span class=\"fn\">ψ</span></span>)</span>\n  <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.not\">FirstOrder.Language.BoundedFormula.not</a>\n    <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.not\">FirstOrder.Language.BoundedFormula.not</a> <span class=\"fn\">φ</span></span> <a href=\"./Mathlib/Order/Notation.html#Inf.inf\">⊓</a> <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.not\">FirstOrder.Language.BoundedFormula.not</a> <span class=\"fn\">ψ</span></span></span>)</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L550-L551","name":"FirstOrder.Language.BoundedFormula.imp_semanticallyEquivalent_not_sup","line":550,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.imp_semanticallyEquivalent_not_sup","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.imp_semanticallyEquivalent_not_sup\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">BoundedFormula</span>.<span class=\"name\">imp_semanticallyEquivalent_not_sup</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ψ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <span class=\"fn\">T</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.imp\">FirstOrder.Language.BoundedFormula.imp</a> <span class=\"fn\">φ</span> <span class=\"fn\">ψ</span></span>)</span>\n  <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.not\">FirstOrder.Language.BoundedFormula.not</a> <span class=\"fn\">φ</span></span> <a href=\"./Mathlib/Order/Notation.html#Sup.sup\">⊔</a> <span class=\"fn\">ψ</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L546-L547","name":"FirstOrder.Language.BoundedFormula.semanticallyEquivalent_not_not","line":546,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.semanticallyEquivalent_not_not","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.BoundedFormula.semanticallyEquivalent_not_not\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">BoundedFormula</span>.<span class=\"name\">semanticallyEquivalent_not_not</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <span class=\"fn\">T</span> <span class=\"fn\">φ</span>\n  <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.not\">FirstOrder.Language.BoundedFormula.not</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.not\">FirstOrder.Language.BoundedFormula.not</a> <span class=\"fn\">φ</span></span>)</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L536-L537","name":"FirstOrder.Language.completeTheory.isComplete","line":536,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.completeTheory.isComplete","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.completeTheory.isComplete\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">completeTheory</span>.<span class=\"name\">isComplete</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(M : <a href=\"./foundational_types.html\">Type</a> w)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language.Structure\">FirstOrder.Language.Structure</a> <span class=\"fn\">L</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsComplete\">FirstOrder.Language.Theory.IsComplete</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.completeTheory\">FirstOrder.Language.completeTheory</a> <span class=\"fn\">L</span> <span class=\"fn\">M</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L532-L533","name":"FirstOrder.Language.completeTheory.isMaximal","line":532,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.completeTheory.isMaximal","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.completeTheory.isMaximal\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">completeTheory</span>.<span class=\"name\">isMaximal</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(M : <a href=\"./foundational_types.html\">Type</a> w)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language.Structure\">FirstOrder.Language.Structure</a> <span class=\"fn\">L</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsMaximal\">FirstOrder.Language.Theory.IsMaximal</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.completeTheory\">FirstOrder.Language.completeTheory</a> <span class=\"fn\">L</span> <span class=\"fn\">M</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L528-L529","name":"FirstOrder.Language.completeTheory.mem_or_not_mem","line":528,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.completeTheory.mem_or_not_mem","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.completeTheory.mem_or_not_mem\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">completeTheory</span>.<span class=\"name\">mem_or_not_mem</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(M : <a href=\"./foundational_types.html\">Type</a> w)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language.Structure\">FirstOrder.Language.Structure</a> <span class=\"fn\">L</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Sentence\">FirstOrder.Language.Sentence</a> <span class=\"fn\">L</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">φ</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.completeTheory\">FirstOrder.Language.completeTheory</a> <span class=\"fn\">L</span> <span class=\"fn\">M</span></span></span> <a href=\"./Init/Prelude.html#Or\">∨</a> <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Formula.not\">FirstOrder.Language.Formula.not</a> <span class=\"fn\">φ</span></span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.completeTheory\">FirstOrder.Language.completeTheory</a> <span class=\"fn\">L</span> <span class=\"fn\">M</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L524-L525","name":"FirstOrder.Language.completeTheory.isSatisfiable","line":524,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.completeTheory.isSatisfiable","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.completeTheory.isSatisfiable\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">completeTheory</span>.<span class=\"name\">isSatisfiable</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(M : <a href=\"./foundational_types.html\">Type</a> w)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language.Structure\">FirstOrder.Language.Structure</a> <span class=\"fn\">L</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable\">FirstOrder.Language.Theory.IsSatisfiable</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.completeTheory\">FirstOrder.Language.completeTheory</a> <span class=\"fn\">L</span> <span class=\"fn\">M</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L509-L514","name":"FirstOrder.Language.Theory.SemanticallyEquivalent.imp","line":509,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.imp","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.imp\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">SemanticallyEquivalent</span>.<span class=\"name\">imp</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ψ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ' : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ψ' : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <span class=\"fn\">T</span> <span class=\"fn\">φ</span> <span class=\"fn\">ψ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h' : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <span class=\"fn\">T</span> <span class=\"fn\">φ'</span> <span class=\"fn\">ψ'</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <span class=\"fn\">T</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.imp\">FirstOrder.Language.BoundedFormula.imp</a> <span class=\"fn\">φ</span> <span class=\"fn\">φ'</span></span>)</span>\n  <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.imp\">FirstOrder.Language.BoundedFormula.imp</a> <span class=\"fn\">ψ</span> <span class=\"fn\">ψ'</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L502-L506","name":"FirstOrder.Language.Theory.SemanticallyEquivalent.not","line":502,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.not","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.not\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">SemanticallyEquivalent</span>.<span class=\"name\">not</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ψ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <span class=\"fn\">T</span> <span class=\"fn\">φ</span> <span class=\"fn\">ψ</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <span class=\"fn\">T</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.not\">FirstOrder.Language.BoundedFormula.not</a> <span class=\"fn\">φ</span></span>)</span>\n  <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.not\">FirstOrder.Language.BoundedFormula.not</a> <span class=\"fn\">ψ</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L495-L499","name":"FirstOrder.Language.Theory.SemanticallyEquivalent.ex","line":495,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.ex","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.ex\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">SemanticallyEquivalent</span>.<span class=\"name\">ex</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">n</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ψ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">n</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <span class=\"fn\">T</span> <span class=\"fn\">φ</span> <span class=\"fn\">ψ</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <span class=\"fn\">T</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.ex\">FirstOrder.Language.BoundedFormula.ex</a> <span class=\"fn\">φ</span></span>)</span>\n  <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.ex\">FirstOrder.Language.BoundedFormula.ex</a> <span class=\"fn\">ψ</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L488-L492","name":"FirstOrder.Language.Theory.SemanticallyEquivalent.all","line":488,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.all","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.all\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">SemanticallyEquivalent</span>.<span class=\"name\">all</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">n</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span></span>)</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ψ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">n</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span></span>)</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <span class=\"fn\">T</span> <span class=\"fn\">φ</span> <span class=\"fn\">ψ</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <span class=\"fn\">T</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.all\">FirstOrder.Language.BoundedFormula.all</a> <span class=\"fn\">φ</span></span>)</span>\n  <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula.all\">FirstOrder.Language.BoundedFormula.all</a> <span class=\"fn\">ψ</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L483-L485","name":"FirstOrder.Language.Theory.semanticallyEquivalentSetoid","line":483,"kind":"def","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.semanticallyEquivalentSetoid","doc":"Semantic equivalence forms an equivalence relation on formulas. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.semanticallyEquivalentSetoid\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">semanticallyEquivalentSetoid</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#Setoid\">Setoid</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L476-L479","name":"FirstOrder.Language.Theory.SemanticallyEquivalent.realize_iff","line":476,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.realize_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.realize_iff\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">SemanticallyEquivalent</span>.<span class=\"name\">realize_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Formula\">FirstOrder.Language.Formula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ψ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Formula\">FirstOrder.Language.Formula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{M : <a href=\"./foundational_types.html\">Type</a> (max u v)}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language.Structure\">FirstOrder.Language.Structure</a> <span class=\"fn\">L</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(_hM : <span class=\"fn\"><span class=\"fn\">M</span> <a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.Theory.Model\">⊨</a> <span class=\"fn\">T</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <span class=\"fn\">T</span> <span class=\"fn\">φ</span> <span class=\"fn\">ψ</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{v : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.Formula.Realize\">FirstOrder.Language.Formula.Realize</a> <span class=\"fn\">φ</span> <span class=\"fn\">v</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.Formula.Realize\">FirstOrder.Language.Formula.Realize</a> <span class=\"fn\">ψ</span> <span class=\"fn\">v</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L470-L473","name":"FirstOrder.Language.Theory.SemanticallyEquivalent.realize_bd_iff","line":470,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.realize_bd_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.realize_bd_iff\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">SemanticallyEquivalent</span>.<span class=\"name\">realize_bd_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ψ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{M : <a href=\"./foundational_types.html\">Type</a> (max u v)}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language.Structure\">FirstOrder.Language.Structure</a> <span class=\"fn\">L</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">M</span> <a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.Theory.Model\">⊨</a> <span class=\"fn\">T</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <span class=\"fn\">T</span> <span class=\"fn\">φ</span> <span class=\"fn\">ψ</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{v : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{xs : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Fin\">Fin</a> <span class=\"fn\">n</span></span> → <span class=\"fn\">M</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.BoundedFormula.Realize\">FirstOrder.Language.BoundedFormula.Realize</a> <span class=\"fn\">φ</span> <span class=\"fn\">v</span> <span class=\"fn\">xs</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.BoundedFormula.Realize\">FirstOrder.Language.BoundedFormula.Realize</a> <span class=\"fn\">ψ</span> <span class=\"fn\">v</span> <span class=\"fn\">xs</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L461-L467","name":"FirstOrder.Language.Theory.SemanticallyEquivalent.trans","line":461,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.trans","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.trans\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">SemanticallyEquivalent</span>.<span class=\"name\">trans</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ψ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{θ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h1 : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <span class=\"fn\">T</span> <span class=\"fn\">φ</span> <span class=\"fn\">ψ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h2 : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <span class=\"fn\">T</span> <span class=\"fn\">ψ</span> <span class=\"fn\">θ</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <span class=\"fn\">T</span> <span class=\"fn\">φ</span> <span class=\"fn\">θ</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L454-L457","name":"FirstOrder.Language.Theory.SemanticallyEquivalent.symm","line":454,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.symm","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.symm\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">SemanticallyEquivalent</span>.<span class=\"name\">symm</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ψ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <span class=\"fn\">T</span> <span class=\"fn\">φ</span> <span class=\"fn\">ψ</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <span class=\"fn\">T</span> <span class=\"fn\">ψ</span> <span class=\"fn\">φ</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L450-L451","name":"FirstOrder.Language.Theory.instIsReflBoundedFormulaSemanticallyEquivalent","line":450,"kind":"instance","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.instIsReflBoundedFormulaSemanticallyEquivalent","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.instIsReflBoundedFormulaSemanticallyEquivalent\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">instIsReflBoundedFormulaSemanticallyEquivalent</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Init/Algebra/Classes.html#IsRefl\">IsRefl</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <span class=\"fn\">T</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L446-L447","name":"FirstOrder.Language.Theory.SemanticallyEquivalent.refl","line":446,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.refl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent.refl\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">SemanticallyEquivalent</span>.<span class=\"name\">refl</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\">FirstOrder.Language.Theory.SemanticallyEquivalent</a> <span class=\"fn\">T</span> <span class=\"fn\">φ</span> <span class=\"fn\">φ</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L441-L442","name":"FirstOrder.Language.Theory.SemanticallyEquivalent","line":441,"kind":"def","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent","doc":"Two (bounded) formulas are semantically equivalent over a theory `T` when they have the same\ninterpretation in every model of `T`. (This is also known as logical equivalence, which also has a\nproof-theoretic definition.) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.SemanticallyEquivalent\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">SemanticallyEquivalent</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ψ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L434-L435","name":"FirstOrder.Language.Theory.IsMaximal.mem_iff_models","line":434,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsMaximal.mem_iff_models","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsMaximal.mem_iff_models\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">IsMaximal</span>.<span class=\"name\">mem_iff_models</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsMaximal\">FirstOrder.Language.Theory.IsMaximal</a> <span class=\"fn\">T</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Sentence\">FirstOrder.Language.Sentence</a> <span class=\"fn\">L</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">φ</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">T</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\">T</span> <a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula\">⊨ᵇ</a> <span class=\"fn\">φ</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L428-L431","name":"FirstOrder.Language.Theory.IsMaximal.mem_of_models","line":428,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsMaximal.mem_of_models","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsMaximal.mem_of_models\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">IsMaximal</span>.<span class=\"name\">mem_of_models</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsMaximal\">FirstOrder.Language.Theory.IsMaximal</a> <span class=\"fn\">T</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Sentence\">FirstOrder.Language.Sentence</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hφ : <span class=\"fn\"><span class=\"fn\">T</span> <a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula\">⊨ᵇ</a> <span class=\"fn\">φ</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">φ</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">T</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L424-L425","name":"FirstOrder.Language.Theory.IsMaximal.mem_or_not_mem","line":424,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsMaximal.mem_or_not_mem","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsMaximal.mem_or_not_mem\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">IsMaximal</span>.<span class=\"name\">mem_or_not_mem</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsMaximal\">FirstOrder.Language.Theory.IsMaximal</a> <span class=\"fn\">T</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Sentence\">FirstOrder.Language.Sentence</a> <span class=\"fn\">L</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">φ</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">T</span></span> <a href=\"./Init/Prelude.html#Or\">∨</a> <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Formula.not\">FirstOrder.Language.Formula.not</a> <span class=\"fn\">φ</span></span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">T</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L420-L421","name":"FirstOrder.Language.Theory.IsMaximal.isComplete","line":420,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsMaximal.isComplete","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsMaximal.isComplete\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">IsMaximal</span>.<span class=\"name\">isComplete</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsMaximal\">FirstOrder.Language.Theory.IsMaximal</a> <span class=\"fn\">T</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsComplete\">FirstOrder.Language.Theory.IsComplete</a> <span class=\"fn\">T</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L416-L417","name":"FirstOrder.Language.Theory.IsMaximal","line":416,"kind":"def","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsMaximal","doc":"A theory is maximal when it is satisfiable and contains each sentence or its negation.\nMaximal theories are complete. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsMaximal\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">IsMaximal</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L403-L409","name":"FirstOrder.Language.Theory.IsComplete.realize_sentence_iff","line":403,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsComplete.realize_sentence_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsComplete.realize_sentence_iff\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">IsComplete</span>.<span class=\"name\">realize_sentence_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsComplete\">FirstOrder.Language.Theory.IsComplete</a> <span class=\"fn\">T</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Sentence\">FirstOrder.Language.Sentence</a> <span class=\"fn\">L</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(M : <a href=\"./foundational_types.html\">Type</a> u_1)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language.Structure\">FirstOrder.Language.Structure</a> <span class=\"fn\">L</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">M</span> <a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.Theory.Model\">⊨</a> <span class=\"fn\">T</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">M</span> <a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.Sentence.Realize\">⊨</a> <span class=\"fn\">φ</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\">T</span> <a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula\">⊨ᵇ</a> <span class=\"fn\">φ</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L390-L400","name":"FirstOrder.Language.Theory.IsComplete.models_not_iff","line":390,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsComplete.models_not_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsComplete.models_not_iff\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">IsComplete</span>.<span class=\"name\">models_not_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsComplete\">FirstOrder.Language.Theory.IsComplete</a> <span class=\"fn\">T</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Sentence\">FirstOrder.Language.Sentence</a> <span class=\"fn\">L</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span> <a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula\">⊨ᵇ</a> <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Formula.not\">FirstOrder.Language.Formula.not</a> <span class=\"fn\">φ</span></span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\"><span class=\"fn\">T</span> <a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula\">⊨ᵇ</a> <span class=\"fn\">φ</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L384-L385","name":"FirstOrder.Language.Theory.IsComplete","line":384,"kind":"def","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsComplete","doc":"A theory is complete when it is satisfiable and models each sentence or its negation. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsComplete\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">IsComplete</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L367-L381","name":"FirstOrder.Language.Theory.models_iff_finset_models","line":367,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.models_iff_finset_models","doc":"An alternative statement of the Compactness Theorem. A formula `φ` is modeled by a\ntheory iff there is a finite subset `T0` of the theory such that `φ` is modeled by `T0` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.models_iff_finset_models\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">models_iff_finset_models</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Sentence\">FirstOrder.Language.Sentence</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span> <a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula\">⊨ᵇ</a> <span class=\"fn\">φ</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∃ (T0 : <span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Basic.html#Finset\">Finset</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Sentence\">FirstOrder.Language.Sentence</a> <span class=\"fn\">L</span></span>)</span></span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">T0</span></span> <a href=\"./Std/Classes/SetNotation.html#HasSubset.Subset\">⊆</a> <span class=\"fn\">T</span></span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">T0</span></span> <a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula\">⊨ᵇ</a> <span class=\"fn\">φ</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L356-L363","name":"FirstOrder.Language.Theory.models_of_models_theory","line":356,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.models_of_models_theory","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.models_of_models_theory\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">models_of_models_theory</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T' : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ <span class=\"fn\">φ</span> ∈ <span class=\"fn\">T'</span>, <span class=\"fn\"><span class=\"fn\">T</span> <a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula\">⊨ᵇ</a> <span class=\"fn\">φ</span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Formula\">FirstOrder.Language.Formula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hφ : <span class=\"fn\"><span class=\"fn\">T'</span> <a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula\">⊨ᵇ</a> <span class=\"fn\">φ</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">T</span> <a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula\">⊨ᵇ</a> <span class=\"fn\">φ</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L344-L353","name":"FirstOrder.Language.Theory.ModelsBoundedFormula.realize_sentence","line":344,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula.realize_sentence","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula.realize_sentence\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">ModelsBoundedFormula</span>.<span class=\"name\">realize_sentence</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Sentence\">FirstOrder.Language.Sentence</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">T</span> <a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula\">⊨ᵇ</a> <span class=\"fn\">φ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(M : <a href=\"./foundational_types.html\">Type</a> u_1)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language.Structure\">FirstOrder.Language.Structure</a> <span class=\"fn\">L</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">M</span> <a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.Theory.Model\">⊨</a> <span class=\"fn\">T</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">M</span> <a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.Sentence.Realize\">⊨</a> <span class=\"fn\">φ</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L326-L341","name":"FirstOrder.Language.Theory.models_iff_not_satisfiable","line":326,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.models_iff_not_satisfiable","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.models_iff_not_satisfiable\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">models_iff_not_satisfiable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Sentence\">FirstOrder.Language.Sentence</a> <span class=\"fn\">L</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span> <a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula\">⊨ᵇ</a> <span class=\"fn\">φ</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable\">FirstOrder.Language.Theory.IsSatisfiable</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">T</span> <a href=\"./Std/Classes/SetNotation.html#Union.union\">∪</a> <span class=\"fn\">{<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Formula.not\">FirstOrder.Language.Formula.not</a> <span class=\"fn\">φ</span></span>}</span></span>)</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L322-L323","name":"FirstOrder.Language.Theory.models_sentence_of_mem","line":322,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.models_sentence_of_mem","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.models_sentence_of_mem\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">models_sentence_of_mem</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Sentence\">FirstOrder.Language.Sentence</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">φ</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">T</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">T</span> <a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula\">⊨ᵇ</a> <span class=\"fn\">φ</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L318-L319","name":"FirstOrder.Language.Theory.models_sentence_iff","line":318,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.models_sentence_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.models_sentence_iff\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">models_sentence_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Sentence\">FirstOrder.Language.Sentence</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span> <a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula\">⊨ᵇ</a> <span class=\"fn\">φ</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∀ (<span class=\"fn\">M</span> : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Bundled.html#FirstOrder.Language.Theory.ModelType\">FirstOrder.Language.Theory.ModelType</a> <span class=\"fn\">T</span></span>), <span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">M</span></span> <a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.Sentence.Realize\">⊨</a> <span class=\"fn\">φ</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L313-L315","name":"FirstOrder.Language.Theory.models_formula_iff","line":313,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.models_formula_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.models_formula_iff\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">models_formula_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Formula\">FirstOrder.Language.Formula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">T</span> <a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula\">⊨ᵇ</a> <span class=\"fn\">φ</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∀ (<span class=\"fn\">M</span> : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Bundled.html#FirstOrder.Language.Theory.ModelType\">FirstOrder.Language.Theory.ModelType</a> <span class=\"fn\">T</span></span>) (<span class=\"fn\">v</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">↑<span class=\"fn\">M</span></span></span>), <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.Formula.Realize\">FirstOrder.Language.Formula.Realize</a> <span class=\"fn\">φ</span> <span class=\"fn\">v</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L308-L309","name":"FirstOrder.Language.Theory.«term_⊨ᵇ_»","line":308,"kind":"def","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.«term_⊨ᵇ_»","doc":"A theory models a (bounded) formula when any of its nonempty models realizes that formula on all\ninputs."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.«term_⊨ᵇ_»\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">«term_⊨ᵇ_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.TrailingParserDescr\">Lean.TrailingParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L302-L303","name":"FirstOrder.Language.Theory.ModelsBoundedFormula","line":302,"kind":"def","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula","doc":"A theory models a (bounded) formula when any of its nonempty models realizes that formula on all\ninputs."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.ModelsBoundedFormula\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">ModelsBoundedFormula</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.BoundedFormula\">FirstOrder.Language.BoundedFormula</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L287-L295","name":"FirstOrder.Language.Theory.exists_model_card_eq","line":287,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.exists_model_card_eq","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.exists_model_card_eq\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">exists_model_card_eq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∃ (M : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Bundled.html#FirstOrder.Language.Theory.ModelType\">FirstOrder.Language.Theory.ModelType</a> <span class=\"fn\">T</span></span>), <span class=\"fn\"><a href=\"./Mathlib/Data/Finite/Defs.html#Infinite\">Infinite</a> <span class=\"fn\">↑<span class=\"fn\">M</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(κ : <a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal\">Cardinal.{w}</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h1 : <span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.aleph0\">Cardinal.aleph0</a> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">κ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h2 : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{w, max u v}</a>          <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language.card\">FirstOrder.Language.card</a> <span class=\"fn\">L</span></span>)</span></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{max u v, w}</a>         <span class=\"fn\">κ</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∃ (N : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Bundled.html#FirstOrder.Language.Theory.ModelType\">FirstOrder.Language.Theory.ModelType</a> <span class=\"fn\">T</span></span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk\">Cardinal.mk</a> <span class=\"fn\">↑<span class=\"fn\">N</span></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">κ</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L275-L280","name":"FirstOrder.Language.exists_elementarilyEquivalent_card_eq","line":275,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.exists_elementarilyEquivalent_card_eq","doc":"A consequence of the Löwenheim–Skolem Theorem: If `κ` is a cardinal greater than the\ncardinalities of `L` and an infinite `L`-structure `M`, then there is a structure of cardinality `κ`\nelementarily equivalent to `M`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.exists_elementarilyEquivalent_card_eq\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">exists_elementarilyEquivalent_card_eq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(M : <a href=\"./foundational_types.html\">Type</a> w')</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language.Structure\">FirstOrder.Language.Structure</a> <span class=\"fn\">L</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Data/Finite/Defs.html#Infinite\">Infinite</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(κ : <a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal\">Cardinal.{w}</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h1 : <span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.aleph0\">Cardinal.aleph0</a> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">κ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h2 : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{w, max u v}</a>          <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language.card\">FirstOrder.Language.card</a> <span class=\"fn\">L</span></span>)</span></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{max u v, w}</a>         <span class=\"fn\">κ</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∃ (N : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/ConcreteCategory/Bundled.html#CategoryTheory.Bundled\">CategoryTheory.Bundled</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language.Structure\">FirstOrder.Language.Structure</a> <span class=\"fn\">L</span></span>)</span></span>),\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.ElementarilyEquivalent\">FirstOrder.Language.ElementarilyEquivalent</a> <span class=\"fn\">L</span> <span class=\"fn\">M</span> <span class=\"fn\">↑<span class=\"fn\">N</span></span></span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk\">Cardinal.mk</a> <span class=\"fn\">↑<span class=\"fn\">N</span></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">κ</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L260-L269","name":"FirstOrder.Language.exists_elementaryEmbedding_card_eq","line":260,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.exists_elementaryEmbedding_card_eq","doc":"The Löwenheim–Skolem Theorem: If `κ` is a cardinal greater than the cardinalities of `L`\nand an infinite `L`-structure `M`, then there is an elementary embedding in the appropriate\ndirection between then `M` and a structure of cardinality `κ`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.exists_elementaryEmbedding_card_eq\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">exists_elementaryEmbedding_card_eq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(M : <a href=\"./foundational_types.html\">Type</a> w')</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language.Structure\">FirstOrder.Language.Structure</a> <span class=\"fn\">L</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[iM : <span class=\"fn\"><a href=\"./Mathlib/Data/Finite/Defs.html#Infinite\">Infinite</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(κ : <a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal\">Cardinal.{w}</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h1 : <span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.aleph0\">Cardinal.aleph0</a> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">κ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h2 : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{w, max u v}</a>          <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language.card\">FirstOrder.Language.card</a> <span class=\"fn\">L</span></span>)</span></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{max u v, w}</a>         <span class=\"fn\">κ</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∃ (N : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/ConcreteCategory/Bundled.html#CategoryTheory.Bundled\">CategoryTheory.Bundled</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language.Structure\">FirstOrder.Language.Structure</a> <span class=\"fn\">L</span></span>)</span></span>),\n  <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/ElementaryMaps.html#FirstOrder.Language.ElementaryEmbedding\">FirstOrder.Language.ElementaryEmbedding</a> <span class=\"fn\">L</span> <span class=\"fn\">(<span class=\"fn\">↑<span class=\"fn\">N</span></span>)</span> <span class=\"fn\">M</span></span>)</span></span> <a href=\"./Init/Prelude.html#Or\">∨</a>       <span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/ElementaryMaps.html#FirstOrder.Language.ElementaryEmbedding\">FirstOrder.Language.ElementaryEmbedding</a> <span class=\"fn\">L</span> <span class=\"fn\">M</span> <span class=\"fn\">↑<span class=\"fn\">N</span></span></span>)</span></span></span>)</span> <a href=\"./Init/Prelude.html#And\">∧</a>     <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk\">Cardinal.mk</a> <span class=\"fn\">↑<span class=\"fn\">N</span></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">κ</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L233-L252","name":"FirstOrder.Language.exists_elementaryEmbedding_card_eq_of_ge","line":233,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.exists_elementaryEmbedding_card_eq_of_ge","doc":"The **Upward Löwenheim–Skolem Theorem**: If `κ` is a cardinal greater than the cardinalities of\n`L` and an infinite `L`-structure `M`, then `M` has an elementary extension of cardinality `κ`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.exists_elementaryEmbedding_card_eq_of_ge\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">exists_elementaryEmbedding_card_eq_of_ge</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(M : <a href=\"./foundational_types.html\">Type</a> w')</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language.Structure\">FirstOrder.Language.Structure</a> <span class=\"fn\">L</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[iM : <span class=\"fn\"><a href=\"./Mathlib/Data/Finite/Defs.html#Infinite\">Infinite</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(κ : <a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal\">Cardinal.{w}</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h1 : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{w, max u v}</a>          <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language.card\">FirstOrder.Language.card</a> <span class=\"fn\">L</span></span>)</span></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{max u v, w}</a>         <span class=\"fn\">κ</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h2 : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{w, w'}</a>     <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk\">Cardinal.mk</a> <span class=\"fn\">M</span></span>)</span></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{w', w}</a>    <span class=\"fn\">κ</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∃ (N : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/ConcreteCategory/Bundled.html#CategoryTheory.Bundled\">CategoryTheory.Bundled</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language.Structure\">FirstOrder.Language.Structure</a> <span class=\"fn\">L</span></span>)</span></span>),\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/ElementaryMaps.html#FirstOrder.Language.ElementaryEmbedding\">FirstOrder.Language.ElementaryEmbedding</a> <span class=\"fn\">L</span> <span class=\"fn\">M</span> <span class=\"fn\">↑<span class=\"fn\">N</span></span></span>)</span></span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk\">Cardinal.mk</a> <span class=\"fn\">↑<span class=\"fn\">N</span></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">κ</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L212-L224","name":"FirstOrder.Language.exists_elementaryEmbedding_card_eq_of_le","line":212,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.exists_elementaryEmbedding_card_eq_of_le","doc":"A version of The Downward Löwenheim–Skolem theorem where the structure `N` elementarily embeds\ninto `M`, but is not by type a substructure of `M`, and thus can be chosen to belong to the universe\nof the cardinal `κ`.\n "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.exists_elementaryEmbedding_card_eq_of_le\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">exists_elementaryEmbedding_card_eq_of_le</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(M : <a href=\"./foundational_types.html\">Type</a> w')</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language.Structure\">FirstOrder.Language.Structure</a> <span class=\"fn\">L</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(κ : <a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal\">Cardinal.{w}</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h1 : <span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.aleph0\">Cardinal.aleph0</a> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\">κ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h2 : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{w, max u v}</a>          <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language.card\">FirstOrder.Language.card</a> <span class=\"fn\">L</span></span>)</span></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{max u v, w}</a>         <span class=\"fn\">κ</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h3 : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{w', w}</a>    <span class=\"fn\">κ</span></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{w, w'}</a>     <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk\">Cardinal.mk</a> <span class=\"fn\">M</span></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∃ (N : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/ConcreteCategory/Bundled.html#CategoryTheory.Bundled\">CategoryTheory.Bundled</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language.Structure\">FirstOrder.Language.Structure</a> <span class=\"fn\">L</span></span>)</span></span>),\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/ElementaryMaps.html#FirstOrder.Language.ElementaryEmbedding\">FirstOrder.Language.ElementaryEmbedding</a> <span class=\"fn\">L</span> <span class=\"fn\">(<span class=\"fn\">↑<span class=\"fn\">N</span></span>)</span> <span class=\"fn\">M</span></span>)</span></span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk\">Cardinal.mk</a> <span class=\"fn\">↑<span class=\"fn\">N</span></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">κ</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L189-L201","name":"FirstOrder.Language.Theory.isSatisfiable_iUnion_iff_isSatisfiable_iUnion_finset","line":189,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.isSatisfiable_iUnion_iff_isSatisfiable_iUnion_finset","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.isSatisfiable_iUnion_iff_isSatisfiable_iUnion_finset\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">isSatisfiable_iUnion_iff_isSatisfiable_iUnion_finset</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ι : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(T : <span class=\"fn\"><span class=\"fn\">ι</span> → <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable\">FirstOrder.Language.Theory.IsSatisfiable</a> <span class=\"fn\">(<span class=\"fn\">⋃ (i : <span class=\"fn\">ι</span>), <span class=\"fn\"><span class=\"fn\">T</span> <span class=\"fn\">i</span></span></span>)</span></span> <a href=\"./Init/Core.html#Iff\">↔</a>   <span class=\"fn\">∀ (<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Basic.html#Finset\">Finset</a> <span class=\"fn\">ι</span></span>), <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable\">FirstOrder.Language.Theory.IsSatisfiable</a> <span class=\"fn\">(<span class=\"fn\">⋃ i ∈ <span class=\"fn\">s</span>, <span class=\"fn\"><span class=\"fn\">T</span> <span class=\"fn\">i</span></span></span>)</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L174-L186","name":"FirstOrder.Language.Theory.exists_large_model_of_infinite_model","line":174,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.exists_large_model_of_infinite_model","doc":"Any theory with an infinite model has arbitrarily large models. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.exists_large_model_of_infinite_model\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">exists_large_model_of_infinite_model</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(κ : <a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal\">Cardinal.{w}</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(M : <a href=\"./foundational_types.html\">Type</a> w')</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language.Structure\">FirstOrder.Language.Structure</a> <span class=\"fn\">L</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">M</span> <a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.Theory.Model\">⊨</a> <span class=\"fn\">T</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Data/Finite/Defs.html#Infinite\">Infinite</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∃ (N : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Bundled.html#FirstOrder.Language.Theory.ModelType\">FirstOrder.Language.Theory.ModelType</a> <span class=\"fn\">T</span></span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{max u v w, w}</a>           <span class=\"fn\">κ</span></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk\">Cardinal.mk</a> <span class=\"fn\">↑<span class=\"fn\">N</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L157-L170","name":"FirstOrder.Language.Theory.isSatisfiable_union_distinctConstantsTheory_of_infinite","line":157,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.isSatisfiable_union_distinctConstantsTheory_of_infinite","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.isSatisfiable_union_distinctConstantsTheory_of_infinite\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">isSatisfiable_union_distinctConstantsTheory_of_infinite</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Mathlib/Init/Set.html#Set\">Set</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(M : <a href=\"./foundational_types.html\">Type</a> w')</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language.Structure\">FirstOrder.Language.Structure</a> <span class=\"fn\">L</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">M</span> <a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.Theory.Model\">⊨</a> <span class=\"fn\">T</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Data/Finite/Defs.html#Infinite\">Infinite</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable\">FirstOrder.Language.Theory.IsSatisfiable</a>\n  <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.LHom.onTheory\">FirstOrder.Language.LHom.onTheory</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/LanguageMap.html#FirstOrder.Language.lhomWithConstants\">FirstOrder.Language.lhomWithConstants</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span></span>)</span> <span class=\"fn\">T</span></span> <a href=\"./Std/Classes/SetNotation.html#Union.union\">∪</a>     <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.distinctConstantsTheory\">FirstOrder.Language.distinctConstantsTheory</a> <span class=\"fn\">L</span> <span class=\"fn\">s</span></span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L138-L154","name":"FirstOrder.Language.Theory.isSatisfiable_union_distinctConstantsTheory_of_card_le","line":138,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.isSatisfiable_union_distinctConstantsTheory_of_card_le","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.isSatisfiable_union_distinctConstantsTheory_of_card_le\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">isSatisfiable_union_distinctConstantsTheory_of_card_le</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> w}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Mathlib/Init/Set.html#Set\">Set</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(M : <a href=\"./foundational_types.html\">Type</a> w')</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language.Structure\">FirstOrder.Language.Structure</a> <span class=\"fn\">L</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">M</span> <a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.Theory.Model\">⊨</a> <span class=\"fn\">T</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{w', w}</a>    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk\">Cardinal.mk</a> <span class=\"fn\">↑<span class=\"fn\">s</span></span></span>)</span></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.lift\">Cardinal.lift.{w, w'}</a>     <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/SetTheory/Cardinal/Basic.html#Cardinal.mk\">Cardinal.mk</a> <span class=\"fn\">M</span></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable\">FirstOrder.Language.Theory.IsSatisfiable</a>\n  <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.LHom.onTheory\">FirstOrder.Language.LHom.onTheory</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/LanguageMap.html#FirstOrder.Language.lhomWithConstants\">FirstOrder.Language.lhomWithConstants</a> <span class=\"fn\">L</span> <span class=\"fn\">α</span></span>)</span> <span class=\"fn\">T</span></span> <a href=\"./Std/Classes/SetNotation.html#Union.union\">∪</a>     <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.distinctConstantsTheory\">FirstOrder.Language.distinctConstantsTheory</a> <span class=\"fn\">L</span> <span class=\"fn\">s</span></span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L129-L135","name":"FirstOrder.Language.Theory.isSatisfiable_directed_union_iff","line":129,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.isSatisfiable_directed_union_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.isSatisfiable_directed_union_iff\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">isSatisfiable_directed_union_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ι : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">ι</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><span class=\"fn\">ι</span> → <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/Order/Directed.html#Directed\">Directed</a> <span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Std/Classes/SetNotation.html#HasSubset.Subset\">⊆</a> <span class=\"fn\">x_1</span></span></span>)</span> <span class=\"fn\">T</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable\">FirstOrder.Language.Theory.IsSatisfiable</a> <span class=\"fn\">(<span class=\"fn\">⋃ (i : <span class=\"fn\">ι</span>), <span class=\"fn\"><span class=\"fn\">T</span> <span class=\"fn\">i</span></span></span>)</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∀ (<span class=\"fn\">i</span> : <span class=\"fn\">ι</span>), <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable\">FirstOrder.Language.Theory.IsSatisfiable</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">T</span> <span class=\"fn\">i</span></span>)</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L107-L126","name":"FirstOrder.Language.Theory.isSatisfiable_iff_isFinitelySatisfiable","line":107,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.isSatisfiable_iff_isFinitelySatisfiable","doc":"The **Compactness Theorem of first-order logic**: A theory is satisfiable if and only if it is\nfinitely satisfiable. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.isSatisfiable_iff_isFinitelySatisfiable\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">isSatisfiable_iff_isFinitelySatisfiable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable\">FirstOrder.Language.Theory.IsSatisfiable</a> <span class=\"fn\">T</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsFinitelySatisfiable\">FirstOrder.Language.Theory.IsFinitelySatisfiable</a> <span class=\"fn\">T</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L101-L102","name":"FirstOrder.Language.Theory.IsSatisfiable.isFinitelySatisfiable","line":101,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable.isFinitelySatisfiable","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable.isFinitelySatisfiable\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">IsSatisfiable</span>.<span class=\"name\">isFinitelySatisfiable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable\">FirstOrder.Language.Theory.IsSatisfiable</a> <span class=\"fn\">T</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsFinitelySatisfiable\">FirstOrder.Language.Theory.IsFinitelySatisfiable</a> <span class=\"fn\">T</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L93-L98","name":"FirstOrder.Language.Theory.isSatisfiable_onTheory_iff","line":93,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.isSatisfiable_onTheory_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.isSatisfiable_onTheory_iff\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">isSatisfiable_onTheory_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L' : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{φ : <span class=\"fn\"><span class=\"fn\">L</span> <a href=\"./Mathlib/ModelTheory/LanguageMap.html#FirstOrder.Language.LHom\">→ᴸ</a> <span class=\"fn\">L'</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/LanguageMap.html#FirstOrder.Language.LHom.Injective\">FirstOrder.Language.LHom.Injective</a> <span class=\"fn\">φ</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable\">FirstOrder.Language.Theory.IsSatisfiable</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.LHom.onTheory\">FirstOrder.Language.LHom.onTheory</a> <span class=\"fn\">φ</span> <span class=\"fn\">T</span></span>)</span></span> <a href=\"./Init/Core.html#Iff\">↔</a>   <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable\">FirstOrder.Language.Theory.IsSatisfiable</a> <span class=\"fn\">T</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L88-L90","name":"FirstOrder.Language.Theory.isSatisfiable_of_isSatisfiable_onTheory","line":88,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.isSatisfiable_of_isSatisfiable_onTheory","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.isSatisfiable_of_isSatisfiable_onTheory\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">isSatisfiable_of_isSatisfiable_onTheory</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L' : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(φ : <span class=\"fn\"><span class=\"fn\">L</span> <a href=\"./Mathlib/ModelTheory/LanguageMap.html#FirstOrder.Language.LHom\">→ᴸ</a> <span class=\"fn\">L'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable\">FirstOrder.Language.Theory.IsSatisfiable</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.LHom.onTheory\">FirstOrder.Language.LHom.onTheory</a> <span class=\"fn\">φ</span> <span class=\"fn\">T</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable\">FirstOrder.Language.Theory.IsSatisfiable</a> <span class=\"fn\">T</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L84-L85","name":"FirstOrder.Language.Theory.isSatisfiable_empty","line":84,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.isSatisfiable_empty","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.isSatisfiable_empty\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">isSatisfiable_empty</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable\">FirstOrder.Language.Theory.IsSatisfiable</a> <a href=\"./Init/Core.html#EmptyCollection.emptyCollection\">∅</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L80-L81","name":"FirstOrder.Language.Theory.IsSatisfiable.mono","line":80,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable.mono","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable.mono\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">IsSatisfiable</span>.<span class=\"name\">mono</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T' : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable\">FirstOrder.Language.Theory.IsSatisfiable</a> <span class=\"fn\">T'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hs : <span class=\"fn\"><span class=\"fn\">T</span> <a href=\"./Std/Classes/SetNotation.html#HasSubset.Subset\">⊆</a> <span class=\"fn\">T'</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable\">FirstOrder.Language.Theory.IsSatisfiable</a> <span class=\"fn\">T</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L75-L77","name":"FirstOrder.Language.Theory.Model.isSatisfiable","line":75,"kind":"theorem","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.Model.isSatisfiable","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.Model.isSatisfiable\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">Model</span>.<span class=\"name\">isSatisfiable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(M : <a href=\"./foundational_types.html\">Type</a> w)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language.Structure\">FirstOrder.Language.Structure</a> <span class=\"fn\">L</span> <span class=\"fn\">M</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><span class=\"fn\">M</span> <a href=\"./Mathlib/ModelTheory/Semantics.html#FirstOrder.Language.Theory.Model\">⊨</a> <span class=\"fn\">T</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable\">FirstOrder.Language.Theory.IsSatisfiable</a> <span class=\"fn\">T</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L69-L70","name":"FirstOrder.Language.Theory.IsFinitelySatisfiable","line":69,"kind":"def","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsFinitelySatisfiable","doc":"A theory is finitely satisfiable if all of its finite subtheories are satisfiable. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsFinitelySatisfiable\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">IsFinitelySatisfiable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/ModelTheory/Satisfiability.lean#L64-L65","name":"FirstOrder.Language.Theory.IsSatisfiable","line":64,"kind":"def","docLink":"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable","doc":"A theory is satisfiable if a structure models it. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/ModelTheory/Satisfiability.html#FirstOrder.Language.Theory.IsSatisfiable\"><span class=\"name\">FirstOrder</span>.<span class=\"name\">Language</span>.<span class=\"name\">Theory</span>.<span class=\"name\">IsSatisfiable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{L : <a href=\"./Mathlib/ModelTheory/Basic.html#FirstOrder.Language\">FirstOrder.Language</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(T : <span class=\"fn\"><a href=\"./Mathlib/ModelTheory/Syntax.html#FirstOrder.Language.Theory\">FirstOrder.Language.Theory</a> <span class=\"fn\">L</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"}]}