{"name":"Mathlib.CategoryTheory.DiscreteCategory","instances":[{"typeNames":["Eq"],"name":"CategoryTheory.instDecidableEqDiscrete","className":"Decidable"},{"typeNames":["CategoryTheory.Discrete"],"name":"CategoryTheory.discreteCategory","className":"CategoryTheory.Category"},{"typeNames":["CategoryTheory.Discrete"],"name":"CategoryTheory.Discrete.instInhabitedDiscrete","className":"Inhabited"},{"typeNames":["CategoryTheory.Discrete"],"name":"CategoryTheory.Discrete.instSubsingletonDiscrete","className":"Subsingleton"},{"typeNames":["Quiver.Hom"],"name":"CategoryTheory.Discrete.instSubsingletonDiscreteHom","className":"Subsingleton"},{"typeNames":["CategoryTheory.Discrete"],"name":"CategoryTheory.Discrete.instUniqueDiscrete","className":"Unique"},{"typeNames":[],"name":"CategoryTheory.Discrete.instIsIsoDiscreteDiscreteCategory","className":"CategoryTheory.IsIso"}],"imports":["Init","Mathlib.CategoryTheory.EqToHom","Mathlib.Data.ULift"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L290-L294","name":"CategoryTheory.Discrete.functor_map_id","line":290,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor_map_id","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor_map_id\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">functor_map_id</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> v₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">J</span></span>)</span> <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{j : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">J</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">j</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">j</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.map <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryTheory.CategoryStruct.id</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">F</span>.obj <span class=\"fn\">j</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L279-L283","name":"CategoryTheory.Discrete.opposite","line":279,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.opposite","doc":"A discrete category is equivalent to its opposite category. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.opposite\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">opposite</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>)</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence\">≌</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L278-L278","name":"CategoryTheory.Discrete.opposite_inverse_obj","line":278,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.opposite_inverse_obj","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.opposite_inverse_obj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">opposite_inverse_obj</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∀ (<span class=\"fn\">a</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.opposite\">CategoryTheory.Discrete.opposite</a> <span class=\"fn\">α</span></span>)</span>.inverse</span>.obj <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\">a</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L278-L278","name":"CategoryTheory.Discrete.opposite_functor_obj_as","line":278,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.opposite_functor_obj_as","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.opposite_functor_obj_as\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">opposite_functor_obj_as</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>)</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.opposite\">CategoryTheory.Discrete.opposite</a> <span class=\"fn\">α</span></span>)</span>.functor</span>.obj <span class=\"fn\">X</span></span>)</span>.as</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">X</span>.unop</span>.as</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L262-L266","name":"CategoryTheory.Discrete.equivOfEquivalence","line":262,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivOfEquivalence","doc":"We can convert an equivalence of `discrete` categories to a type-level `Equiv`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivOfEquivalence\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">equivOfEquivalence</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span> <a href=\"./Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence\">≌</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">β</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">α</span> <a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv\">≃</a> <span class=\"fn\">β</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L261-L261","name":"CategoryTheory.Discrete.equivOfEquivalence_symm_apply","line":261,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivOfEquivalence_symm_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivOfEquivalence_symm_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">equivOfEquivalence_symm_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span> <a href=\"./Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence\">≌</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">β</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∀ (<span class=\"fn\">a</span> : <span class=\"fn\">β</span>),\n  <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivOfEquivalence\">CategoryTheory.Discrete.equivOfEquivalence</a> <span class=\"fn\">h</span></span>)</span>.symm</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>     <span class=\"fn\"><a href=\"./Init/Prelude.html#Function.comp\">(<a href=\"./Init/Prelude.html#Function.comp\"><span class=\"fn\">CategoryTheory.Discrete.as</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">h</span>.inverse</span>.obj</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">CategoryTheory.Discrete.mk</span></span></a>)</a> <span class=\"fn\">a</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L261-L261","name":"CategoryTheory.Discrete.equivOfEquivalence_apply","line":261,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivOfEquivalence_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivOfEquivalence_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">equivOfEquivalence_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span> <a href=\"./Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence\">≌</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">β</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∀ (<span class=\"fn\">a</span> : <span class=\"fn\">α</span>),\n  <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivOfEquivalence\">CategoryTheory.Discrete.equivOfEquivalence</a> <span class=\"fn\">h</span></span>)</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>     <span class=\"fn\"><a href=\"./Init/Prelude.html#Function.comp\">(<a href=\"./Init/Prelude.html#Function.comp\"><span class=\"fn\">CategoryTheory.Discrete.as</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">h</span>.functor</span>.obj</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">CategoryTheory.Discrete.mk</span></span></a>)</a> <span class=\"fn\">a</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L251-L257","name":"CategoryTheory.Discrete.equivalence","line":251,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivalence","doc":"We can promote a type-level `Equiv` to\nan equivalence between the corresponding `discrete` categories.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivalence\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">equivalence</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(e : <span class=\"fn\"><span class=\"fn\">I</span> <a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv\">≃</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span> <a href=\"./Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence\">≌</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">J</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L250-L250","name":"CategoryTheory.Discrete.equivalence_counitIso","line":250,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivalence_counitIso","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivalence_counitIso\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">equivalence_counitIso</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(e : <span class=\"fn\"><span class=\"fn\">I</span> <a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv\">≃</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivalence\">CategoryTheory.Discrete.equivalence</a> <span class=\"fn\">e</span></span>)</span>.counitIso</span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natIso\">CategoryTheory.Discrete.natIso</a> <span class=\"fn\">fun (<span class=\"fn\">j</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">J</span></span>) =&gt;\n    <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToIso\">CategoryTheory.eqToIso</a>\n      <span class=\"fn\">(_ :\n        <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp\">CategoryTheory.Functor.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">CategoryTheory.Discrete.mk</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">⇑<span class=\"fn\"><span class=\"fn\">e</span>.symm</span></span></span>)</span></span>)</span>\n                <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">CategoryTheory.Discrete.mk</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">⇑<span class=\"fn\">e</span></span></span>)</span></span>)</span></span>)</span>.obj\n            <span class=\"fn\">j</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>           <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id\">CategoryTheory.Functor.id</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">J</span></span>)</span></span>)</span>.obj <span class=\"fn\">j</span></span></span>)</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L250-L250","name":"CategoryTheory.Discrete.equivalence_unitIso","line":250,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivalence_unitIso","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivalence_unitIso\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">equivalence_unitIso</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(e : <span class=\"fn\"><span class=\"fn\">I</span> <a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv\">≃</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivalence\">CategoryTheory.Discrete.equivalence</a> <span class=\"fn\">e</span></span>)</span>.unitIso</span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natIso\">CategoryTheory.Discrete.natIso</a> <span class=\"fn\">fun (<span class=\"fn\">i</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>) =&gt;\n    <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToIso\">CategoryTheory.eqToIso</a>\n      <span class=\"fn\">(_ :\n        <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id\">CategoryTheory.Functor.id</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>)</span></span>)</span>.obj <span class=\"fn\">i</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>           <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp\">CategoryTheory.Functor.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">CategoryTheory.Discrete.mk</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">⇑<span class=\"fn\">e</span></span></span>)</span></span>)</span>\n                <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">CategoryTheory.Discrete.mk</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">⇑<span class=\"fn\"><span class=\"fn\">e</span>.symm</span></span></span>)</span></span>)</span></span>)</span>.obj\n            <span class=\"fn\">i</span></span></span>)</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L250-L250","name":"CategoryTheory.Discrete.equivalence_functor","line":250,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivalence_functor","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivalence_functor\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">equivalence_functor</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(e : <span class=\"fn\"><span class=\"fn\">I</span> <a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv\">≃</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivalence\">CategoryTheory.Discrete.equivalence</a> <span class=\"fn\">e</span></span>)</span>.functor</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">CategoryTheory.Discrete.mk</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">⇑<span class=\"fn\">e</span></span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L250-L250","name":"CategoryTheory.Discrete.equivalence_inverse","line":250,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivalence_inverse","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivalence_inverse\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">equivalence_inverse</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(e : <span class=\"fn\"><span class=\"fn\">I</span> <a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv\">≃</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.equivalence\">CategoryTheory.Discrete.equivalence</a> <span class=\"fn\">e</span></span>)</span>.inverse</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">CategoryTheory.Discrete.mk</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">⇑<span class=\"fn\"><span class=\"fn\">e</span>.symm</span></span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L242-L244","name":"CategoryTheory.Discrete.compNatIsoDiscrete","line":242,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.compNatIsoDiscrete","doc":"Composing `Discrete.functor F` with another functor `G` amounts to composing `F` with `G.obj` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.compNatIsoDiscrete\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">compNatIsoDiscrete</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{D : <a href=\"./foundational_types.html\">Type</a> u₃}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₃, u₃}</a>     <span class=\"fn\">D</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(G : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">C</span> <span class=\"fn\">D</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp\">CategoryTheory.Functor.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">F</span></span>)</span> <span class=\"fn\">G</span></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">G</span>.obj</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">F</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L236-L237","name":"CategoryTheory.Discrete.natIsoFunctor","line":236,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natIsoFunctor","doc":"Every functor `F` from a discrete category is naturally isomorphic (actually, equal) to\n`Discrete.functor (F.obj)`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natIsoFunctor\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">natIsoFunctor</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">F</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">CategoryTheory.Discrete.mk</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L229-L230","name":"CategoryTheory.Discrete.natIso_app","line":229,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natIso_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natIso_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">natIso_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{G : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj <span class=\"fn\">i</span></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\">G</span>.obj <span class=\"fn\">i</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natIso\">CategoryTheory.Discrete.natIso</a> <span class=\"fn\">f</span></span>)</span>.app <span class=\"fn\">i</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">i</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L219-L225","name":"CategoryTheory.Discrete.natIso","line":219,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natIso","doc":"For functors out of a discrete category,\na natural isomorphism is just a collection of isomorphisms,\nas the naturality squares are trivial.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natIso\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">natIso</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{G : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj <span class=\"fn\">i</span></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\">G</span>.obj <span class=\"fn\">i</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">F</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\">G</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L218-L218","name":"CategoryTheory.Discrete.natIso_hom_app","line":218,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natIso_hom_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natIso_hom_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">natIso_hom_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{G : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj <span class=\"fn\">i</span></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\">G</span>.obj <span class=\"fn\">i</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natIso\">CategoryTheory.Discrete.natIso</a> <span class=\"fn\">f</span></span>)</span>.hom</span>.app <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">X</span></span>)</span>.hom</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L218-L218","name":"CategoryTheory.Discrete.natIso_inv_app","line":218,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natIso_inv_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natIso_inv_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">natIso_inv_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{G : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj <span class=\"fn\">i</span></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><span class=\"fn\">G</span>.obj <span class=\"fn\">i</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natIso\">CategoryTheory.Discrete.natIso</a> <span class=\"fn\">f</span></span>)</span>.inv</span>.app <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">X</span></span>)</span>.inv</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L204-L211","name":"CategoryTheory.Discrete.natTrans","line":204,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natTrans","doc":"For functors out of a discrete category,\na natural transformation is just a collection of maps,\nas the naturality squares are trivial.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natTrans\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">natTrans</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{G : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj <span class=\"fn\">i</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">G</span>.obj <span class=\"fn\">i</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">F</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">G</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L203-L203","name":"CategoryTheory.Discrete.natTrans_app","line":203,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natTrans_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natTrans_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">natTrans_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{F : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{G : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>)</span> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">F</span>.obj <span class=\"fn\">i</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><span class=\"fn\">G</span>.obj <span class=\"fn\">i</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natTrans\">CategoryTheory.Discrete.natTrans</a> <span class=\"fn\">f</span></span>)</span>.app <span class=\"fn\">i</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">i</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L194-L196","name":"CategoryTheory.Discrete.functorComp","line":194,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functorComp","doc":"The discrete functor induced by a composition of maps can be written as a\ncomposition of two discrete functors.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functorComp\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">functorComp</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> u₁'}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">g</span></span>)</span></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp\">CategoryTheory.Functor.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">CategoryTheory.Discrete.mk</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">g</span></span>)</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">f</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L193-L193","name":"CategoryTheory.Discrete.functorComp_inv_app","line":193,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functorComp_inv_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functorComp_inv_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">functorComp_inv_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> u₁'}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functorComp\">CategoryTheory.Discrete.functorComp</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.inv</span>.app <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryTheory.CategoryStruct.id</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">g</span></span>)</span></span>)</span>.obj <span class=\"fn\">X</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L193-L193","name":"CategoryTheory.Discrete.functorComp_hom_app","line":193,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functorComp_hom_app","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functorComp_hom_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">functorComp_hom_app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <a href=\"./foundational_types.html\">Type</a> u₁'}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">J</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functorComp\">CategoryTheory.Discrete.functorComp</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span>.hom</span>.app <span class=\"fn\">X</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryTheory.CategoryStruct.id</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">g</span></span>)</span></span>)</span>.obj <span class=\"fn\">X</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L186-L187","name":"CategoryTheory.Discrete.functor_map","line":186,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor_map","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor_map\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">functor_map</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{i : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">i</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">i</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">F</span></span>)</span>.map <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryTheory.CategoryStruct.id</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">F</span> <span class=\"fn\"><span class=\"fn\">i</span>.as</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L181-L183","name":"CategoryTheory.Discrete.functor_obj","line":181,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor_obj","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor_obj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">functor_obj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\">I</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\">CategoryTheory.Discrete.functor</a> <span class=\"fn\">F</span></span>)</span>.obj <span class=\"fn\">{ <span class=\"fn\">as</span> := <span class=\"fn\">i</span> }</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">F</span> <span class=\"fn\">i</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L172-L177","name":"CategoryTheory.Discrete.functor","line":172,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor","doc":"Any function `I → C` gives a functor `Discrete I ⥤ C`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">functor</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u₂}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v₂, u₂}</a>     <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>)</span> <span class=\"fn\">C</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L165-L166","name":"CategoryTheory.Discrete.instIsIsoDiscreteDiscreteCategory","line":165,"kind":"instance","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.instIsIsoDiscreteDiscreteCategory","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.instIsIsoDiscreteDiscreteCategory\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">instIsIsoDiscreteDiscreteCategory</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{i : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{j : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">I</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">i</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">j</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.IsIso\">CategoryTheory.IsIso</a> <span class=\"fn\">f</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L159-L160","name":"CategoryTheory.Discrete.id_def","line":159,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.id_def","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.id_def\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">id_def</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">{ <span class=\"fn\">down</span> := <span class=\"fn\">{ <span class=\"fn\">down</span> := <span class=\"fn\">(_ : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">X</span>.as</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">X</span>.as</span></span>)</span> }</span> }</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryTheory.CategoryStruct.id</a> <span class=\"fn\">X</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L154-L155","name":"CategoryTheory.Discrete.eqToIso'","line":154,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.eqToIso'","doc":"A variant of `eqToIso` that lifts terms to the discrete category. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.eqToIso'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">eqToIso'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{a : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{b : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">{ <span class=\"fn\">as</span> := <span class=\"fn\">a</span> }</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\">{ <span class=\"fn\">as</span> := <span class=\"fn\">b</span> }</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L149-L150","name":"CategoryTheory.Discrete.eqToHom'","line":149,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.eqToHom'","doc":"A variant of `eqToHom` that lifts terms to the discrete category. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.eqToHom'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">eqToHom'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{a : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{b : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">{ <span class=\"fn\">as</span> := <span class=\"fn\">a</span> }</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">{ <span class=\"fn\">as</span> := <span class=\"fn\">b</span> }</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L144-L145","name":"CategoryTheory.Discrete.eqToIso","line":144,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.eqToIso","doc":"Promote an equation between the wrapped terms in `X Y : Discrete α` to an isomorphism `X ≅ Y`\nin the discrete category. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.eqToIso\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">eqToIso</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">X</span>.as</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">Y</span>.as</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\">Y</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L138-L139","name":"CategoryTheory.Discrete.eqToHom","line":138,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.eqToHom","doc":"Promote an equation between the wrapped terms in `X Y : Discrete α` to a morphism `X ⟶ Y`\nin the discrete category. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.eqToHom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">eqToHom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">X</span>.as</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">Y</span>.as</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L132-L133","name":"CategoryTheory.Discrete.eq_of_hom","line":132,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.eq_of_hom","doc":"Extract the equation from a morphism in a discrete category. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.eq_of_hom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">eq_of_hom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Y : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">X</span>.as</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">Y</span>.as</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L128-L129","name":"CategoryTheory.Discrete.instUniqueDiscrete","line":128,"kind":"instance","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.instUniqueDiscrete","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.instUniqueDiscrete\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">instUniqueDiscrete</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Logic/Unique.html#Unique\">Unique</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Logic/Unique.html#Unique\">Unique</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L118-L119","name":"CategoryTheory.Discrete.discreteCases","line":118,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.discreteCases","doc":"Use:\n```\nattribute [local aesop safe tactic (rule_sets [CategoryTheory])]\n  CategoryTheory.Discrete.discreteCases\n```\nto locally gives `aesop_cat` the ability to call `cases` on\n`Discrete` and `(_ : Discrete _) ⟶ (_ : Discrete _)` hypotheses.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.discreteCases\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">discreteCases</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L105-L106","name":"CategoryTheory.Discrete.tacticDiscrete_cases","line":105,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.tacticDiscrete_cases","doc":"A simple tactic to run `cases` on any `Discrete α` hypotheses. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.tacticDiscrete_cases\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">tacticDiscrete_cases</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L100-L101","name":"CategoryTheory.Discrete.instSubsingletonDiscreteHom","line":100,"kind":"instance","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.instSubsingletonDiscreteHom","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.instSubsingletonDiscreteHom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">instSubsingletonDiscreteHom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#Subsingleton\">Subsingleton</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L97-L98","name":"CategoryTheory.Discrete.instSubsingletonDiscrete","line":97,"kind":"instance","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.instSubsingletonDiscrete","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.instSubsingletonDiscrete\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">instSubsingletonDiscrete</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Core.html#Subsingleton\">Subsingleton</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#Subsingleton\">Subsingleton</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L94-L95","name":"CategoryTheory.Discrete.instInhabitedDiscrete","line":94,"kind":"instance","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.instInhabitedDiscrete","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.instInhabitedDiscrete\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">instInhabitedDiscrete</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L79-L87","name":"CategoryTheory.discreteCategory","line":79,"kind":"instance","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.discreteCategory","doc":"The \"Discrete\" category on a type, whose morphisms are equalities.\n\nBecause we do not allow morphisms in `Prop` (only in `Type`),\nsomewhat annoyingly we have to define `X ⟶ Y` as `ULift (PLift (X = Y))`.\n\nSee <https://stacks.math.columbia.edu/tag/001A>\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.discreteCategory\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">discreteCategory</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory\">CategoryTheory.SmallCategory</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L69-L70","name":"CategoryTheory.instDecidableEqDiscrete","line":69,"kind":"instance","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.instDecidableEqDiscrete","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.instDecidableEqDiscrete\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">instDecidableEqDiscrete</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L62-L66","name":"CategoryTheory.discreteEquiv","line":62,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.discreteEquiv","doc":"`Discrete α` is equivalent to the original type `α`."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.discreteEquiv\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">discreteEquiv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span> <a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv\">≃</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L61-L61","name":"CategoryTheory.discreteEquiv_symm_apply_as","line":61,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.discreteEquiv_symm_apply_as","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.discreteEquiv_symm_apply_as\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">discreteEquiv_symm_apply_as</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(as : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">CategoryTheory.discreteEquiv</span>.symm</span> <span class=\"fn\">as</span></span>)</span>.as</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">as</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L61-L61","name":"CategoryTheory.discreteEquiv_apply","line":61,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.discreteEquiv_apply","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.discreteEquiv_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">discreteEquiv_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(self : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">CategoryTheory.discreteEquiv</span> <span class=\"fn\">self</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">self</span>.as</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L55-L57","name":"CategoryTheory.Discrete.mk_as","line":55,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.mk_as","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.mk_as\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">mk_as</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">{ <span class=\"fn\">as</span> := <span class=\"fn\"><span class=\"fn\">X</span>.as</span> }</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">X</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L51-L51","name":"CategoryTheory.Discrete.as","line":51,"kind":"def","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.as","doc":"A wrapper for promoting any type to a category,\nwith the only morphisms being equalities. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.as\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">as</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(self : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">α</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L48-L48","name":"CategoryTheory.Discrete.mk","line":48,"kind":"ctor","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.mk\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(as : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L48-L51","name":"CategoryTheory.Discrete","line":48,"kind":"structure","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete","doc":"A wrapper for promoting any type to a category,\nwith the only morphisms being equalities.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./foundational_types.html\">Type</a> u₁)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u₁</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L47-L47","name":"CategoryTheory.Discrete.ext","line":47,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.ext","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(y : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(as : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x</span>.as</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">y</span>.as</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/DiscreteCategory.lean#L47-L47","name":"CategoryTheory.Discrete.ext_iff","line":47,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.ext_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.ext_iff\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Discrete</span>.<span class=\"name\">ext_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(y : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete\">CategoryTheory.Discrete</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x</span>.as</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">y</span>.as</span></span></span></div></div>"}]}