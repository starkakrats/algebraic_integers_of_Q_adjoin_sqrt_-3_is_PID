{"name":"Mathlib.CategoryTheory.Sites.Canonical","instances":[],"imports":["Init","Mathlib.CategoryTheory.Sites.SheafOfTypes"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/Canonical.lean#L245-L247","name":"CategoryTheory.Sheaf.Subcanonical.isSheaf_of_representable","line":245,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.Sheaf.Subcanonical.isSheaf_of_representable","doc":"If `J` is subcanonical, then any representable is a `J`-sheaf. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.Sheaf.Subcanonical.isSheaf_of_representable\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Sheaf</span>.<span class=\"name\">Subcanonical</span>.<span class=\"name\">isSheaf_of_representable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{J : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology\">CategoryTheory.GrothendieckTopology</a> <span class=\"fn\">C</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(hJ : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.Sheaf.Subcanonical\">CategoryTheory.Sheaf.Subcanonical</a> <span class=\"fn\">J</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> v)</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.Functor.Representable\">CategoryTheory.Functor.Representable</a> <span class=\"fn\">P</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.IsSheaf\">CategoryTheory.Presieve.IsSheaf</a> <span class=\"fn\">J</span> <span class=\"fn\">P</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/Canonical.lean#L236-L241","name":"CategoryTheory.Sheaf.Subcanonical.of_yoneda_isSheaf","line":236,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.Sheaf.Subcanonical.of_yoneda_isSheaf","doc":"If every functor `yoneda.obj X` is a `J`-sheaf, then `J` is subcanonical. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.Sheaf.Subcanonical.of_yoneda_isSheaf\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Sheaf</span>.<span class=\"name\">Subcanonical</span>.<span class=\"name\">of_yoneda_isSheaf</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(J : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology\">CategoryTheory.GrothendieckTopology</a> <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">X</span> : <span class=\"fn\">C</span>), <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.IsSheaf\">CategoryTheory.Presieve.IsSheaf</a> <span class=\"fn\">J</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">CategoryTheory.yoneda</span>.obj <span class=\"fn\">X</span></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.Sheaf.Subcanonical\">CategoryTheory.Sheaf.Subcanonical</a> <span class=\"fn\">J</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/Canonical.lean#L229-L230","name":"CategoryTheory.Sheaf.Subcanonical","line":229,"kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.Sheaf.Subcanonical","doc":"A subcanonical topology is a topology which is smaller than the canonical topology.\nEquivalently, a topology is subcanonical iff every representable is a sheaf.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.Sheaf.Subcanonical\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Sheaf</span>.<span class=\"name\">Subcanonical</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(J : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology\">CategoryTheory.GrothendieckTopology</a> <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/Canonical.lean#L221-L223","name":"CategoryTheory.Sheaf.isSheaf_of_representable","line":221,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.Sheaf.isSheaf_of_representable","doc":"A representable functor is a sheaf for the canonical topology. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.Sheaf.isSheaf_of_representable\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Sheaf</span>.<span class=\"name\">isSheaf_of_representable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> v)</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Yoneda.html#CategoryTheory.Functor.Representable\">CategoryTheory.Functor.Representable</a> <span class=\"fn\">P</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.IsSheaf\">CategoryTheory.Presieve.IsSheaf</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.Sheaf.canonicalTopology\">CategoryTheory.Sheaf.canonicalTopology</a> <span class=\"fn\">C</span></span>)</span> <span class=\"fn\">P</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/Canonical.lean#L216-L217","name":"CategoryTheory.Sheaf.isSheaf_yoneda_obj","line":216,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.Sheaf.isSheaf_yoneda_obj","doc":"`yoneda.obj X` is a sheaf for the canonical topology. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.Sheaf.isSheaf_yoneda_obj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Sheaf</span>.<span class=\"name\">isSheaf_yoneda_obj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.IsSheaf\">CategoryTheory.Presieve.IsSheaf</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.Sheaf.canonicalTopology\">CategoryTheory.Sheaf.canonicalTopology</a> <span class=\"fn\">C</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">CategoryTheory.yoneda</span>.obj <span class=\"fn\">X</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/Canonical.lean#L211-L212","name":"CategoryTheory.Sheaf.canonicalTopology","line":211,"kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.Sheaf.canonicalTopology","doc":"The `canonicalTopology` on a category is the finest (largest) topology for which every\nrepresentable presheaf is a sheaf.\n\nSee <https://stacks.math.columbia.edu/tag/00ZA>\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.Sheaf.canonicalTopology\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Sheaf</span>.<span class=\"name\">canonicalTopology</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(C : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology\">CategoryTheory.GrothendieckTopology</a> <span class=\"fn\">C</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/Canonical.lean#L198-L203","name":"CategoryTheory.Sheaf.le_finestTopology","line":198,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.Sheaf.le_finestTopology","doc":"Check that if each `P ∈ Ps` is a sheaf for `J`, then `J` is a subtopology of `finestTopology Ps`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.Sheaf.le_finestTopology\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Sheaf</span>.<span class=\"name\">le_finestTopology</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(Ps : <span class=\"fn\"><a href=\"./Mathlib/Init/Set.html#Set\">Set</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> v)</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(J : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology\">CategoryTheory.GrothendieckTopology</a> <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hJ : <span class=\"fn\">∀ <span class=\"fn\">P</span> ∈ <span class=\"fn\">Ps</span>, <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.IsSheaf\">CategoryTheory.Presieve.IsSheaf</a> <span class=\"fn\">J</span> <span class=\"fn\">P</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">J</span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.Sheaf.finestTopology\">CategoryTheory.Sheaf.finestTopology</a> <span class=\"fn\">Ps</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/Canonical.lean#L190-L192","name":"CategoryTheory.Sheaf.sheaf_for_finestTopology","line":190,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.Sheaf.sheaf_for_finestTopology","doc":"Check that if `P ∈ Ps`, then `P` is indeed a sheaf for the finest topology on `Ps`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.Sheaf.sheaf_for_finestTopology\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Sheaf</span>.<span class=\"name\">sheaf_for_finestTopology</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> v)</a></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(Ps : <span class=\"fn\"><a href=\"./Mathlib/Init/Set.html#Set\">Set</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> v)</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">Ps</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.IsSheaf\">CategoryTheory.Presieve.IsSheaf</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.Sheaf.finestTopology\">CategoryTheory.Sheaf.finestTopology</a> <span class=\"fn\">Ps</span></span>)</span> <span class=\"fn\">P</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/Canonical.lean#L185-L186","name":"CategoryTheory.Sheaf.finestTopology","line":185,"kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.Sheaf.finestTopology","doc":"Construct the finest (largest) Grothendieck topology for which all the given presheaves are sheaves.\n\nThis is equal to the construction of <https://stacks.math.columbia.edu/tag/00Z9>.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.Sheaf.finestTopology\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Sheaf</span>.<span class=\"name\">finestTopology</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(Ps : <span class=\"fn\"><a href=\"./Mathlib/Init/Set.html#Set\">Set</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> v)</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology\">CategoryTheory.GrothendieckTopology</a> <span class=\"fn\">C</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/Canonical.lean#L159-L177","name":"CategoryTheory.Sheaf.finestTopologySingle","line":159,"kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.Sheaf.finestTopologySingle","doc":"Construct the finest (largest) Grothendieck topology for which the given presheaf is a sheaf.\n\nThis is a special case of https://stacks.math.columbia.edu/tag/00Z9, but following a different\nproof (see the comments there).\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.Sheaf.finestTopologySingle\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Sheaf</span>.<span class=\"name\">finestTopologySingle</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> v)</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology\">CategoryTheory.GrothendieckTopology</a> <span class=\"fn\">C</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/Canonical.lean#L126-L151","name":"CategoryTheory.Sheaf.isSheafFor_trans","line":126,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.Sheaf.isSheafFor_trans","doc":"Given two sieves `R` and `S`, to show that `P` is a sheaf for `S`, we can show:\n* `P` is a sheaf for `R`\n* `P` is a sheaf for the pullback of `S` along any arrow in `R`\n* `P` is separated for the pullback of `R` along any arrow in `S`.\n\nThis is mostly an auxiliary lemma to construct `finestTopology`.\nAdapted from [Elephant], Lemma C2.1.7(ii) with suggestions as mentioned in\nhttps://math.stackexchange.com/a/358709\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.Sheaf.isSheafFor_trans\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Sheaf</span>.<span class=\"name\">isSheafFor_trans</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> v)</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(R : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve\">CategoryTheory.Sieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(S : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve\">CategoryTheory.Sieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hR : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.IsSheafFor\">CategoryTheory.Presieve.IsSheafFor</a> <span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">R</span>.arrows</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hR' : <span class=\"fn\">∀ ⦃<span class=\"fn\">Y</span> : <span class=\"fn\">C</span>⦄ ⦃<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>⦄, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">S</span>.arrows <span class=\"fn\">f</span></span> → <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.IsSeparatedFor\">CategoryTheory.Presieve.IsSeparatedFor</a> <span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.pullback\">CategoryTheory.Sieve.pullback</a> <span class=\"fn\">f</span> <span class=\"fn\">R</span></span>)</span>.arrows</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hS : <span class=\"fn\">∀ ⦃<span class=\"fn\">Y</span> : <span class=\"fn\">C</span>⦄ ⦃<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>⦄, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">R</span>.arrows <span class=\"fn\">f</span></span> → <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.IsSheafFor\">CategoryTheory.Presieve.IsSheafFor</a> <span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.pullback\">CategoryTheory.Sieve.pullback</a> <span class=\"fn\">f</span> <span class=\"fn\">S</span></span>)</span>.arrows</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.IsSheafFor\">CategoryTheory.Presieve.IsSheafFor</a> <span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">S</span>.arrows</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/Canonical.lean#L62-L114","name":"CategoryTheory.Sheaf.isSheafFor_bind","line":62,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.Sheaf.isSheafFor_bind","doc":"To show `P` is a sheaf for the binding of `U` with `B`, it suffices to show that `P` is a sheaf for\n`U`, that `P` is a sheaf for each sieve in `B`, and that it is separated for any pullback of any\nsieve in `B`.\n\nThis is mostly an auxiliary lemma to show `isSheafFor_trans`.\nAdapted from [Elephant], Lemma C2.1.7(i) with suggestions as mentioned in\nhttps://math.stackexchange.com/a/358709/\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.Sheaf.isSheafFor_bind\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Sheaf</span>.<span class=\"name\">isSheafFor_bind</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> v)</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(U : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve\">CategoryTheory.Sieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(B : <span class=\"fn\">⦃<span class=\"fn\">Y</span> : <span class=\"fn\">C</span>⦄ → <span class=\"fn\">⦃<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>⦄ → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">U</span>.arrows <span class=\"fn\">f</span></span> → <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve\">CategoryTheory.Sieve</a> <span class=\"fn\">Y</span></span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hU : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.IsSheafFor\">CategoryTheory.Presieve.IsSheafFor</a> <span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">U</span>.arrows</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hB : <span class=\"fn\">∀ ⦃<span class=\"fn\">Y</span> : <span class=\"fn\">C</span>⦄ ⦃<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>⦄ (<span class=\"fn\">hf</span> : <span class=\"fn\"><span class=\"fn\">U</span>.arrows <span class=\"fn\">f</span></span>), <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.IsSheafFor\">CategoryTheory.Presieve.IsSheafFor</a> <span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">B</span> <span class=\"fn\">hf</span></span>)</span>.arrows</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hB' : <span class=\"fn\">∀ ⦃<span class=\"fn\">Y</span> : <span class=\"fn\">C</span>⦄ ⦃<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>⦄ (<span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">U</span>.arrows <span class=\"fn\">f</span></span>) ⦃<span class=\"fn\">Z</span> : <span class=\"fn\">C</span>⦄ (<span class=\"fn\">g</span> : <span class=\"fn\"><span class=\"fn\">Z</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>),\n  <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.IsSeparatedFor\">CategoryTheory.Presieve.IsSeparatedFor</a> <span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.pullback\">CategoryTheory.Sieve.pullback</a> <span class=\"fn\">g</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">B</span> <span class=\"fn\">h</span></span>)</span></span>)</span>.arrows</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.IsSheafFor\">CategoryTheory.Presieve.IsSheafFor</a> <span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.bind\">CategoryTheory.Sieve.bind</a> <span class=\"fn\"><span class=\"fn\">U</span>.arrows</span> <span class=\"fn\">B</span></span>)</span>.arrows</span></span></div></div>"}]}