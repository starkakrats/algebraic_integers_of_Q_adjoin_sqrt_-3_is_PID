{"name":"Std.Tactic.Omega.Frontend","instances":[{"typeNames":["Std.Tactic.Omega.MetaProblem"],"name":"Std.Tactic.Omega.MetaProblem.instInhabitedMetaProblem","className":"Inhabited"}],"imports":["Init","Std.Tactic.Omega.Core","Std.Tactic.Omega.LinearCombo","Std.Tactic.Omega.Logic","Std.Tactic.Omega.Int","Std.Tactic.FalseOrByContra","Std.Lean.Meta.Basic","Std.Lean.Elab.Tactic"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Frontend.lean#L497-L526","name":"Std.Tactic.Omega.omegaSyntax","line":497,"kind":"def","docLink":"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.omegaSyntax","doc":"The `omega` tactic, for resolving integer and natural linear arithmetic problems.\n\nIt is not yet a full decision procedure (no \"dark\" or \"grey\" shadows),\nbut should be effective on many problems.\n\nWe handle hypotheses of the form `x = y`, `x < y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`\n(and `k` a literal), along with negations of these statements.\n\nWe decompose the sides of the inequalities as linear combinations of atoms.\n\nIf we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables\nand the relevant inequalities.\n\nOn the first pass, we do not perform case splits on natural subtraction.\nIf `omega` fails, we recursively perform a case split on\na natural subtraction appearing in a hypothesis, and try again.\n\nThe options\n```\nomega (config := { splitDisjunctions := true, splitNatSub := true, splitNatAbs := true})\n```\ncan be used to:\n* `splitDisjunctions`: split any disjunctions found in the context,\n  if the problem is not otherwise solvable.\n* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.\n* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.\nCurrently, all of these are on by default.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.omegaSyntax\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">omegaSyntax</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Frontend.lean#L495-L495","name":"Std.Tactic.Omega.omegaDefault","line":495,"kind":"def","docLink":"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.omegaDefault","doc":"The `omega` tactic, for resolving integer and natural linear arithmetic problems. This\n`TacticM Unit` frontend with default configuration can be used as an Aesop rule, for example via\nthe tactic call `aesop (add 50% tactic Std.Tactic.Omega.omegaDefault)`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.omegaDefault\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">omegaDefault</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Frontend.lean#L483-L490","name":"Std.Tactic.Omega.omegaTactic","line":483,"kind":"def","docLink":"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.omegaTactic","doc":"The `omega` tactic, for resolving integer and natural linear arithmetic problems. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.omegaTactic\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">omegaTactic</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Std/Tactic/Omega/Config.html#Std.Tactic.Omega.OmegaConfig\">Std.Tactic.Omega.OmegaConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Frontend.lean#L477-L478","name":"Std.Tactic.Omega.omega","line":477,"kind":"def","docLink":"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.omega","doc":"Given a collection of facts, try prove `False` using the omega algorithm,\nand close the goal using that.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.omega\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">omega</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(facts : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(cfg : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Std/Tactic/Omega/Config.html#Std.Tactic.Omega.OmegaConfig\">Std.Tactic.Omega.OmegaConfig</a> <span class=\"fn\">{ <span class=\"fn\">splitDisjunctions</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">splitNatSub</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">splitNatAbs</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Frontend.lean#L454-L469","name":"Std.Tactic.Omega.omegaImpl","line":454,"kind":"opaque","docLink":"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.omegaImpl","doc":"Implementation of the `omega` algorithm, and handling disjunctions. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.omegaImpl\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">omegaImpl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(m : <a href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem\">Std.Tactic.Omega.MetaProblem</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/OmegaM.html#Std.Tactic.Omega.OmegaM\">Std.Tactic.Omega.OmegaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Frontend.lean#L428-L451","name":"Std.Tactic.Omega.splitDisjunction","line":428,"kind":"opaque","docLink":"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.splitDisjunction","doc":"Split a disjunction in a `MetaProblem`, and if we find a new usable fact\ncall `omegaImpl` in both branches.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.splitDisjunction\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">splitDisjunction</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(m : <a href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem\">Std.Tactic.Omega.MetaProblem</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/OmegaM.html#Std.Tactic.Omega.OmegaM\">Std.Tactic.Omega.OmegaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Frontend.lean#L409-L419","name":"Std.Tactic.Omega.cases₂","line":409,"kind":"def","docLink":"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.cases₂","doc":"Given `p : P ∨ Q` (or any inductive type with two one-argument constructors),\nsplit the goal into two subgoals:\none containing the hypothesis `h : P` and another containing `h : Q`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.cases₂\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">cases₂</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(mvarId : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hName : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> <span class=\"fn\">`h</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span>)</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Frontend.lean#L389-L400","name":"Std.Tactic.Omega.MetaProblem.processFacts","line":389,"kind":"opaque","docLink":"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem.processFacts","doc":"Process all the facts in a `MetaProblem`, returning the new problem, and the number of new facts.\n\nThis is partial because new facts may be generated along the way.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem.processFacts\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">MetaProblem</span>.<span class=\"name\">processFacts</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem\">Std.Tactic.Omega.MetaProblem</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/OmegaM.html#Std.Tactic.Omega.OmegaM\">Std.Tactic.Omega.OmegaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem\">Std.Tactic.Omega.MetaProblem</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Frontend.lean#L314-L382","name":"Std.Tactic.Omega.MetaProblem.addFact","line":314,"kind":"opaque","docLink":"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem.addFact","doc":"Parse an `Expr` and extract facts, also returning the number of new facts found.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem.addFact\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">MetaProblem</span>.<span class=\"name\">addFact</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem\">Std.Tactic.Omega.MetaProblem</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/OmegaM.html#Std.Tactic.Omega.OmegaM\">Std.Tactic.Omega.OmegaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem\">Std.Tactic.Omega.MetaProblem</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Frontend.lean#L267-L309","name":"Std.Tactic.Omega.MetaProblem.pushNot","line":267,"kind":"def","docLink":"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem.pushNot","doc":"Given a fact `h` with type `¬ P`, return a more useful fact obtained by pushing the negation. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem.pushNot\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">MetaProblem</span>.<span class=\"name\">pushNot</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(h : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(P : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Frontend.lean#L255-L264","name":"Std.Tactic.Omega.MetaProblem.addIntInequality","line":255,"kind":"def","docLink":"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem.addIntInequality","doc":"Add an integer inequality to the `Problem`.\n\nWe solve equalities as they are discovered, as this often results in an earlier contradiction.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem.addIntInequality\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">MetaProblem</span>.<span class=\"name\">addIntInequality</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem\">Std.Tactic.Omega.MetaProblem</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(y : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/OmegaM.html#Std.Tactic.Omega.OmegaM\">Std.Tactic.Omega.OmegaM</a> <a href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem\">Std.Tactic.Omega.MetaProblem</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Frontend.lean#L239-L248","name":"Std.Tactic.Omega.MetaProblem.addIntEquality","line":239,"kind":"def","docLink":"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem.addIntEquality","doc":"Add an integer equality to the `Problem`.\n\nWe solve equalities as they are discovered, as this often results in an earlier contradiction.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem.addIntEquality\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">MetaProblem</span>.<span class=\"name\">addIntEquality</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem\">Std.Tactic.Omega.MetaProblem</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/OmegaM.html#Std.Tactic.Omega.OmegaM\">Std.Tactic.Omega.OmegaM</a> <a href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem\">Std.Tactic.Omega.MetaProblem</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Frontend.lean#L232-L232","name":"Std.Tactic.Omega.MetaProblem.instInhabitedMetaProblem","line":232,"kind":"instance","docLink":"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem.instInhabitedMetaProblem","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem.instInhabitedMetaProblem\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">MetaProblem</span>.<span class=\"name\">instInhabitedMetaProblem</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem\">Std.Tactic.Omega.MetaProblem</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Frontend.lean#L229-L230","name":"Std.Tactic.Omega.MetaProblem.trivial","line":229,"kind":"def","docLink":"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem.trivial","doc":"The trivial `MetaProblem`, with no facts to processs and a trivial `Problem`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem.trivial\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">MetaProblem</span>.<span class=\"name\">trivial</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem\">Std.Tactic.Omega.MetaProblem</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Frontend.lean#L216-L223","name":"Std.Tactic.Omega.asLinearComboImpl.rewrite","line":216,"kind":"opaque","docLink":"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.asLinearComboImpl.rewrite","doc":"Apply a rewrite rule to an expression, and interpret the result as a `LinearCombo`.\n(We're not rewriting any subexpressions here, just the top level, for efficiency.)\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.asLinearComboImpl.rewrite\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">asLinearComboImpl</span>.<span class=\"name\">rewrite</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(lhs : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(rw : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/OmegaM.html#Std.Tactic.Omega.OmegaM\">Std.Tactic.Omega.OmegaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/LinearCombo.html#Std.Tactic.Omega.LinearCombo\">Std.Tactic.Omega.LinearCombo</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/OmegaM.html#Std.Tactic.Omega.OmegaM\">Std.Tactic.Omega.OmegaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Lean/Data/HashSet.html#Lean.HashSet\">Lean.HashSet</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Frontend.lean#L123-L223","name":"Std.Tactic.Omega.asLinearComboImpl","line":123,"kind":"opaque","docLink":"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.asLinearComboImpl","doc":"Translates an expression into a `LinearCombo`.\nAlso returns:\n* a proof that this linear combo evaluated at the atoms is equal to the original expression\n* a list of new facts which should be recorded:\n  * for each new atom `a` of the form `((x : Nat) : Int)`, the fact that `0 ≤ a`\n  * for each new atom `a` of the form `x / k`, for `k` a positive numeral, the facts that\n    `k * a ≤ x < (k + 1) * a`\n  * for each new atom of the form `((a - b : Nat) : Int)`, the fact:\n    `b ≤ a ∧ ((a - b : Nat) : Int) = a - b ∨ a < b ∧ ((a - b : Nat) : Int) = 0`\n\nWe also transform the expression as we descend into it:\n* pushing coercions: `↑(x + y)`, `↑(x * y)`, `↑(x / k)`, `↑(x % k)`, `↑k`\n* unfolding `emod`: `x % k` → `x - x / k`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.asLinearComboImpl\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">asLinearComboImpl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/OmegaM.html#Std.Tactic.Omega.OmegaM\">Std.Tactic.Omega.OmegaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/LinearCombo.html#Std.Tactic.Omega.LinearCombo\">Std.Tactic.Omega.LinearCombo</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/OmegaM.html#Std.Tactic.Omega.OmegaM\">Std.Tactic.Omega.OmegaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Lean/Data/HashSet.html#Lean.HashSet\">Lean.HashSet</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Frontend.lean#L97-L106","name":"Std.Tactic.Omega.asLinearCombo","line":97,"kind":"opaque","docLink":"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.asLinearCombo","doc":"Wrapper for `asLinearComboImpl`,\nusing a cache for previously visited expressions.\n\nGives a small (10%) speedup in testing.\nI tried using a pointer based cache,\nbut there was never enough subexpression sharing to make it effective.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.asLinearCombo\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">asLinearCombo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/OmegaM.html#Std.Tactic.Omega.OmegaM\">Std.Tactic.Omega.OmegaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/LinearCombo.html#Std.Tactic.Omega.LinearCombo\">Std.Tactic.Omega.LinearCombo</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/OmegaM.html#Std.Tactic.Omega.OmegaM\">Std.Tactic.Omega.OmegaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Lean/Data/HashSet.html#Lean.HashSet\">Lean.HashSet</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Frontend.lean#L76-L78","name":"Std.Tactic.Omega.mkAtomLinearCombo","line":76,"kind":"def","docLink":"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.mkAtomLinearCombo","doc":"Construct the linear combination (and its associated proof and new facts) for an atom. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.mkAtomLinearCombo\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">mkAtomLinearCombo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/OmegaM.html#Std.Tactic.Omega.OmegaM\">Std.Tactic.Omega.OmegaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/LinearCombo.html#Std.Tactic.Omega.LinearCombo\">Std.Tactic.Omega.LinearCombo</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/OmegaM.html#Std.Tactic.Omega.OmegaM\">Std.Tactic.Omega.OmegaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Lean/Data/HashSet.html#Lean.HashSet\">Lean.HashSet</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Frontend.lean#L62-L73","name":"Std.Tactic.Omega.mkCoordinateEvalAtomsEq","line":62,"kind":"def","docLink":"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.mkCoordinateEvalAtomsEq","doc":"If `e : Expr` is the `n`-th atom, construct the proof that\n`e = (coordinate n).eval atoms`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.mkCoordinateEvalAtomsEq\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">mkCoordinateEvalAtomsEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/OmegaM.html#Std.Tactic.Omega.OmegaM\">Std.Tactic.Omega.OmegaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Frontend.lean#L57-L58","name":"Std.Tactic.Omega.mkEvalRflProof","line":57,"kind":"def","docLink":"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.mkEvalRflProof","doc":"Construct the `rfl` proof that `lc.eval atoms = e`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.mkEvalRflProof\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">mkEvalRflProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(lc : <a href=\"./Std/Tactic/Omega/LinearCombo.html#Std.Tactic.Omega.LinearCombo\">Std.Tactic.Omega.LinearCombo</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/OmegaM.html#Std.Tactic.Omega.OmegaM\">Std.Tactic.Omega.OmegaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Frontend.lean#L53-L54","name":"Std.Tactic.Omega.mkEqReflWithExpectedType","line":53,"kind":"def","docLink":"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.mkEqReflWithExpectedType","doc":"Construct the term with type hint `(Eq.refl a : a = b)`"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.mkEqReflWithExpectedType\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">mkEqReflWithExpectedType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(a : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Frontend.lean#L50-L50","name":"Std.Tactic.Omega.MetaProblem.processedFacts","line":50,"kind":"def","docLink":"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem.processedFacts","doc":"Facts which have already been processed; we keep these to avoid duplicates. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem.processedFacts\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">MetaProblem</span>.<span class=\"name\">processedFacts</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem\">Std.Tactic.Omega.MetaProblem</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/HashSet.html#Lean.HashSet\">Lean.HashSet</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Frontend.lean#L48-L48","name":"Std.Tactic.Omega.MetaProblem.disjunctions","line":48,"kind":"def","docLink":"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem.disjunctions","doc":"Pending disjunctions, which we will case split one at a time if we can't get a contradiction.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem.disjunctions\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">MetaProblem</span>.<span class=\"name\">disjunctions</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem\">Std.Tactic.Omega.MetaProblem</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Frontend.lean#L44-L44","name":"Std.Tactic.Omega.MetaProblem.facts","line":44,"kind":"def","docLink":"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem.facts","doc":"Pending facts which have not been processed yet. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem.facts\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">MetaProblem</span>.<span class=\"name\">facts</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem\">Std.Tactic.Omega.MetaProblem</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Frontend.lean#L42-L42","name":"Std.Tactic.Omega.MetaProblem.problem","line":42,"kind":"def","docLink":"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem.problem","doc":"An integer linear arithmetic problem. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem.problem\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">MetaProblem</span>.<span class=\"name\">problem</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem\">Std.Tactic.Omega.MetaProblem</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Core.html#Std.Tactic.Omega.Problem\">Std.Tactic.Omega.Problem</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Frontend.lean#L40-L40","name":"Std.Tactic.Omega.MetaProblem.mk","line":40,"kind":"ctor","docLink":"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem.mk\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">MetaProblem</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(problem : <a href=\"./Std/Tactic/Omega/Core.html#Std.Tactic.Omega.Problem\">Std.Tactic.Omega.Problem</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(facts : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(disjunctions : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(processedFacts : <span class=\"fn\"><a href=\"./Lean/Data/HashSet.html#Lean.HashSet\">Lean.HashSet</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem\">Std.Tactic.Omega.MetaProblem</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Frontend.lean#L40-L50","name":"Std.Tactic.Omega.MetaProblem","line":40,"kind":"structure","docLink":"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem","doc":"A partially processed `omega` context.\n\nWe have:\n* a `Problem` representing the integer linear constraints extracted so far, and their proofs\n* the unprocessed `facts : List Expr` taken from the local context,\n* the unprocessed `disjunctions : List Expr`,\n  which will only be split one at a time if we can't otherwise find a contradiction.\n\nWe begin with `facts := ← getLocalHyps` and `problem := .trivial`,\nand progressively process the facts.\n\nAs we process the facts, we may generate additional facts\n(e.g. about coercions and integer divisions).\nTo avoid duplicates, we maintain a `HashSet` of previously processed facts.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Frontend.html#Std.Tactic.Omega.MetaProblem\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">MetaProblem</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"}]}