{"name":"Mathlib.Tactic.Convert","instances":[],"imports":["Init","Mathlib.Tactic.Congr!"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Convert.lean#L147-L156","name":"Mathlib.Tactic.acChange","line":147,"kind":"def","docLink":"./Mathlib/Tactic/Convert.html#Mathlib.Tactic.acChange","doc":"`ac_change g using n` is `convert_to g using n` followed by `ac_rfl`. It is useful for\nrearranging/reassociating e.g. sums:\n```lean\nexample (a b c d e f g N : ℕ) : (a + b) + (c + d) + (e + f) + g ≤ N := by\n  ac_change a + d + e + f + c + g + b ≤ _\n  -- ⊢ a + d + e + f + c + g + b ≤ N\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Convert.html#Mathlib.Tactic.acChange\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">acChange</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Convert.lean#L127-L139","name":"Mathlib.Tactic.convertTo","line":127,"kind":"def","docLink":"./Mathlib/Tactic/Convert.html#Mathlib.Tactic.convertTo","doc":"`convert_to g using n` attempts to change the current goal to `g`, but unlike `change`,\nit will generate equality proof obligations using `congr! n` to resolve discrepancies.\n`convert_to g` defaults to using `congr! 1`.\n`convert_to` is similar to `convert`, but `convert_to` takes a type (the desired subgoal) while\n`convert` takes a proof term.\nThat is, `convert_to g using n` is equivalent to `convert (?_ : g) using n`.\n\nThe syntax for `convert_to` is the same as for `convert`, and it has variations such as\n`convert_to ← g` and `convert_to (config := {transparency := .default}) g`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Convert.html#Mathlib.Tactic.convertTo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">convertTo</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Convert.lean#L36-L99","name":"Mathlib.Tactic.convert","line":36,"kind":"def","docLink":"./Mathlib/Tactic/Convert.html#Mathlib.Tactic.convert","doc":"The `exact e` and `refine e` tactics require a term `e` whose type is\ndefinitionally equal to the goal. `convert e` is similar to `refine e`,\nbut the type of `e` is not required to exactly match the\ngoal. Instead, new goals are created for differences between the type\nof `e` and the goal using the same strategies as the `congr!` tactic.\nFor example, in the proof state\n\n```lean\nn : ℕ,\ne : Prime (2 * n + 1)\n⊢ Prime (n + n + 1)\n```\n\nthe tactic `convert e using 2` will change the goal to\n\n```lean\n⊢ n + n = 2 * n\n```\n\nIn this example, the new goal can be solved using `ring`.\n\nThe `using 2` indicates it should iterate the congruence algorithm up to two times,\nwhere `convert e` would use an unrestricted number of iterations and lead to two\nimpossible goals: `⊢ HAdd.hAdd = HMul.hMul` and `⊢ n = 2`.\n\nA variant configuration is `convert (config := .unfoldSameFun) e`, which only equates function\napplications for the same function (while doing so at the higher `default` transparency).\nThis gives the same goal of `⊢ n + n = 2 * n` without needing `using 2`.\n\nThe `convert` tactic applies congruence lemmas eagerly before reducing,\ntherefore it can fail in cases where `exact` succeeds:\n```lean\ndef p (n : ℕ) := True\nexample (h : p 0) : p 1 := by exact h -- succeeds\nexample (h : p 0) : p 1 := by convert h -- fails, with leftover goal `1 = 0`\n```\nLimiting the depth of recursion can help with this. For example, `convert h using 1` will work\nin this case.\n\nThe syntax `convert ← e` will reverse the direction of the new goals\n(producing `⊢ 2 * n = n + n` in this example).\n\nInternally, `convert e` works by creating a new goal asserting that\nthe goal equals the type of `e`, then simplifying it using\n`congr!`. The syntax `convert e using n` can be used to control the\ndepth of matching (like `congr! n`). In the example, `convert e using 1`\nwould produce a new goal `⊢ n + n + 1 = 2 * n + 1`.\n\nRefer to the `congr!` tactic to understand the congruence operations. One of its many\nfeatures is that if `x y : t` and an instance `Subsingleton t` is in scope,\nthen any goals of the form `x = y` are solved automatically.\n\nLike `congr!`, `convert` takes an optional `with` clause of `rintro` patterns,\nfor example `convert e using n with x y z`.\n\nThe `convert` tactic also takes a configuration option, for example\n```lean\nconvert (config := {transparency := .default}) h\n```\nThese are passed to `congr!`. See `Congr!.Config` for options.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Convert.html#Mathlib.Tactic.convert\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">convert</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Convert.lean#L23-L32","name":"Lean.MVarId.convert","line":23,"kind":"def","docLink":"./Mathlib/Tactic/Convert.html#Lean.MVarId.convert","doc":"Close the goal `g` using `Eq.mp v e`,\nwhere `v` is a metavariable asserting that the type of `g` and `e` are equal.\nThen call `MVarId.congrN!` (also using local hypotheses and reflexivity) on `v`,\nand return the resulting goals.\n\nWith `sym = true`, reverses the equality in `v`, and uses `Eq.mpr v e` instead.\nWith `depth = some n`, calls `MVarId.congrN! n` instead, with `n` as the max recursion depth.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Convert.html#Lean.MVarId.convert\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">convert</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(sym : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(depth : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span> <span class=\"fn\">none</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(config : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Mathlib/Tactic/Congr!.html#Congr!.Config\">Congr!.Config</a>\n  <span class=\"fn\">{ <span class=\"fn\">closePre</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">closePost</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">transparency</span> := <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode.reducible\">Lean.Meta.TransparencyMode.reducible</a>,\n    <span class=\"fn\">preTransparency</span> := <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode.reducible\">Lean.Meta.TransparencyMode.reducible</a>, <span class=\"fn\">preferLHS</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">partialApp</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">sameFun</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>,\n    <span class=\"fn\">maxArgs</span> := <span class=\"fn\">none</span>, <span class=\"fn\">typeEqs</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>, <span class=\"fn\">etaExpand</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>, <span class=\"fn\">useCongrSimp</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a> }</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(patterns : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`rcasesPat</span></span>)</span></span>)</span> <span class=\"fn\">[]</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></span></div></div>"}]}