{"name":"Mathlib.Tactic.ToAdditive","instances":[{"typeNames":["ToAdditive.Config"],"name":"ToAdditive.instReprConfig","className":"Repr"}],"imports":["Init","Mathlib.Init.Data.Nat.Notation","Mathlib.Data.String.Defs","Mathlib.Data.Array.Defs","Mathlib.Lean.Expr.ReplaceRec","Mathlib.Lean.EnvExtension","Mathlib.Lean.Meta.Simp","Std.Lean.NameMapAttribute","Std.Data.Option.Basic","Std.Tactic.CoeExt","Std.Tactic.Ext.Attr","Std.Tactic.Lint","Std.Tactic.Relation.Rfl","Std.Tactic.Relation.Symm","Mathlib.Tactic.Relation.Trans","Mathlib.Tactic.Eqns","Mathlib.Tactic.Simps.Basic"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L1219-L1261","name":"ToAdditive.addToAdditiveAttr","line":1219,"kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.addToAdditiveAttr","doc":"`addToAdditiveAttr src cfg` adds a `@[to_additive]` attribute to `src` with configuration `cfg`.\nSee the attribute implementation for more details.\nIt returns an array with names of additive declarations (usually 1, but more if there are nested\n`to_additive` calls. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.addToAdditiveAttr\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">addToAdditiveAttr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(src : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config\">ToAdditive.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(kind : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Lean/Attributes.html#Lean.AttributeKind\">Lean.AttributeKind</a> <a href=\"./Lean/Attributes.html#Lean.AttributeKind.global\">Lean.AttributeKind.global</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Attributes.html#Lean.AttrM\">Lean.AttrM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L1211-L1213","name":"ToAdditive.transformDecl","line":1211,"kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.transformDecl","doc":"Make a new copy of a declaration, replacing fragments of the names of identifiers in the type and\nthe body using the `translations` dictionary.\nThis is used to implement `@[to_additive]`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.transformDecl\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">transformDecl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config\">ToAdditive.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(src : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tgt : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L1192-L1204","name":"ToAdditive.copyMetaData","line":1192,"kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.copyMetaData","doc":"Copies equation lemmas and attributes from `src` to `tgt`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.copyMetaData\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">copyMetaData</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config\">ToAdditive.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(src : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tgt : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L1121-L1187","name":"ToAdditive.applyAttributes","line":1121,"kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.applyAttributes","doc":"Apply attributes to the multiplicative and additive declarations. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.applyAttributes\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">applyAttributes</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(stx : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(rawAttrs : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(thisAttr : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(src : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tgt : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L1093-L1117","name":"ToAdditive.elabToAdditive","line":1093,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.elabToAdditive","doc":"Elaboration of the configuration options for `to_additive`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.elabToAdditive\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">elabToAdditive</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <a href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config\">ToAdditive.Config</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L1081-L1090","name":"ToAdditive.proceedFields","line":1081,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.proceedFields","doc":"Add the structure fields of `src` to the translations dictionary\nso that future uses of `to_additive` will map them to the corresponding `tgt` fields. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.proceedFields\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">proceedFields</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(src : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tgt : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L1068-L1077","name":"ToAdditive.proceedFieldsAux","line":1068,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.proceedFieldsAux","doc":"if `f src = #[a_1, ..., a_n]` and `f tgt = #[b_1, ... b_n]` then `proceedFieldsAux src tgt f`\nwill insert translations from `src.a_i` to `tgt.b_i`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.proceedFieldsAux\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">proceedFieldsAux</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(src : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tgt : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L1047-L1064","name":"ToAdditive.targetName","line":1047,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.targetName","doc":"Return the provided target name or autogenerate one if one was not provided. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.targetName\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">targetName</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config\">ToAdditive.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(src : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L1038-L1044","name":"ToAdditive.guessName","line":1038,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.guessName","doc":"Autogenerate additive name.\nThis runs in several steps:\n1) Split according to capitalisation rule and at `_`.\n2) Apply word-by-word translation rules.\n3) Fix up abbreviations that are not word-by-word translations, like \"addComm\" or \"Nonneg\".\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.guessName\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">guessName</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#String\">String</a> → <a href=\"./Init/Prelude.html#String\">String</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L965-L1029","name":"ToAdditive.fixAbbreviation","line":965,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.fixAbbreviation","doc":"There are a few abbreviations we use. For example \"Nonneg\" instead of \"ZeroLE\"\nor \"addComm\" instead of \"commAdd\".\nNote: The input to this function is case sensitive!\nTodo: A lot of abbreviations here are manual fixes and there might be room to\n      improve the naming logic to reduce the size of `fixAbbreviation`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.fixAbbreviation\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">fixAbbreviation</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#String\">String</a></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#String\">String</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L954-L956","name":"ToAdditive.applyNameDict","line":954,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.applyNameDict","doc":"Turn each element to lower-case, apply the `nameDict` and\ncapitalize the output like the input.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.applyNameDict\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">applyNameDict</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#String\">String</a></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#String\">String</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L918-L948","name":"ToAdditive.nameDict","line":918,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.nameDict","doc":"Dictionary used by `guessName` to autogenerate names.\n\nNote: `guessName` capitalizes first element of the output according to\ncapitalization of the input. Input and first element should therefore be lower-case,\n2nd element should be capitalized properly.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.nameDict\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">nameDict</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#String\">String</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#String\">String</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L907-L909","name":"ToAdditive.capitalizeFirstLike","line":907,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.capitalizeFirstLike","doc":"Capitalize First element of a list like `s`.\nNote that we need to capitalize multiple characters in some cases,\nin examples like `HMul` or `hAdd`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.capitalizeFirstLike\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">capitalizeFirstLike</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#String\">String</a></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#String\">String</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L901-L902","name":"ToAdditive.capitalizeLike","line":901,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.capitalizeLike","doc":"Capitalizes `s` char-by-char like `r`. If `s` is longer, it leaves the tail untouched. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.capitalizeLike\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">capitalizeLike</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(r : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(s : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#String\">String</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L888-L898","name":"ToAdditive.capitalizeLikeAux","line":888,"kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.capitalizeLikeAux","doc":"Helper for `capitalizeLike`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.capitalizeLikeAux\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">capitalizeLikeAux</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#String.Pos\">String.Pos</a> <span class=\"fn\">0</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#String\">String</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L868-L885","name":"ToAdditive.firstMultiplicativeArg","line":868,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.firstMultiplicativeArg","doc":"Find the first argument of `nm` that has a multiplicative type-class on it.\nReturns 1 if there are no types with a multiplicative class as arguments.\nE.g. `Prod.Group` returns 1, and `Pi.One` returns 2.\nNote: we only consider the first argument of each type-class.\nE.g. `[Pow A N]` is a multiplicative type-class on `A`, not on `N`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.firstMultiplicativeArg\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">firstMultiplicativeArg</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(nm : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L850-L859","name":"ToAdditive.additivizeLemmas","line":850,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.additivizeLemmas","doc":"`runAndAdditivize names desc t` runs `t` on all elements of `names`\nand adds translations between the generated lemmas (the output of `t`).\n`names` must be non-empty. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.additivizeLemmas\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">additivizeLemmas</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{m : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Lean/Exception.html#Lean.MonadError\">Lean.MonadError</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadLiftT\">MonadLiftT</a> <a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(names : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(desc : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L843-L845","name":"ToAdditive.warnParametricAttr","line":843,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.warnParametricAttr","doc":"Warn the user when the multiplicative declaration has a parametric attribute. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.warnParametricAttr\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">warnParametricAttr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(stx : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(attr : <span class=\"fn\"><a href=\"./Lean/Attributes.html#Lean.ParametricAttribute\">Lean.ParametricAttribute</a> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(thisAttr : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(attrName : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(src : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tgt : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L838-L840","name":"ToAdditive.warnAttr","line":838,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.warnAttr","doc":"Warn the user when the multiplicative declaration has a simple scoped attribute. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.warnAttr\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">warnAttr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(stx : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(attr : <span class=\"fn\"><a href=\"./Lean/ScopedEnvExtension.html#Lean.SimpleScopedEnvExtension\">Lean.SimpleScopedEnvExtension</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(thisAttr : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(attrName : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(src : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tgt : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L824-L835","name":"ToAdditive.warnExt","line":824,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.warnExt","doc":"Warn the user when the multiplicative declaration has an attribute. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.warnExt\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">warnExt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{σ : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">σ</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(stx : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ext : <span class=\"fn\"><a href=\"./Lean/Environment.html#Lean.PersistentEnvExtension\">Lean.PersistentEnvExtension</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span> <span class=\"fn\">σ</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">σ</span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(thisAttr : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(attrName : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(src : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tgt : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L816-L821","name":"ToAdditive.copyInstanceAttribute","line":816,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.copyInstanceAttribute","doc":"Copy the instance attribute in a `to_additive`\n\n[todo] it seems not to work when the `to_additive` is added as an attribute later. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.copyInstanceAttribute\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">copyInstanceAttribute</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(src : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tgt : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L745-L811","name":"ToAdditive.transformDeclAux","line":745,"kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.transformDeclAux","doc":"transform the declaration `src` and all declarations `pre._proof_i` occurring in `src`\nusing the transforms dictionary.\n`replace_all`, `trace`, `ignore` and `reorder` are configuration options.\n`pre` is the declaration that got the `@[to_additive]` attribute and `tgt_pre` is the target of this\ndeclaration. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.transformDeclAux\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">transformDeclAux</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config\">ToAdditive.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(pre : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tgt_pre : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L732-L738","name":"ToAdditive.findAuxDecls","line":732,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.findAuxDecls","doc":"Returns a `NameSet` of all auxiliary constants in `e` that might have been generated\nwhen adding `pre` to the environment.\nExamples include `pre.match_5`, `Mathlib.MyFile._auxLemma.3` and\n`_private.Mathlib.MyFile.someOtherNamespace.someOtherDeclaration._eq_2`.\nThe last two examples may or may not have been generated by this declaration.\nThe last example may or may not be the equation lemma of a declaration with the `@[to_additive]`\nattribute. We will only translate it has the `@[to_additive]` attribute.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.findAuxDecls\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">findAuxDecls</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(pre : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(mainModule : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Data/NameMap.html#Lean.NameSet\">Lean.NameSet</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L703-L722","name":"ToAdditive.findTargetName","line":703,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.findTargetName","doc":"Find the target name of `pre` and all created auxiliary declarations. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.findTargetName\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">findTargetName</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(env : <a href=\"./Lean/Environment.html#Lean.Environment\">Lean.Environment</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(src : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(pre : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tgt_pre : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L689-L700","name":"ToAdditive.updateDecl","line":689,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.updateDecl","doc":"Run applyReplacementFun on the given `srcDecl` to make a new declaration with name `tgt` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.updateDecl\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">updateDecl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(tgt : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(srcDecl : <a href=\"./Lean/Declaration.html#Lean.ConstantInfo\">Lean.ConstantInfo</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(reorder : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span>)</span> <span class=\"fn\">[]</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Declaration.html#Lean.ConstantInfo\">Lean.ConstantInfo</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L682-L686","name":"ToAdditive.reorderLambda","line":682,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.reorderLambda","doc":"Reorder lambda-binders. See doc of `reorderAttr` for the interpretation of the argument "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.reorderLambda\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">reorderLambda</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(src : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(reorder : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span>)</span> <span class=\"fn\">[]</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L675-L679","name":"ToAdditive.reorderForall","line":675,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.reorderForall","doc":"Reorder pi-binders. See doc of `reorderAttr` for the interpretation of the argument "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.reorderForall\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">reorderForall</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(src : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(reorder : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span>)</span> <span class=\"fn\">[]</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L648-L672","name":"ToAdditive.expand","line":648,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.expand","doc":"`e.expand` eta-expands all expressions that have as head a constant `n` in\n`reorder`. They are expanded until they are applied to one more argument than the maximum in\n`reorder.find n`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.expand\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">expand</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L642-L643","name":"ToAdditive.etaExpandN","line":642,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.etaExpandN","doc":"Eta expands `e` at most `n` times."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.etaExpandN\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">etaExpandN</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L565-L639","name":"ToAdditive.applyReplacementFun.aux","line":565,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.applyReplacementFun.aux","doc":"Implementation of `applyReplacementFun`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.applyReplacementFun.aux\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">applyReplacementFun</span>.<span class=\"name\">aux</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(findTranslation? : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(reorderFn : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ignore : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(changeNumeral? : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(relevantArg : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(trace : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L557-L639","name":"ToAdditive.applyReplacementFun","line":557,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.applyReplacementFun","doc":"`applyReplacementFun e` replaces the expression `e` with its additive counterpart.\nIt translates each identifier (inductive type, defined function etc) in an expression, unless\n* The identifier occurs in an application with first argument `arg`; and\n* `test arg` is false.\nHowever, if `f` is in the dictionary `relevant`, then the argument `relevant.find f`\nis tested, instead of the first argument.\n\nIt will also reorder arguments of certain functions, using `reorderFn`:\ne.g. `g x₁ x₂ x₃ ... xₙ` becomes `g x₂ x₁ x₃ ... xₙ` if `reorderFn g = some [1]`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.applyReplacementFun\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">applyReplacementFun</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L542-L544","name":"ToAdditive.changeNumeral","line":542,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.changeNumeral","doc":"Change the numeral `nat_lit 1` to the numeral `nat_lit 0`.\nLeave all other expressions unchanged. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.changeNumeral\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">changeNumeral</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L535-L538","name":"List.swapFirstTwo","line":535,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#List.swapFirstTwo","doc":"Swap the first two elements of a list "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#List.swapFirstTwo\"><span class=\"name\">List</span>.<span class=\"name\">swapFirstTwo</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L530-L532","name":"ToAdditive.additiveTest","line":530,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.additiveTest","doc":"`additiveTest e` tests whether the expression `e` contains a constant\n`nm` that is not applied to any arguments, and such that `translations.find?[nm] = none`.\nThis is used in `@[to_additive]` for deciding which subexpressions to transform: we only transform\nconstants if `additiveTest` applied to their first argument returns `true`.\nThis means we will replace expression applied to e.g. `α` or `α × β`, but not when applied to\ne.g. `ℕ` or `ℝ × α`.\nWe ignore all arguments specified by the `ignore` `NameMap`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.additiveTest\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">additiveTest</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(findTranslation? : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ignore : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L496-L518","name":"ToAdditive.additiveTestUnsafe.visit","line":496,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.additiveTestUnsafe.visit","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">unsafe def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.additiveTestUnsafe.visit\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">additiveTestUnsafe</span>.<span class=\"name\">visit</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(findTranslation? : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ignore : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(inApp : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Control/Option.html#OptionT\">OptionT</a> <a href=\"./Lean/Util/FindExpr.html#Lean.Expr.FindImpl.FindM\">Lean.Expr.FindImpl.FindM</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L494-L519","name":"ToAdditive.additiveTestUnsafe","line":494,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.additiveTestUnsafe","doc":"Implementation function for `additiveTest`.\nWe cache previous applications of the function, using the same method that `Expr.find?` uses,\nto avoid visiting the same subexpression many times. Note that we only need to cache the\nexpressions without taking the value of `inApp` into account, since `inApp` only matters when\nthe expression is a constant. However, for this reason we have to make sure that we never\ncache constant expressions, so that's why the `if`s in the implementation are in this order.\n\nNote that this function is still called many times by `applyReplacementFun`\nand we're not remembering the cache between these calls. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">unsafe def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.additiveTestUnsafe\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">additiveTestUnsafe</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(findTranslation? : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ignore : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L480-L480","name":"ToAdditive.instReprConfig","line":480,"kind":"instance","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.instReprConfig","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.instReprConfig\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">instReprConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <a href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config\">ToAdditive.Config</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L479-L479","name":"ToAdditive.Config.existing","line":479,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config.existing","doc":"An optional flag stating whether the additive declaration already exists.\nIf this flag is set but wrong about whether the additive declaration exists, `to_additive` will\nraise a linter error.\nNote: the linter will never raise an error for inductive types and structures. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config.existing\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">Config</span>.<span class=\"name\">existing</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config\">ToAdditive.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L474-L474","name":"ToAdditive.Config.ref","line":474,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config.ref","doc":"The `Syntax` element corresponding to the original multiplicative declaration\n(or the `to_additive` attribute if it is added later),\nwhich we need for adding definition ranges. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config.ref\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">Config</span>.<span class=\"name\">ref</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config\">ToAdditive.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L470-L470","name":"ToAdditive.Config.attrs","line":470,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config.attrs","doc":"The attributes which we want to give to both the multiplicative and additive versions.\nFor certain attributes (such as `simp` and `simps`) this will also add generated lemmas to the\ntranslation dictionary. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config.attrs\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">Config</span>.<span class=\"name\">attrs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config\">ToAdditive.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L466-L466","name":"ToAdditive.Config.reorder","line":466,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config.reorder","doc":"The arguments that should be reordered by `to_additive`, using cycle notation. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config.reorder\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">Config</span>.<span class=\"name\">reorder</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config\">ToAdditive.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L464-L464","name":"ToAdditive.Config.allowAutoName","line":464,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config.allowAutoName","doc":"If `allowAutoName` is `false` (default) then\n`@[to_additive]` will check whether the given name can be auto-generated. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config.allowAutoName\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">Config</span>.<span class=\"name\">allowAutoName</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config\">ToAdditive.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L461-L461","name":"ToAdditive.Config.doc","line":461,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config.doc","doc":"An optional doc string."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config.doc\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">Config</span>.<span class=\"name\">doc</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config\">ToAdditive.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#String\">String</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L459-L459","name":"ToAdditive.Config.tgt","line":459,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config.tgt","doc":"The name of the target (the additive declaration)."},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config.tgt\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">Config</span>.<span class=\"name\">tgt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config\">ToAdditive.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L457-L457","name":"ToAdditive.Config.trace","line":457,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config.trace","doc":"View the trace of the to_additive procedure.\nEquivalent to `set_option trace.to_additive true`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config.trace\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">Config</span>.<span class=\"name\">trace</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config\">ToAdditive.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L454-L454","name":"ToAdditive.Config.mk","line":454,"kind":"ctor","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config.mk\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">Config</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(trace : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tgt : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(doc : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#String\">String</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(allowAutoName : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(reorder : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(attrs : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ref : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(existing : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config\">ToAdditive.Config</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L454-L480","name":"ToAdditive.Config","line":454,"kind":"structure","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config","doc":"`Config` is the type of the arguments that can be provided to `to_additive`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.Config\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">Config</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L443-L451","name":"ToAdditive.insertTranslation","line":443,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.insertTranslation","doc":"Add a (multiplicative → additive) name translation to the translations map. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.insertTranslation\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">insertTranslation</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(src : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tgt : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(failIfExists : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">Lean.CoreM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L439-L440","name":"ToAdditive.findTranslation?","line":439,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.findTranslation?","doc":"Get the multiplicative → additive translation for the given name. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.findTranslation?\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">findTranslation?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(env : <a href=\"./Lean/Environment.html#Lean.Environment\">Lean.Environment</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L435-L436","name":"ToAdditive.translations","line":435,"kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.translations","doc":"Maps multiplicative names to their additive counterparts. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.translations\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">translations</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Lean/NameMapAttribute.html#Lean.NameMapExtension\">Lean.NameMapExtension</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L410-L433","name":"ToAdditive.changeNumeralAttr","line":410,"kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.changeNumeralAttr","doc":"An attribute that stores all the declarations that deal with numeric literals on variable types.\n\nNumeral literals occur in expressions without type information, so in order to decide whether `1`\nneeds to be changed to `0`, the context around the numeral is relevant.\nMost numerals will be in an `OfNat.ofNat` application, though tactics can add numeral literals\ninside arbitrary functions. By default we assume that we do not change numerals, unless it is\nin a function application with the `to_additive_change_numeral` attribute.\n\n`@[to_additive_change_numeral n₁ ...]` should be added to all functions that take one or more\nnumerals as argument that should be changed if `additiveTest` succeeds on the first argument,\ni.e. when the numeral is only translated if the first argument is a variable\n(or consists of variables).\nThe arguments `n₁ ...` are the positions of the numeral arguments (starting counting from 1).\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.changeNumeralAttr\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">changeNumeralAttr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Lean/NameMapAttribute.html#Lean.NameMapExtension\">Lean.NameMapExtension</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L381-L408","name":"ToAdditive.relevantArgAttr","line":381,"kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.relevantArgAttr","doc":"An attribute that is automatically added to declarations tagged with `@[to_additive]`, if needed.\n\nThis attribute tells which argument is the type where this declaration uses the multiplicative\nstructure. If there are multiple argument, we typically tag the first one.\nIf this argument contains a fixed type, this declaration will note be additivized.\nSee the Heuristics section of `to_additive.attr` for more details.\n\nIf a declaration is not tagged, it is presumed that the first argument is relevant.\n`@[to_additive]` uses the function `to_additive.first_multiplicative_arg` to automatically tag\ndeclarations. It is ok to update it manually if the automatic tagging made an error.\n\nImplementation note: we only allow exactly 1 relevant argument, even though some declarations\n(like `prod.group`) have multiple arguments with a multiplicative structure on it.\nThe reason is that whether we additivize a declaration is an all-or-nothing decision, and if\nwe will not be able to additivize declarations that (e.g.) talk about multiplication on `ℕ × α`\nanyway.\n\nWarning: interactions between this and the `(reorder := ...)` argument are not well-tested.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.relevantArgAttr\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">relevantArgAttr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Lean/NameMapAttribute.html#Lean.NameMapExtension\">Lean.NameMapExtension</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L359-L379","name":"ToAdditive.reorderAttr","line":359,"kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.reorderAttr","doc":"An attribute that stores all the declarations that needs their arguments reordered when\napplying `@[to_additive]`. It is applied automatically by the `(reorder := ...)` syntax of\n`to_additive`, and should not usually be added manually.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.reorderAttr\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">reorderAttr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Lean/NameMapAttribute.html#Lean.NameMapExtension\">Lean.NameMapExtension</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L342-L357","name":"ToAdditive.ignoreArgsAttr","line":342,"kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.ignoreArgsAttr","doc":"An attribute that tells `@[to_additive]` that certain arguments of this definition are not\ninvolved when using `@[to_additive]`.\nThis helps the heuristic of `@[to_additive]` by also transforming definitions if `ℕ` or another\nfixed type occurs as one of these arguments.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.ignoreArgsAttr\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">ignoreArgsAttr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Lean/NameMapAttribute.html#Lean.NameMapExtension\">Lean.NameMapExtension</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L334-L339","name":"ToAdditive.linter.toAdditiveExisting","line":334,"kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.linter.toAdditiveExisting","doc":"Linter to check whether the user correctly specified that the additive declaration already\nexists "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.linter.toAdditiveExisting\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">linter</span>.<span class=\"name\">toAdditiveExisting</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/Options.html#Lean.Option\">Lean.Option</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L328-L332","name":"ToAdditive.linter.toAdditiveGenerateName","line":328,"kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.linter.toAdditiveGenerateName","doc":"Linter to check that the `to_additive` attribute is not given manually "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.linter.toAdditiveGenerateName\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">linter</span>.<span class=\"name\">toAdditiveGenerateName</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/Options.html#Lean.Option\">Lean.Option</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L321-L326","name":"ToAdditive.linter.existingAttributeWarning","line":321,"kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.linter.existingAttributeWarning","doc":"Linter, mostly used by `@[to_additive]`, that checks that the source declaration doesn't have\ncertain attributes "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.linter.existingAttributeWarning\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">linter</span>.<span class=\"name\">existingAttributeWarning</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/Options.html#Lean.Option\">Lean.Option</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L316-L319","name":"ToAdditive.linter.toAdditiveReorder","line":316,"kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive.html#ToAdditive.linter.toAdditiveReorder","doc":"Linter to check that the `reorder` attribute is not given manually "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#ToAdditive.linter.toAdditiveReorder\"><span class=\"name\">ToAdditive</span>.<span class=\"name\">linter</span>.<span class=\"name\">toAdditiveReorder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/Options.html#Lean.Option\">Lean.Option</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L287-L309","name":"String.splitCase","line":287,"kind":"opaque","docLink":"./Mathlib/Tactic/ToAdditive.html#String.splitCase","doc":"This function takes a String and splits it into separate parts based on the following\n(naming conventions)[https://github.com/leanprover-community/mathlib4/wiki#naming-convention].\n\nE.g. `#eval \"InvHMulLEConjugate₂SMul_ne_top\".splitCase` yields\n`[\"Inv\", \"HMul\", \"LE\", \"Conjugate₂\", \"SMul\", \"_\", \"ne\", \"_\", \"top\"]`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#String.splitCase\"><span class=\"name\">String</span>.<span class=\"name\">splitCase</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(i₀ : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#String.Pos\">String.Pos</a> <span class=\"fn\">0</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(r : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#String\">String</a></span>)</span> <span class=\"fn\">[]</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#String\">String</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L275-L278","name":"endCapitalNames","line":275,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#endCapitalNames","doc":"A set of strings of names that end in a capital letter.\n* If the string contains a lowercase letter, the string should be split between the first occurrence\n  of a lower-case letter followed by an upper-case letter.\n* If multiple strings have the same prefix, they should be grouped by prefix\n* In this case, the second list should be prefix-free\n  (no element can be a prefix of a later element)\n\nTodo: automate the translation from `String` to an element in this `RBMap`\n  (but this would require having something similar to the `rb_lmap` from Lean 3). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#endCapitalNames\"><span class=\"name\">endCapitalNames</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/RBMap.html#Lean.RBMap\">Lean.RBMap</a> <a href=\"./Init/Prelude.html#String\">String</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#String\">String</a></span>)</span> <span class=\"fn\">compare</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L264-L264","name":"attrTo_additive?_","line":264,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#attrTo_additive?_","doc":"The `to_additive` attribute. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#attrTo_additive?_\"><span class=\"name\">attrTo_additive?_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L260-L261","name":"to_additive","line":260,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#to_additive","doc":"The `to_additive` attribute. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#to_additive\"><span class=\"name\">to_additive</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L258-L259","name":"toAdditiveRest","line":258,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#toAdditiveRest","doc":"Remaining arguments of `to_additive`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#toAdditiveRest\"><span class=\"name\">toAdditiveRest</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L256-L257","name":"toAdditiveOption","line":256,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#toAdditiveOption","doc":"Options to `to_additive`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#toAdditiveOption\"><span class=\"name\">toAdditiveOption</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L254-L255","name":"toAdditiveParenthesizedOption","line":254,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#toAdditiveParenthesizedOption","doc":"Options to `to_additive`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#toAdditiveParenthesizedOption\"><span class=\"name\">toAdditiveParenthesizedOption</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L252-L253","name":"toAdditiveReorderOption","line":252,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#toAdditiveReorderOption","doc":"A `reorder := ...` option for `to_additive`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#toAdditiveReorderOption\"><span class=\"name\">toAdditiveReorderOption</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L250-L251","name":"toAdditiveAttrOption","line":250,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#toAdditiveAttrOption","doc":"An `attr := ...` option for `to_additive`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#toAdditiveAttrOption\"><span class=\"name\">toAdditiveAttrOption</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L248-L249","name":"to_additive_change_numeral","line":248,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#to_additive_change_numeral","doc":"The `to_additive_change_numeral` attribute. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#to_additive_change_numeral\"><span class=\"name\">to_additive_change_numeral</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L246-L247","name":"to_additive_reorder","line":246,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#to_additive_reorder","doc":"The `to_additive_reorder` attribute. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#to_additive_reorder\"><span class=\"name\">to_additive_reorder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L244-L245","name":"to_additive_relevant_arg","line":244,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#to_additive_relevant_arg","doc":"The `to_additive_relevant_arg` attribute. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#to_additive_relevant_arg\"><span class=\"name\">to_additive_relevant_arg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ToAdditive.lean#L242-L243","name":"to_additive_ignore_args","line":242,"kind":"def","docLink":"./Mathlib/Tactic/ToAdditive.html#to_additive_ignore_args","doc":"The `to_additive_ignore_args` attribute. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ToAdditive.html#to_additive_ignore_args\"><span class=\"name\">to_additive_ignore_args</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"}]}