{"name":"Std.Tactic.SqueezeScope","instances":[],"imports":["Init","Lean.Elab.Tactic.Simp","Std.Tactic.SimpTrace"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SqueezeScope.lean#L66-L74","name":"Std.Tactic.squeezeScopes","line":66,"kind":"opaque","docLink":"./Std/Tactic/SqueezeScope.html#Std.Tactic.squeezeScopes","doc":"We implement `squeeze_scope` using a global variable that tracks all `squeeze_scope` invocations\nin flight. It is a map `a => (x => (stx, simps))` where `a` is a unique identifier for\nthe `squeeze_scope` invocation which is shared with all contained simps, and `x` is a unique\nidentifier for a particular piece of simp syntax (which can be called multiple times).\nWithin that, `stx` is the simp syntax itself, and `simps` is the aggregated list of simps used\nso far.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SqueezeScope.html#Std.Tactic.squeezeScopes\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">squeezeScopes</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#IO.Ref\">IO.Ref</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Lean/Data/NameMap.html#Lean.NameMap\">Lean.NameMap</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Lean/Data/NameMap.html#Lean.NameMap\">Lean.NameMap</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.UsedSimps\">Lean.Meta.Simp.UsedSimps</a></span></span>)</span></span>)</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SqueezeScope.lean#L55-L62","name":"Std.Tactic.squeezeScope","line":55,"kind":"def","docLink":"./Std/Tactic/SqueezeScope.html#Std.Tactic.squeezeScope","doc":"The `squeeze_scope` tactic allows aggregating multiple calls to `simp` coming from the same syntax\nbut in different branches of execution, such as in `cases x <;> simp`.\nThe reported `simp` call covers all simp lemmas used by this syntax.\n```\n@[simp] def bar (z : Nat) := 1 + z\n@[simp] def baz (z : Nat) := 1 + z\n\n@[simp] def foo : Nat → Nat → Nat\n  | 0, z => bar z\n  | _+1, z => baz z\n\nexample : foo x y = 1 + y := by\n  cases x <;> simp? -- two printouts:\n  -- \"Try this: simp only [foo, bar]\"\n  -- \"Try this: simp only [foo, baz]\"\n\nexample : foo x y = 1 + y := by\n  squeeze_scope\n    cases x <;> simp -- only one printout: \"Try this: simp only [foo, baz, bar]\"\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SqueezeScope.html#Std.Tactic.squeezeScope\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">squeezeScope</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SqueezeScope.lean#L25-L30","name":"Std.Tactic.squeezeWrap","line":25,"kind":"def","docLink":"./Std/Tactic/SqueezeScope.html#Std.Tactic.squeezeWrap","doc":"`squeeze_wrap a x => tac` is part of the implementation of `squeeze_scope`.\nHere `tac` will be a `simp` or `dsimp` syntax, and `squeeze_wrap` will run the tactic\nand contribute the generated `usedSimps` to the `squeezeScopes[a][x]` variable.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SqueezeScope.html#Std.Tactic.squeezeWrap\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">squeezeWrap</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SqueezeScope.lean#L19-L24","name":"Std.Tactic.squeezeScopeIn","line":19,"kind":"def","docLink":"./Std/Tactic/SqueezeScope.html#Std.Tactic.squeezeScopeIn","doc":"`squeeze_scope a => tacs` is part of the implementation of `squeeze_scope`.\nInside `tacs`, invocations of `simp` wrapped with `squeeze_wrap a _ => ...` will contribute\nto the accounting associated to scope `a`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SqueezeScope.html#Std.Tactic.squeezeScopeIn\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">squeezeScopeIn</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"}]}