{"name":"Std.Tactic.Change","instances":[],"imports":["Init","Lean.Meta.Tactic.Replace","Lean.Elab.Tactic.Location"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Change.lean#L59-L74","name":"Lean.MVarId.changeLocalDecl'","line":59,"kind":"def","docLink":"./Std/Tactic/Change.html#Lean.MVarId.changeLocalDecl'","doc":"Replace the type of the free variable `fvarId` with `typeNew`.\n\nIf `checkDefEq = true` then throws an error if `typeNew` is not definitionally\nequal to the type of `fvarId`. Otherwise this function assumes `typeNew` and the type\nof `fvarId` are definitionally equal.\n\nThis function is the same as `Lean.MVarId.changeLocalDecl` but makes sure to push substitution\ninformation into the infotree.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Change.html#Lean.MVarId.changeLocalDecl'\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">changeLocalDecl'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(mvarId : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fvarId : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(typeNew : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(checkDefEq : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Change.lean#L37-L47","name":"Lean.MVarId.withReverted","line":37,"kind":"def","docLink":"./Std/Tactic/Change.html#Lean.MVarId.withReverted","doc":"Function to help do the revert/intro pattern, running some code inside a context\nwhere certain variables have been reverted before re-introing them.\nIt will push `FVarId` alias information into info trees for you according to a simple protocol.\n\n- `fvarIds` is an array of `fvarIds` to revert. These are passed to\n  `Lean.MVarId.revert` with `preserveOrder := true`, hence the function\n  raises an error if they cannot be reverted in the provided order.\n- `k` is given the goal with all the variables reverted and\n  the array of reverted `FVarId`s, with the requested `FVarId`s at the beginning.\n  It must return a tuple of a value, an array describing which `FVarIds` to link,\n  and a mutated `MVarId`.\n\nThe `a : Array (Option FVarId)` array returned by `k` is interpreted in the following way.\nThe function will intro `a.size` variables, and then for each non-`none` entry we\ncreate an FVar alias between it and the corresponding `intro`ed variable.\nFor example, having `k` return `fvars.map .some` causes all reverted variables to be\n`intro`ed and linked.\n\nReturns the value returned by `k` along with the resulting goal.\n "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Change.html#Lean.MVarId.withReverted\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">withReverted</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(mvarId : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fvarIds : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span>)</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(clearAuxDeclsInsteadOfRevert : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></span></div></div>"}]}