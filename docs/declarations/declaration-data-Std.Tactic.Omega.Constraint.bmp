{"name":"Std.Tactic.Omega.Constraint","instances":[{"typeNames":["Std.Tactic.Omega.Constraint"],"name":"Std.Tactic.Omega.instBEqConstraint","className":"BEq"},{"typeNames":["Eq"],"name":"Std.Tactic.Omega.instDecidableEqConstraint","className":"Decidable"},{"typeNames":["Std.Tactic.Omega.Constraint"],"name":"Std.Tactic.Omega.instReprConstraint","className":"Repr"},{"typeNames":["Std.Tactic.Omega.Constraint"],"name":"Std.Tactic.Omega.Constraint.instToExprConstraint","className":"Lean.ToExpr"},{"typeNames":["Std.Tactic.Omega.Constraint"],"name":"Std.Tactic.Omega.Constraint.instToStringConstraint","className":"ToString"}],"imports":["Init","Std.Classes.Order","Std.Tactic.RCases","Std.Tactic.NormCast","Std.Tactic.Omega.Coeffs.IntList"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L252-L253","name":"Std.Tactic.Omega.Constraint.not_sat'_of_isImpossible","line":252,"kind":"theorem","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.not_sat'_of_isImpossible","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.not_sat'_of_isImpossible\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">not_sat'_of_isImpossible</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.isImpossible\">Std.Tactic.Omega.Constraint.isImpossible</a> <span class=\"fn\">c</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{x : <a href=\"./Std/Tactic/Omega/Coeffs/IntList.html#Std.Tactic.Omega.Coeffs\">Std.Tactic.Omega.Coeffs</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{y : <a href=\"./Std/Tactic/Omega/Coeffs/IntList.html#Std.Tactic.Omega.Coeffs\">Std.Tactic.Omega.Coeffs</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat'\">Std.Tactic.Omega.Constraint.sat'</a> <span class=\"fn\">c</span> <span class=\"fn\">x</span> <span class=\"fn\">y</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L246-L250","name":"Std.Tactic.Omega.Constraint.div_sat'","line":246,"kind":"theorem","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.div_sat'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.div_sat'\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">div_sat'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{x : <a href=\"./Std/Tactic/Omega/Coeffs/IntList.html#Std.Tactic.Omega.Coeffs\">Std.Tactic.Omega.Coeffs</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{y : <a href=\"./Std/Tactic/Omega/Coeffs/IntList.html#Std.Tactic.Omega.Coeffs\">Std.Tactic.Omega.Coeffs</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Coeffs/IntList.html#Std.Tactic.Omega.Coeffs.gcd\">Std.Tactic.Omega.Coeffs.gcd</a> <span class=\"fn\">x</span></span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">0</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">c</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/Coeffs/IntList.html#Std.Tactic.Omega.Coeffs.dot\">Std.Tactic.Omega.Coeffs.dot</a> <span class=\"fn\">x</span> <span class=\"fn\">y</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat'\">Std.Tactic.Omega.Constraint.sat'</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.div\">Std.Tactic.Omega.Constraint.div</a> <span class=\"fn\">c</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/Coeffs/IntList.html#Std.Tactic.Omega.Coeffs.gcd\">Std.Tactic.Omega.Coeffs.gcd</a> <span class=\"fn\">x</span></span>)</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/Coeffs/IntList.html#Std.Tactic.Omega.Coeffs.sdiv\">Std.Tactic.Omega.Coeffs.sdiv</a> <span class=\"fn\">x</span> <span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/Coeffs/IntList.html#Std.Tactic.Omega.Coeffs.gcd\">Std.Tactic.Omega.Coeffs.gcd</a> <span class=\"fn\">x</span></span>)</span></span></span>)</span> <span class=\"fn\">y</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <a href=\"./Init/Prelude.html#Bool.true\">true</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L243-L244","name":"Std.Tactic.Omega.Constraint.combine_sat'","line":243,"kind":"theorem","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.combine_sat'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.combine_sat'\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">combine_sat'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{s : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{x : <a href=\"./Std/Tactic/Omega/Coeffs/IntList.html#Std.Tactic.Omega.Coeffs\">Std.Tactic.Omega.Coeffs</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{y : <a href=\"./Std/Tactic/Omega/Coeffs/IntList.html#Std.Tactic.Omega.Coeffs\">Std.Tactic.Omega.Coeffs</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ws : <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat'\">Std.Tactic.Omega.Constraint.sat'</a> <span class=\"fn\">s</span> <span class=\"fn\">x</span> <span class=\"fn\">y</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(wt : <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat'\">Std.Tactic.Omega.Constraint.sat'</a> <span class=\"fn\">t</span> <span class=\"fn\">x</span> <span class=\"fn\">y</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat'\">Std.Tactic.Omega.Constraint.sat'</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.combine\">Std.Tactic.Omega.Constraint.combine</a> <span class=\"fn\">s</span> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">x</span> <span class=\"fn\">y</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L241-L241","name":"Std.Tactic.Omega.Constraint.sat'","line":241,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat'","doc":"It is convenient below to say that a constraint is satisfied at the dot product of two vectors,\nso we make an abbreviation `sat'` for this.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat'\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">sat'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <a href=\"./Std/Tactic/Omega/Coeffs/IntList.html#Std.Tactic.Omega.Coeffs\">Std.Tactic.Omega.Coeffs</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(y : <a href=\"./Std/Tactic/Omega/Coeffs/IntList.html#Std.Tactic.Omega.Coeffs\">Std.Tactic.Omega.Coeffs</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L213-L235","name":"Std.Tactic.Omega.Constraint.div_sat","line":213,"kind":"theorem","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.div_sat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.div_sat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">div_sat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n : <span class=\"fn\"><span class=\"fn\">k</span> <a href=\"./Init/Core.html#Ne\">≠</a> <span class=\"fn\">0</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">k</span></span> <a href=\"./Std/Classes/Dvd.html#Dvd.dvd\">∣</a> <span class=\"fn\">t</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">c</span> <span class=\"fn\">t</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.div\">Std.Tactic.Omega.Constraint.div</a> <span class=\"fn\">c</span> <span class=\"fn\">k</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">t</span> <a href=\"./Init/Prelude.html#HDiv.hDiv\">/</a> <span class=\"fn\">↑<span class=\"fn\">k</span></span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L209-L211","name":"Std.Tactic.Omega.Constraint.div","line":209,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.div","doc":"Dividing a constraint by a natural number, and tightened to integer bounds.\nThus the lower bound is rounded up, and the upper bound is rounded down.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.div\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">div</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L194-L203","name":"Std.Tactic.Omega.Constraint.combine_sat","line":194,"kind":"theorem","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.combine_sat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.combine_sat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">combine_sat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(c' : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.combine\">Std.Tactic.Omega.Constraint.combine</a> <span class=\"fn\">c</span> <span class=\"fn\">c'</span></span>)</span> <span class=\"fn\">t</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">c</span> <span class=\"fn\">t</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span> <a href=\"./Init/Prelude.html#And\">∧</a> <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">c'</span> <span class=\"fn\">t</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L190-L192","name":"Std.Tactic.Omega.Constraint.combine","line":190,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.combine","doc":"The conjunction of two constraints. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.combine\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">combine</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(x : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(y : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L185-L187","name":"Std.Tactic.Omega.Constraint.combo_sat","line":185,"kind":"theorem","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.combo_sat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.combo_sat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">combo_sat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c₁ : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c₂ : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{x₁ : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{x₂ : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(a : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w₁ : <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">c₁</span> <span class=\"fn\">x₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w₂ : <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">c₂</span> <span class=\"fn\">x₂</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.combo\">Std.Tactic.Omega.Constraint.combo</a> <span class=\"fn\">a</span> <span class=\"fn\">c₁</span> <span class=\"fn\">b</span> <span class=\"fn\">c₂</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">x₁</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">x₂</span></span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L182-L183","name":"Std.Tactic.Omega.Constraint.combo","line":182,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.combo","doc":"A linear combination of two constraints. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.combo\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">combo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(a : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(y : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L168-L179","name":"Std.Tactic.Omega.Constraint.add_sat","line":168,"kind":"theorem","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.add_sat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.add_sat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">add_sat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c₁ : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c₂ : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{x₁ : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{x₂ : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(w₁ : <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">c₁</span> <span class=\"fn\">x₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w₂ : <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">c₂</span> <span class=\"fn\">x₂</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.add\">Std.Tactic.Omega.Constraint.add</a> <span class=\"fn\">c₁</span> <span class=\"fn\">c₂</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">x₁</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">x₂</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L164-L166","name":"Std.Tactic.Omega.Constraint.add","line":164,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.add","doc":"The sum of two constraints. `[a, b] + [c, d] = [a + c, b + d]`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.add\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">add</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(x : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(y : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L140-L161","name":"Std.Tactic.Omega.Constraint.scale_sat","line":140,"kind":"theorem","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.scale_sat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.scale_sat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">scale_sat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(w : <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">c</span> <span class=\"fn\">t</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.scale\">Std.Tactic.Omega.Constraint.scale</a> <span class=\"fn\">k</span> <span class=\"fn\">c</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">t</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L132-L138","name":"Std.Tactic.Omega.Constraint.scale","line":132,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.scale","doc":"Scale a constraint by multiplying by an integer.\n* If `k = 0` this is either impossible, if the original constraint was impossible,\n  or the `= 0` exact constraint.\n* If `k` is positive this takes `[x, y]` to `[k * x, k * y]`\n* If `k` is negative this takes `[x, y]` to `[k * y, k * x]`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.scale\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">scale</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(k : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L119-L123","name":"Std.Tactic.Omega.Constraint.not_sat_of_isImpossible","line":119,"kind":"theorem","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.not_sat_of_isImpossible","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.not_sat_of_isImpossible\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">not_sat_of_isImpossible</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.isImpossible\">Std.Tactic.Omega.Constraint.isImpossible</a> <span class=\"fn\">c</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Not\">¬</a><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">c</span> <span class=\"fn\">t</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L115-L117","name":"Std.Tactic.Omega.Constraint.isExact","line":115,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.isExact","doc":"Check if a constraint requires an exact value. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.isExact\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">isExact</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L110-L112","name":"Std.Tactic.Omega.Constraint.isImpossible","line":110,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.isImpossible","doc":"Check if a constraint is unsatisfiable. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.isImpossible\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">isImpossible</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L105-L107","name":"Std.Tactic.Omega.Constraint.exact_sat","line":105,"kind":"theorem","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.exact_sat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.exact_sat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">exact_sat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(r : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.exact\">Std.Tactic.Omega.Constraint.exact</a> <span class=\"fn\">r</span></span>)</span> <span class=\"fn\">t</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable.decide\">decide</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">r</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">t</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L102-L103","name":"Std.Tactic.Omega.Constraint.trivial_say","line":102,"kind":"theorem","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.trivial_say","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.trivial_say\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">trivial_say</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.trivial\">Std.Tactic.Omega.Constraint.trivial</a> <span class=\"fn\">t</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L100-L100","name":"Std.Tactic.Omega.Constraint.exact","line":100,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.exact","doc":"An exact constraint. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.exact\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">exact</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(r : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L98-L98","name":"Std.Tactic.Omega.Constraint.impossible","line":98,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.impossible","doc":"The impossible constraint, unsatisfiable. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.impossible\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">impossible</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L96-L96","name":"Std.Tactic.Omega.Constraint.trivial","line":96,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.trivial","doc":"The trivial constraint, satisfied everywhere. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.trivial\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">trivial</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L87-L93","name":"Std.Tactic.Omega.Constraint.neg_sat","line":87,"kind":"theorem","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.neg_sat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.neg_sat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">neg_sat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{v : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">c</span> <span class=\"fn\">v</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span> →\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.neg\">Std.Tactic.Omega.Constraint.neg</a> <span class=\"fn\">c</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">v</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L85-L85","name":"Std.Tactic.Omega.Constraint.neg","line":85,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.neg","doc":"Negate a constraint. `[x, y]` becomes `[-y, -x]`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.neg\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">neg</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L78-L80","name":"Std.Tactic.Omega.Constraint.flip","line":78,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.flip","doc":"Flip a constraint.\nThis operation is not useful by itself, but is used to implement `neg` and `scale`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.flip\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">flip</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L66-L72","name":"Std.Tactic.Omega.Constraint.translate_sat","line":66,"kind":"theorem","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.translate_sat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.translate_sat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">translate_sat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{t : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{c : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{v : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">c</span> <span class=\"fn\">v</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span> →\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\">Std.Tactic.Omega.Constraint.sat</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.translate\">Std.Tactic.Omega.Constraint.translate</a> <span class=\"fn\">c</span> <span class=\"fn\">t</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">v</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">t</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L64-L64","name":"Std.Tactic.Omega.Constraint.translate","line":64,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.translate","doc":"Translate a constraint. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.translate\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">translate</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L59-L61","name":"Std.Tactic.Omega.Constraint.map","line":59,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.map","doc":"Apply a function to both the lower bound and upper bound. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.map\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">map</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><a href=\"./Init/Data/Int/Basic.html#Int\">Int</a> → <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L56-L56","name":"Std.Tactic.Omega.Constraint.sat","line":56,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat","doc":"A constraint is satisfied at `t` is both the lower bound and upper bound are satisfied. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.sat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">sat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L47-L53","name":"Std.Tactic.Omega.Constraint.instToStringConstraint","line":47,"kind":"instance","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.instToStringConstraint","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.instToStringConstraint\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">instToStringConstraint</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/ToString/Basic.html#ToString\">ToString</a> <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L42-L45","name":"Std.Tactic.Omega.Constraint.instToExprConstraint","line":42,"kind":"instance","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.instToExprConstraint","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.instToExprConstraint\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">instToExprConstraint</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/ToExpr.html#Lean.ToExpr\">Lean.ToExpr</a> <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L37-L37","name":"Std.Tactic.Omega.instReprConstraint","line":37,"kind":"instance","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.instReprConstraint","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.instReprConstraint\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">instReprConstraint</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L37-L37","name":"Std.Tactic.Omega.instDecidableEqConstraint","line":37,"kind":"instance","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.instDecidableEqConstraint","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.instDecidableEqConstraint\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">instDecidableEqConstraint</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L37-L37","name":"Std.Tactic.Omega.instBEqConstraint","line":37,"kind":"instance","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.instBEqConstraint","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.instBEqConstraint\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">instBEqConstraint</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L36-L36","name":"Std.Tactic.Omega.Constraint.upperBound","line":36,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.upperBound","doc":"An upper bound. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.upperBound\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">upperBound</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.UpperBound\">Std.Tactic.Omega.UpperBound</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L34-L34","name":"Std.Tactic.Omega.Constraint.lowerBound","line":34,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.lowerBound","doc":"A lower bound. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.lowerBound\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">lowerBound</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.LowerBound\">Std.Tactic.Omega.LowerBound</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L32-L32","name":"Std.Tactic.Omega.Constraint.mk","line":32,"kind":"ctor","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint.mk\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(lowerBound : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.LowerBound\">Std.Tactic.Omega.LowerBound</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(upperBound : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.UpperBound\">Std.Tactic.Omega.UpperBound</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\">Std.Tactic.Omega.Constraint</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L32-L37","name":"Std.Tactic.Omega.Constraint","line":32,"kind":"structure","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint","doc":"A `Constraint` consists of an optional lower and upper bound (inclusive),\nconstraining a value to a set of the form `∅`, `{x}`, `[x, y]`, `[x, ∞)`, `(-∞, y]`, or `(-∞, ∞)`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.Constraint\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">Constraint</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L26-L26","name":"Std.Tactic.Omega.UpperBound.sat","line":26,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.UpperBound.sat","doc":"A upper bound at `y` is satisfied at `t` if `t ≤ y`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.UpperBound.sat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">UpperBound</span>.<span class=\"name\">sat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(b : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.UpperBound\">Std.Tactic.Omega.UpperBound</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L24-L24","name":"Std.Tactic.Omega.LowerBound.sat","line":24,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.LowerBound.sat","doc":"A lower bound at `x` is satisfied at `t` if `x ≤ t`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.LowerBound.sat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">LowerBound</span>.<span class=\"name\">sat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(b : <a href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.LowerBound\">Std.Tactic.Omega.LowerBound</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <a href=\"./Init/Data/Int/Basic.html#Int\">Int</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L21-L21","name":"Std.Tactic.Omega.UpperBound","line":21,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.UpperBound","doc":"An optional upper bound on a integer. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.UpperBound\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">UpperBound</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Constraint.lean#L19-L19","name":"Std.Tactic.Omega.LowerBound","line":19,"kind":"def","docLink":"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.LowerBound","doc":"An optional lower bound on a integer. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Constraint.html#Std.Tactic.Omega.LowerBound\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">LowerBound</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"}]}