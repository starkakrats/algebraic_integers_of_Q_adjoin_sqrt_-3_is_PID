{"name":"Std.Tactic.NormCast","instances":[],"imports":["Init","Lean.Elab.Tactic.Conv.Simp","Std.Lean.Meta.Simp","Std.Tactic.NormCast.Ext","Std.Tactic.CoeExt","Std.Classes.Cast"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast.lean#L327-L332","name":"Std.Tactic.NormCast.evalPushCast","line":327,"kind":"def","docLink":"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.evalPushCast","doc":"`push_cast` rewrites the expression to move casts toward the leaf nodes.\nThis uses `norm_cast` lemmas in the forward direction.\nFor example, `↑(a + b)` will be written to `↑a + ↑b`.\nIt is equivalent to `simp only with push_cast`.\nIt can also be used at hypotheses with `push_cast at h`\nand with extra simp lemmas with `push_cast [int.add_zero]`.\n\n```lean\nexample (a b : ℕ) (h1 : ((a + b : ℕ) : ℤ) = 10) (h2 : ((a + b + 0 : ℕ) : ℤ) = 10) :\n  ((a + b : ℕ) : ℤ) = 10 :=\nbegin\n  push_cast,\n  push_cast at h1,\n  push_cast [int.add_zero] at h2,\nend\n```\n\nThe implementation and behavior of the `norm_cast` family is described in detail at\n<https://lean-forward.github.io/norm_cast/norm_cast.pdf>.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.evalPushCast\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">evalPushCast</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.Tactic\">Lean.Elab.Tactic.Tactic</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast.lean#L303-L325","name":"Std.Tactic.NormCast.pushCast","line":303,"kind":"def","docLink":"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.pushCast","doc":"`push_cast` rewrites the expression to move casts toward the leaf nodes.\nThis uses `norm_cast` lemmas in the forward direction.\nFor example, `↑(a + b)` will be written to `↑a + ↑b`.\nIt is equivalent to `simp only with push_cast`.\nIt can also be used at hypotheses with `push_cast at h`\nand with extra simp lemmas with `push_cast [int.add_zero]`.\n\n```lean\nexample (a b : ℕ) (h1 : ((a + b : ℕ) : ℤ) = 10) (h2 : ((a + b + 0 : ℕ) : ℤ) = 10) :\n  ((a + b : ℕ) : ℤ) = 10 :=\nbegin\n  push_cast,\n  push_cast at h1,\n  push_cast [int.add_zero] at h2,\nend\n```\n\nThe implementation and behavior of the `norm_cast` family is described in detail at\n<https://lean-forward.github.io/norm_cast/norm_cast.pdf>.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.pushCast\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">pushCast</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast.lean#L299-L301","name":"Std.Tactic.NormCast.evalConvNormCast","line":299,"kind":"def","docLink":"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.evalConvNormCast","doc":"`norm_cast` tactic in `conv` mode. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.evalConvNormCast\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">evalConvNormCast</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.Tactic\">Lean.Elab.Tactic.Tactic</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast.lean#L296-L297","name":"Std.Tactic.NormCast.convNormCast","line":296,"kind":"def","docLink":"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.convNormCast","doc":"`norm_cast` tactic in `conv` mode. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.convNormCast\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">convNormCast</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast.lean#L294-L294","name":"Std.Tactic.NormCast.tacticApply_mod_cast_","line":294,"kind":"def","docLink":"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.tacticApply_mod_cast_","doc":"Normalize the goal and the given expression, then apply the expression to the goal.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.tacticApply_mod_cast_\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">tacticApply_mod_cast_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast.lean#L289-L289","name":"Std.Tactic.NormCast.tacticExact_mod_cast_","line":289,"kind":"def","docLink":"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.tacticExact_mod_cast_","doc":"Normalize the goal and the given expression, then close the goal with exact.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.tacticExact_mod_cast_\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">tacticExact_mod_cast_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast.lean#L276-L279","name":"Std.Tactic.NormCast.tacticRw_mod_cast___","line":276,"kind":"def","docLink":"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.tacticRw_mod_cast___","doc":"Rewrite with the given rules and normalize casts between steps.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.tacticRw_mod_cast___\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">tacticRw_mod_cast___</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast.lean#L273-L274","name":"Std.Tactic.NormCast.tacticNorm_cast_","line":273,"kind":"def","docLink":"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.tacticNorm_cast_","doc":"The `norm_cast` family of tactics is used to normalize casts inside expressions.\nIt is basically a simp tactic with a specific set of lemmas to move casts\nupwards in the expression.\nTherefore it can be used more safely as a non-terminating tactic.\nIt also has special handling of numerals.\n\nFor instance, given an assumption\n```lean\na b : ℤ\nh : ↑a + ↑b < (10 : ℚ)\n```\n\nwriting `norm_cast at h` will turn `h` into\n```lean\nh : a + b < 10\n```\n\nYou can also use `exact_mod_cast`, `apply_mod_cast`, `rw_mod_cast`\nor `assumption_mod_cast`.\nWriting `exact_mod_cast h` and `apply_mod_cast h` will normalize the goal and\n`h` before using `exact h` or `apply h`.\nWriting `assumption_mod_cast` will normalize the goal and for every\nexpression `h` in the context it will try to normalize `h` and use\n`exact h`.\n`rw_mod_cast` acts like the `rw` tactic but it applies `norm_cast` between steps.\n\nSee also `push_cast`, for move casts inwards.\n\nThe implementation and behavior of the `norm_cast` family is described in detail at\n<https://lean-forward.github.io/norm_cast/norm_cast.pdf>.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.tacticNorm_cast_\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">tacticNorm_cast_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast.lean#L239-L239","name":"Std.Tactic.NormCast.tacticAssumption_mod_cast","line":239,"kind":"def","docLink":"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.tacticAssumption_mod_cast","doc":"`assumption_mod_cast` runs `norm_cast` on the goal. For each local hypothesis `h`, it also\nnormalizes `h` and tries to use that to close the goal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.tacticAssumption_mod_cast\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">tacticAssumption_mod_cast</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast.lean#L226-L235","name":"Std.Tactic.NormCast.tacticNorm_cast0_","line":226,"kind":"def","docLink":"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.tacticNorm_cast0_","doc":"Implementation of `norm_cast` (the full `norm_cast` calls `trivial` afterwards). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.tacticNorm_cast0_\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">tacticNorm_cast0_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast.lean#L220-L224","name":"Std.Tactic.NormCast.normCastHyp","line":220,"kind":"def","docLink":"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.normCastHyp","doc":"Implementation of the `norm_cast` tactic when operating on a hypothesis. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.normCastHyp\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">normCastHyp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(fvarId : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast.lean#L213-L217","name":"Std.Tactic.NormCast.normCastTarget","line":213,"kind":"def","docLink":"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.normCastTarget","doc":"Implementation of the `norm_cast` tactic when operating on the main goal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.normCastTarget\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">normCastTarget</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast.lean#L196-L208","name":"Std.Tactic.NormCast.termMod_cast_","line":196,"kind":"def","docLink":"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.termMod_cast_","doc":"Term elaborator which uses the expected type to insert coercions. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.termMod_cast_\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">termMod_cast_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast.lean#L159-L193","name":"Std.Tactic.NormCast.derive","line":159,"kind":"def","docLink":"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.derive","doc":"The core simplification routine of `normCast`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.derive\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">derive</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast.lean#L149-L154","name":"Std.Tactic.NormCast.numeralToCoe","line":149,"kind":"def","docLink":"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.numeralToCoe","doc":"If possible, rewrite `(n : α)` to `(Nat.cast n : α)` where `n` is a numeral and `α ≠ ℕ`.\nReturns a pair of the new expression and proof that they are equal.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.numeralToCoe\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">numeralToCoe</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast.lean#L138-L143","name":"Std.Tactic.NormCast.upwardAndElim","line":138,"kind":"def","docLink":"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.upwardAndElim","doc":"Core rewriting function used in the \"squash\" step, which moves casts upwards\nand eliminates them.\n\nIt tries to rewrite an expression using the elim and move lemmas.\nOn failure, it calls the splitting procedure heuristic.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.upwardAndElim\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">upwardAndElim</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(up : <a href=\"./Lean/Meta/Tactic/Simp/SimpTheorems.html#Lean.Meta.SimpTheorems\">Lean.Meta.SimpTheorems</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.SimpM\">Lean.Meta.SimpM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Step\">Lean.Meta.Simp.Step</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast.lean#L127-L129","name":"Std.Tactic.NormCast.prove","line":127,"kind":"def","docLink":"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.prove","doc":"Discharging function used during simplification in the \"squash\" step.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.prove\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">prove</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.SimpM\">Lean.Meta.SimpM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast.lean#L76-L120","name":"Std.Tactic.NormCast.splittingProcedure","line":76,"kind":"def","docLink":"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.splittingProcedure","doc":"This is the main heuristic used alongside the elim and move lemmas.\nThe goal is to help casts move past operators by adding intermediate casts.\nAn expression of the shape: op (↑(x : α) : γ) (↑(y : β) : γ)\nis rewritten to:            op (↑(↑(x : α) : β) : γ) (↑(y : β) : γ)\nwhen (↑(↑(x : α) : β) : γ) = (↑(x : α) : γ) can be proven with a squash lemma\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.splittingProcedure\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">splittingProcedure</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(expr : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast.lean#L60-L67","name":"Std.Tactic.NormCast.isNumeral?","line":60,"kind":"def","docLink":"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.isNumeral?","doc":"Check if an expression is a numeral in some type,\nand if so return that type and the natural number.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.isNumeral?\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">isNumeral?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast.lean#L49-L54","name":"Std.Tactic.NormCast.isCoeOf?","line":49,"kind":"def","docLink":"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.isCoeOf?","doc":"Check if an expression is the coercion of some other expression,\nand if so return that expression.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.isCoeOf?\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">isCoeOf?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast.lean#L41-L43","name":"Std.Tactic.NormCast.mkCoe","line":41,"kind":"def","docLink":"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.mkCoe","doc":"Construct the expression `(e : ty)`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.mkCoe\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">mkCoe</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ty : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast.lean#L36-L38","name":"Std.Tactic.NormCast.proveEqUsingDown","line":36,"kind":"def","docLink":"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.proveEqUsingDown","doc":"Prove `a = b` by simplifying using move and squash lemmas. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.proveEqUsingDown\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">proveEqUsingDown</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(a : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast.lean#L25-L33","name":"Std.Tactic.NormCast.proveEqUsing","line":25,"kind":"def","docLink":"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.proveEqUsing","doc":"Prove `a = b` using the given simp set. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast.html#Std.Tactic.NormCast.proveEqUsing\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">proveEqUsing</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <a href=\"./Lean/Meta/Tactic/Simp/SimpTheorems.html#Lean.Meta.SimpTheorems\">Lean.Meta.SimpTheorems</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span>)</span></span></div></div>"}]}