{"name":"Std.Tactic.NormCast.Ext","instances":[{"typeNames":["Eq"],"name":"Std.Tactic.NormCast.instDecidableEqLabel","className":"Decidable"},{"typeNames":["Std.Tactic.NormCast.Label"],"name":"Std.Tactic.NormCast.instReprLabel","className":"Repr"},{"typeNames":["Std.Tactic.NormCast.Label"],"name":"Std.Tactic.NormCast.instInhabitedLabel","className":"Inhabited"},{"typeNames":["Std.Tactic.NormCast.NormCastExtension"],"name":"Std.Tactic.NormCast.instInhabitedNormCastExtension","className":"Inhabited"}],"imports":["Init","Lean.Meta.CongrTheorems","Lean.Meta.Tactic.Simp.SimpTheorems","Std.Tactic.CoeExt"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast/Ext.lean#L157-L205","name":"Std.Tactic.NormCast.Attr.norm_cast","line":157,"kind":"def","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.Attr.norm_cast","doc":"The `norm_cast` attribute should be given to lemmas that describe the\nbehaviour of a coercion in regard to an operator, a relation, or a particular\nfunction.\n\nIt only concerns equality or iff lemmas involving `↑`, `⇑` and `↥`, describing the behavior of\nthe coercion functions.\nIt does not apply to the explicit functions that define the coercions.\n\nExamples:\n```lean\n@[norm_cast] theorem coe_nat_inj' {m n : ℕ} : (↑m : ℤ) = ↑n ↔ m = n\n\n@[norm_cast] theorem coe_int_denom (n : ℤ) : (n : ℚ).denom = 1\n\n@[norm_cast] theorem cast_id : ∀ n : ℚ, ↑n = n\n\n@[norm_cast] theorem coe_nat_add (m n : ℕ) : (↑(m + n) : ℤ) = ↑m + ↑n\n\n@[norm_cast] theorem cast_coe_nat (n : ℕ) : ((n : ℤ) : α) = n\n\n@[norm_cast] theorem cast_one : ((1 : ℚ) : α) = 1\n```\n\nLemmas tagged with `@[norm_cast]` are classified into three categories: `move`, `elim`, and\n`squash`. They are classified roughly as follows:\n\n* elim lemma:   LHS has 0 head coes and ≥ 1 internal coe\n* move lemma:   LHS has 1 head coe and 0 internal coes,    RHS has 0 head coes and ≥ 1 internal coes\n* squash lemma: LHS has ≥ 1 head coes and 0 internal coes, RHS has fewer head coes\n\n`norm_cast` uses `move` and `elim` lemmas to factor coercions toward the root of an expression\nand to cancel them from both sides of an equation or relation. It uses `squash` lemmas to clean\nup the result.\n\nOccasionally you may want to override the automatic classification.\nYou can do this by giving an optional `elim`, `move`, or `squash` parameter to the attribute.\n\n```lean\n@[simp, norm_cast elim] lemma nat_cast_re (n : ℕ) : (n : ℂ).re = n := by\n  rw [← of_real_nat_cast, of_real_re]\n```\n\nDon't do this unless you understand what you are doing.\n\nA full description of the tactic, and the use of each lemma category, can be found at\n<https://lean-forward.github.io/norm_cast/norm_cast.pdf>.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.Attr.norm_cast\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">Attr</span>.<span class=\"name\">norm_cast</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast/Ext.lean#L153-L154","name":"Std.Tactic.NormCast.Attr.normCastLabel","line":153,"kind":"def","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.Attr.normCastLabel","doc":"The possible `norm_cast` kinds: `elim`, `move`, or `squash`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.Attr.normCastLabel\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">Attr</span>.<span class=\"name\">normCastLabel</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast/Ext.lean#L144-L150","name":"Std.Tactic.NormCast.addInfer","line":144,"kind":"def","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.addInfer","doc":"`addInfer decl` infers the label of `decl` and adds it to the cache.\n\n* elim lemma:   LHS has 0 head coes and ≥ 1 internal coe\n* move lemma:   LHS has 1 head coe and 0 internal coes,    RHS has 0 head coes and ≥ 1 internal coes\n* squash lemma: LHS has ≥ 1 head coes and 0 internal coes, RHS has fewer head coes\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.addInfer\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">addInfer</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(decl : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(kind : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Lean/Attributes.html#Lean.AttributeKind\">Lean.AttributeKind</a> <a href=\"./Lean/Attributes.html#Lean.AttributeKind.global\">Lean.AttributeKind.global</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prio : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <span class=\"fn\">1000</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast/Ext.lean#L132-L136","name":"Std.Tactic.NormCast.addSquash","line":132,"kind":"def","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.addSquash","doc":"`addSquash decl` adds `decl` as a `squash` lemma to the cache. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.addSquash\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">addSquash</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(decl : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(kind : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Lean/Attributes.html#Lean.AttributeKind\">Lean.AttributeKind</a> <a href=\"./Lean/Attributes.html#Lean.AttributeKind.global\">Lean.AttributeKind.global</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prio : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <span class=\"fn\">1000</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast/Ext.lean#L125-L129","name":"Std.Tactic.NormCast.addMove","line":125,"kind":"def","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.addMove","doc":"`addMove decl` adds `decl` as a `move` lemma to the cache. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.addMove\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">addMove</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(decl : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(kind : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Lean/Attributes.html#Lean.AttributeKind\">Lean.AttributeKind</a> <a href=\"./Lean/Attributes.html#Lean.AttributeKind.global\">Lean.AttributeKind.global</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prio : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <span class=\"fn\">1000</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast/Ext.lean#L120-L122","name":"Std.Tactic.NormCast.addElim","line":120,"kind":"def","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.addElim","doc":"`addElim decl` adds `decl` as an `elim` lemma to the cache. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.addElim\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">addElim</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(decl : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(kind : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Lean/Attributes.html#Lean.AttributeKind\">Lean.AttributeKind</a> <a href=\"./Lean/Attributes.html#Lean.AttributeKind.global\">Lean.AttributeKind.global</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prio : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <span class=\"fn\">1000</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast/Ext.lean#L112-L117","name":"Std.Tactic.NormCast.normCastExt","line":112,"kind":"opaque","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.normCastExt","doc":"The `norm_cast` extension data. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.normCastExt\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">normCastExt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.NormCastExtension\">Std.Tactic.NormCast.NormCastExtension</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast/Ext.lean#L110-L110","name":"Std.Tactic.NormCast.instInhabitedNormCastExtension","line":110,"kind":"instance","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.instInhabitedNormCastExtension","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.instInhabitedNormCastExtension\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">instInhabitedNormCastExtension</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.NormCastExtension\">Std.Tactic.NormCast.NormCastExtension</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast/Ext.lean#L109-L109","name":"Std.Tactic.NormCast.NormCastExtension.squash","line":109,"kind":"def","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.NormCastExtension.squash","doc":"A simp set which simplifies transitive coercions. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.NormCastExtension.squash\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">NormCastExtension</span>.<span class=\"name\">squash</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.NormCastExtension\">Std.Tactic.NormCast.NormCastExtension</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/SimpTheorems.html#Lean.Meta.SimpExtension\">Lean.Meta.SimpExtension</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast/Ext.lean#L107-L107","name":"Std.Tactic.NormCast.NormCastExtension.down","line":107,"kind":"def","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.NormCastExtension.down","doc":"A simp set which pushes coercion arrows to the leaves. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.NormCastExtension.down\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">NormCastExtension</span>.<span class=\"name\">down</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.NormCastExtension\">Std.Tactic.NormCast.NormCastExtension</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/SimpTheorems.html#Lean.Meta.SimpExtension\">Lean.Meta.SimpExtension</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast/Ext.lean#L105-L105","name":"Std.Tactic.NormCast.NormCastExtension.up","line":105,"kind":"def","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.NormCastExtension.up","doc":"A simp set which lifts coercion arrows to the top level. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.NormCastExtension.up\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">NormCastExtension</span>.<span class=\"name\">up</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.NormCastExtension\">Std.Tactic.NormCast.NormCastExtension</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/SimpTheorems.html#Lean.Meta.SimpExtension\">Lean.Meta.SimpExtension</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast/Ext.lean#L103-L103","name":"Std.Tactic.NormCast.NormCastExtension.mk","line":103,"kind":"ctor","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.NormCastExtension.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.NormCastExtension.mk\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">NormCastExtension</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(up : <a href=\"./Lean/Meta/Tactic/Simp/SimpTheorems.html#Lean.Meta.SimpExtension\">Lean.Meta.SimpExtension</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(down : <a href=\"./Lean/Meta/Tactic/Simp/SimpTheorems.html#Lean.Meta.SimpExtension\">Lean.Meta.SimpExtension</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(squash : <a href=\"./Lean/Meta/Tactic/Simp/SimpTheorems.html#Lean.Meta.SimpExtension\">Lean.Meta.SimpExtension</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.NormCastExtension\">Std.Tactic.NormCast.NormCastExtension</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast/Ext.lean#L103-L110","name":"Std.Tactic.NormCast.NormCastExtension","line":103,"kind":"structure","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.NormCastExtension","doc":"The `norm_cast` attribute stores three simp sets. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.NormCastExtension\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">NormCastExtension</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast/Ext.lean#L96-L100","name":"Std.Tactic.NormCast.pushCastExt","line":96,"kind":"opaque","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.pushCastExt","doc":"The `push_cast` simp attribute. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.pushCastExt\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">pushCastExt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/SimpTheorems.html#Lean.Meta.SimpExtension\">Lean.Meta.SimpExtension</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast/Ext.lean#L67-L94","name":"Std.Tactic.NormCast.classifyType","line":67,"kind":"def","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.classifyType","doc":"Classifies a declaration of type `ty` as a `norm_cast` rule. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.classifyType\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">classifyType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ty : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.Label\">Std.Tactic.NormCast.Label</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast/Ext.lean#L63-L64","name":"Std.Tactic.NormCast.countInternalCoes","line":63,"kind":"def","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.countInternalCoes","doc":"Count how many coercions are inside the expression, excluding the top ones. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.countInternalCoes\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">countInternalCoes</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast/Ext.lean#L51-L60","name":"Std.Tactic.NormCast.countCoes","line":51,"kind":"opaque","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.countCoes","doc":"Count how many coercions are inside the expression, including the top ones. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.countCoes\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">countCoes</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast/Ext.lean#L43-L48","name":"Std.Tactic.NormCast.countHeadCoes","line":43,"kind":"opaque","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.countHeadCoes","doc":"Count how many coercions are at the top of the expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.countHeadCoes\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">countHeadCoes</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast/Ext.lean#L32-L40","name":"Std.Tactic.NormCast.getSimpArgs","line":32,"kind":"def","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.getSimpArgs","doc":"Assuming `e` is an application, returns the list of subterms that `simp` will rewrite in. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.getSimpArgs\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">getSimpArgs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast/Ext.lean#L29-L29","name":"Std.Tactic.NormCast.instInhabitedLabel","line":29,"kind":"instance","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.instInhabitedLabel","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.instInhabitedLabel\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">instInhabitedLabel</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.Label\">Std.Tactic.NormCast.Label</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast/Ext.lean#L29-L29","name":"Std.Tactic.NormCast.instReprLabel","line":29,"kind":"instance","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.instReprLabel","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.instReprLabel\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">instReprLabel</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <a href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.Label\">Std.Tactic.NormCast.Label</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast/Ext.lean#L29-L29","name":"Std.Tactic.NormCast.instDecidableEqLabel","line":29,"kind":"instance","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.instDecidableEqLabel","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.instDecidableEqLabel\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">instDecidableEqLabel</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <a href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.Label\">Std.Tactic.NormCast.Label</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast/Ext.lean#L27-L28","name":"Std.Tactic.NormCast.Label.squash","line":27,"kind":"ctor","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.Label.squash","doc":"squash lemma: LHS has ≥ 1 head coes and 0 internal coes, RHS has fewer head coes "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.Label.squash\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">Label</span>.<span class=\"name\">squash</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.Label\">Std.Tactic.NormCast.Label</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast/Ext.lean#L24-L26","name":"Std.Tactic.NormCast.Label.move","line":24,"kind":"ctor","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.Label.move","doc":"move lemma: LHS has 1 head coe and 0 internal coes,\nRHS has 0 head coes and ≥ 1 internal coes "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.Label.move\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">Label</span>.<span class=\"name\">move</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.Label\">Std.Tactic.NormCast.Label</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast/Ext.lean#L22-L23","name":"Std.Tactic.NormCast.Label.elim","line":22,"kind":"ctor","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.Label.elim","doc":"elim lemma: LHS has 0 head coes and ≥ 1 internal coe "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.Label.elim\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">Label</span>.<span class=\"name\">elim</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.Label\">Std.Tactic.NormCast.Label</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NormCast/Ext.lean#L21-L29","name":"Std.Tactic.NormCast.Label","line":21,"kind":"inductive","docLink":"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.Label","doc":"`Label` is a type used to classify `norm_cast` lemmas.\n* elim lemma:   LHS has 0 head coes and ≥ 1 internal coe\n* move lemma:   LHS has 1 head coe and 0 internal coes,    RHS has 0 head coes and ≥ 1 internal coes\n* squash lemma: LHS has ≥ 1 head coes and 0 internal coes, RHS has fewer head coes\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NormCast/Ext.html#Std.Tactic.NormCast.Label\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">NormCast</span>.<span class=\"name\">Label</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"}]}