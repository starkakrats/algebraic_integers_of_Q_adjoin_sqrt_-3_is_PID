{"name":"Mathlib.Tactic.ReduceModChar","instances":[{"typeNames":["Tactic.ReduceModChar.TypeToCharPResult"],"name":"Tactic.ReduceModChar.instInhabitedTypeToCharPResult","className":"Inhabited"}],"imports":["Init","Mathlib.Data.ZMod.Basic","Mathlib.RingTheory.Polynomial.Basic","Mathlib.Tactic.NormNum.DivMod","Mathlib.Tactic.ReduceModChar.Ext"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ReduceModChar.lean#L235-L251","name":"Tactic.ReduceModChar.reduce_mod_char","line":235,"kind":"def","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.reduce_mod_char","doc":"The tactic `reduce_mod_char` looks for numeric expressions in characteristic `p`\nand reduces these to lie between `0` and `p`.\n\nFor example:\n```\nexample : (5 : ZMod 4) = 1 := by reduce_mod_char\nexample : (X ^ 2 - 3 * X + 4 : (ZMod 4)[X]) = X ^ 2 + X := by reduce_mod_char\n```\n\nIt also handles negation, turning it into multiplication by `p - 1`,\nand similarly subtraction.\n\nThis tactic uses the type of the subexpression to figure out if it is indeed of positive\ncharacteristic, for improved performance compared to trying to synthesise a `CharP` instance.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.reduce_mod_char\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">reduce_mod_char</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ReduceModChar.lean#L227-L231","name":"Tactic.ReduceModChar.reduceModCharHyp","line":227,"kind":"def","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.reduceModCharHyp","doc":"Reduce all numeric subexpressions of the given hypothesis modulo their characteristic. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.reduceModCharHyp\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">reduceModCharHyp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(fvarId : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ReduceModChar.lean#L214-L224","name":"Tactic.ReduceModChar.reduceModCharTarget","line":214,"kind":"def","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.reduceModCharTarget","doc":"Reduce all numeric subexpressions of the goal modulo their characteristic. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.reduceModCharTarget\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">reduceModCharTarget</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ReduceModChar.lean#L181-L211","name":"Tactic.ReduceModChar.derive","line":181,"kind":"def","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.derive","doc":"Reduce all numeric subexpressions of `e` modulo their characteristic. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.derive\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">derive</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ReduceModChar.lean#L155-L173","name":"Tactic.ReduceModChar.matchAndNorm","line":155,"kind":"def","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.matchAndNorm","doc":"Given an expression `e`, determine whether it is a numeric expression in characteristic `n`,\nand if so, reduce `e` modulo `n`.\n\nThis is not a `norm_num` plugin because it does not match on the syntax of `e`,\nrather it matches on the type of `e`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.matchAndNorm\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">matchAndNorm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ReduceModChar.lean#L137-L147","name":"Tactic.ReduceModChar.typeToCharP","line":137,"kind":"opaque","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.typeToCharP","doc":"Determine the characteristic of a ring from the type.\nThis should be fast, so this pattern-matches on the type, rather than searching for a\n`CharP` instance. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.typeToCharP\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">typeToCharP</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{u : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.TypeToCharPResult\">Tactic.ReduceModChar.TypeToCharPResult</a> <span class=\"fn\">t</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ReduceModChar.lean#L132-L132","name":"Tactic.ReduceModChar.instInhabitedTypeToCharPResult","line":132,"kind":"instance","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.instInhabitedTypeToCharPResult","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.instInhabitedTypeToCharPResult\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">instInhabitedTypeToCharPResult</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">{<span class=\"fn\">a</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>} → <span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> a)</span>} → <span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.TypeToCharPResult\">Tactic.ReduceModChar.TypeToCharPResult</a> <span class=\"fn\">α</span></span>)</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ReduceModChar.lean#L130-L130","name":"Tactic.ReduceModChar.TypeToCharPResult.failure","line":130,"kind":"ctor","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.TypeToCharPResult.failure","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.TypeToCharPResult.failure\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">TypeToCharPResult</span>.<span class=\"name\">failure</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{u : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.TypeToCharPResult\">Tactic.ReduceModChar.TypeToCharPResult</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ReduceModChar.lean#L129-L129","name":"Tactic.ReduceModChar.TypeToCharPResult.intLike","line":129,"kind":"ctor","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.TypeToCharPResult.intLike","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.TypeToCharPResult.intLike\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">TypeToCharPResult</span>.<span class=\"name\">intLike</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{u : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(instRing : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(instCharP : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/CharP/Basic.html#CharP\">CharP</a> <span class=\"fn\">«$α»</span> <span class=\"fn\">«$n»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.TypeToCharPResult\">Tactic.ReduceModChar.TypeToCharPResult</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ReduceModChar.lean#L128-L130","name":"Tactic.ReduceModChar.TypeToCharPResult","line":128,"kind":"inductive","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.TypeToCharPResult","doc":"A `TypeToCharPResult α` indicates if `α` can be determined to be a ring of characteristic `p`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.TypeToCharPResult\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">TypeToCharPResult</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{u : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(α : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ReduceModChar.lean#L108-L124","name":"Tactic.ReduceModChar.normNegCoeffMul","line":108,"kind":"def","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.normNegCoeffMul","doc":"Given an expression `-(a * b) : t` such that `t` is a ring of characteristic `n`,\nand `a` is a numeral, simplify this to `((n - 1) * a) * b`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.normNegCoeffMul\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">normNegCoeffMul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{u : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(_instRing : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(instCharP : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/CharP/Basic.html#CharP\">CharP</a> <span class=\"fn\">«$α»</span> <span class=\"fn\">«$n»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ReduceModChar.lean#L99-L103","name":"Tactic.ReduceModChar.CharP.neg_mul_eq_sub_one_mul","line":99,"kind":"theorem","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.CharP.neg_mul_eq_sub_one_mul","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.CharP.neg_mul_eq_sub_one_mul\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">CharP</span>.<span class=\"name\">neg_mul_eq_sub_one_mul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(inst : <span class=\"fn\"><a href=\"./Mathlib/Algebra/CharP/Basic.html#CharP\">CharP</a> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(na : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(na' : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(p : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Mathlib.Meta.NormNum.IsNat</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">1</span></span>)</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a</span></span>)</span> <span class=\"fn\">na</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(pa : <span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">na</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">na'</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">na'</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ReduceModChar.lean#L83-L97","name":"Tactic.ReduceModChar.normNeg","line":83,"kind":"def","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.normNeg","doc":"Given an expression `(-e) : t` such that `t` is a ring of characteristic `n`,\nsimplify this to `(n - 1) * e`.\n\nThis should be called only when `normIntNumeral` fails, because `normIntNumeral` would otherwise\nbe more useful by evaluating `-e` mod `n` to an actual numeral.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.normNeg\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">normNeg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{u : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(_instRing : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(instCharP : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/CharP/Basic.html#CharP\">CharP</a> <span class=\"fn\">«$α»</span> <span class=\"fn\">«$n»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ReduceModChar.lean#L70-L74","name":"Tactic.ReduceModChar.CharP.neg_eq_sub_one_mul","line":70,"kind":"theorem","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.CharP.neg_eq_sub_one_mul","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.CharP.neg_eq_sub_one_mul\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">CharP</span>.<span class=\"name\">neg_eq_sub_one_mul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(inst : <span class=\"fn\"><a href=\"./Mathlib/Algebra/CharP/Basic.html#CharP\">CharP</a> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a' : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(p : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Mathlib.Meta.NormNum.IsNat</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">1</span></span>)</span> <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(pa : <span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">a'</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ReduceModChar.lean#L61-L68","name":"Tactic.ReduceModChar.normIntNumeral","line":61,"kind":"def","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.normIntNumeral","doc":"Given an integral expression `e : t` such that `t` is a ring of characteristic `n`,\nreduce `e` modulo `n`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.normIntNumeral\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">normIntNumeral</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{u : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(n : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(instRing : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(instCharP : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/CharP/Basic.html#CharP\">CharP</a> <span class=\"fn\">«$α»</span> <span class=\"fn\">«$n»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Mathlib.Meta.NormNum.Result</a> <span class=\"fn\">e</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ReduceModChar.lean#L55-L57","name":"Tactic.ReduceModChar.CharP.isInt_of_mod","line":55,"kind":"theorem","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.CharP.isInt_of_mod","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.CharP.isInt_of_mod\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">CharP</span>.<span class=\"name\">isInt_of_mod</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{e' : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{r : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n' : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(inst : <span class=\"fn\"><a href=\"./Mathlib/Algebra/CharP/Basic.html#CharP\">CharP</a> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{e : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(he : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">Mathlib.Meta.NormNum.IsInt</a> <span class=\"fn\">e</span> <span class=\"fn\">e'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hn : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Mathlib.Meta.NormNum.IsNat</a> <span class=\"fn\">n</span> <span class=\"fn\">n'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h₂ : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">Mathlib.Meta.NormNum.IsInt</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">e'</span> <a href=\"./Init/Prelude.html#HMod.hMod\">%</a> <span class=\"fn\">↑<span class=\"fn\">n'</span></span></span>)</span> <span class=\"fn\">r</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">Mathlib.Meta.NormNum.IsInt</a> <span class=\"fn\">e</span> <span class=\"fn\">r</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ReduceModChar.lean#L49-L53","name":"Tactic.ReduceModChar.CharP.cast_int_eq_mod","line":49,"kind":"theorem","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.CharP.cast_int_eq_mod","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.CharP.cast_int_eq_mod\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">CharP</span>.<span class=\"name\">cast_int_eq_mod</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(R : <a href=\"./foundational_types.html\">Type</a> u_1)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/CharP/Basic.html#CharP\">CharP</a> <span class=\"fn\">R</span> <span class=\"fn\">p</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(k : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">↑<span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#HMod.hMod\">%</a> <span class=\"fn\">↑<span class=\"fn\">p</span></span></span>)</span></span></span></div></div>"}]}