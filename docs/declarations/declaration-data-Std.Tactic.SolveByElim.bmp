{"name":"Std.Tactic.SolveByElim","instances":[{"typeNames":["Std.Tactic.SolveByElim.Config","Std.Tactic.BacktrackConfig"],"name":"Std.Tactic.SolveByElim.instCoeConfigBacktrackConfig","className":"Coe"}],"imports":["Init","Std.Data.Sum.Basic","Std.Tactic.LabelAttr","Std.Tactic.Relation.Symm","Std.Tactic.SolveByElim.Backtrack"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L510-L533","name":"Std.Tactic.SolveByElim.applyRulesSyntax","line":510,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.applyRulesSyntax","doc":"`apply_rules [l₁, l₂, ...]` tries to solve the main goal by iteratively\napplying the list of lemmas `[l₁, l₂, ...]` or by applying a local hypothesis.\nIf `apply` generates new goals, `apply_rules` iteratively tries to solve those goals.\nYou can use `apply_rules [-h]` to omit a local hypothesis.\n\n`apply_rules` will also use `rfl`, `trivial`, `congrFun` and `congrArg`.\nThese can be disabled, as can local hypotheses, by using `apply_rules only [...]`.\n\nYou can use `apply_rules using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...})`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n\n`apply_rules` will try calling `symm` on hypotheses and `exfalso` on the goal as needed.\nThis can be disabled with `apply_rules (config := {symm := false, exfalso := false})`.\n\nYou can bound the iteration depth using the syntax `apply_rules (config := {maxDepth := n})`.\n\nUnlike `solve_by_elim`, `apply_rules` does not perform backtracking, and greedily applies\na lemma from the list until it gets stuck.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.applyRulesSyntax\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">applyRulesSyntax</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L477-L498","name":"Std.Tactic.SolveByElim.applyAssumptionSyntax","line":477,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.applyAssumptionSyntax","doc":"`apply_assumption` looks for an assumption of the form `... → ∀ _, ... → head`\nwhere `head` matches the current goal.\n\nYou can specify additional rules to apply using `apply_assumption [...]`.\nBy default `apply_assumption` will also try `rfl`, `trivial`, `congrFun`, and `congrArg`.\nIf you don't want these, or don't want to use all hypotheses, use `apply_assumption only [...]`.\nYou can use `apply_assumption [-h]` to omit a local hypothesis.\nYou can use `apply_assumption using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`apply_assumption` will use consequences of local hypotheses obtained via `symm`.\n\nIf `apply_assumption` fails, it will call `exfalso` and try again.\nThus if there is an assumption of the form `P → ¬ Q`, the new tactic state\nwill have two goals, `P` and `Q`.\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...}) lemmas`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.applyAssumptionSyntax\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">applyAssumptionSyntax</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L457-L462","name":"Std.Tactic.SolveByElim.solveByElim.processSyntax","line":457,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.solveByElim.processSyntax","doc":"Wrapper for `solveByElim` that processes a list of `Term`s\nthat specify the lemmas to use. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.solveByElim.processSyntax\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">solveByElim</span>.<span class=\"name\">processSyntax</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cfg : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config\">Std.Tactic.SolveByElim.Config</a>\n  <span class=\"fn\">{\n    <span class=\"fn\">toApplyRulesConfig</span> :=\n      <span class=\"fn\">{\n        <span class=\"fn\">toBacktrackConfig</span> :=\n          <span class=\"fn\">{ <span class=\"fn\">maxDepth</span> := <span class=\"fn\">6</span>, <span class=\"fn\">proc</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> x : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <span class=\"fn\">none</span></span></span>,\n            <span class=\"fn\">suspend</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span></span>, <span class=\"fn\">discharge</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>) =&gt; <span class=\"fn\">failure</span></span>,\n            <span class=\"fn\">commitIndependentGoals</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a> }</span>,\n        <span class=\"fn\">toApplyConfig</span> :=\n          <span class=\"fn\">{ <span class=\"fn\">newGoals</span> := <a href=\"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals.nonDependentFirst\">Lean.Meta.ApplyNewGoals.nonDependentFirst</a>, <span class=\"fn\">synthAssignedInstances</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>,\n            <span class=\"fn\">allowSynthFailures</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>, <span class=\"fn\">approx</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span>,\n        <span class=\"fn\">transparency</span> := <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode.default\">Lean.Meta.TransparencyMode.default</a>, <span class=\"fn\">symm</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">exfalso</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span>,\n    <span class=\"fn\">backtracking</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(only : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(star : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(add : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(remove : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(use : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta.html#Lean.Syntax.Ident\">Lean.Ident</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(goals : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L415-L453","name":"Std.Tactic.SolveByElim.solveByElimSyntax","line":415,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.solveByElimSyntax","doc":"`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches\nand then repeatedly calls `apply` on the generated subgoals until no subgoals remain,\nperforming at most `maxDepth` (defaults to 6) recursive steps.\n\n`solve_by_elim` discharges the current goal or fails.\n\n`solve_by_elim` performs backtracking if subgoals can not be solved.\n\nBy default, the assumptions passed to `apply` are the local context, `rfl`, `trivial`,\n`congrFun` and `congrArg`.\n\nThe assumptions can be modified with similar syntax as for `simp`:\n* `solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the given expressions.\n* `solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context,\n  `rfl`, `trivial`, `congrFun`, or `congrArg` unless they are explicitly included.\n* `solve_by_elim [-h₁, ... -hₙ]` removes the given local hypotheses.\n* `solve_by_elim using [a₁, ...]` uses all lemmas which have been labelled\n  with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal\nmakes other goals impossible.\n(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)\n\nOptional arguments passed via a configuration argument as `solve_by_elim (config := { ... })`\n- `maxDepth`: number of attempts at discharging generated subgoals\n- `symm`: adds all hypotheses derived by `symm` (defaults to `true`).\n- `exfalso`: allow calling `exfalso` and trying again if `solve_by_elim` fails\n  (defaults to `true`).\n- `transparency`: change the transparency mode when calling `apply`. Defaults to `.default`,\n  but it is often useful to change to `.reducible`,\n  so semireducible definitions will not be unfolded when trying to apply a lemma.\n\nSee also the doc-comment for `Std.Tactic.BacktrackConfig` for the options\n`proc`, `suspend`, and `discharge` which allow further customization of `solve_by_elim`.\nBoth `apply_assumption` and `apply_rules` are implemented via these hooks.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.solveByElimSyntax\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">solveByElimSyntax</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L408-L413","name":"Std.Tactic.SolveByElim.parseUsing","line":408,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.parseUsing","doc":"Parse the `using ...` argument for `solve_by_elim`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.parseUsing\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">parseUsing</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Std.Tactic.SolveByElim.using_</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta.html#Lean.Syntax.Ident\">Lean.Ident</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L390-L405","name":"Std.Tactic.SolveByElim.parseArgs","line":390,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.parseArgs","doc":"Parse the lemma argument of a call to `solve_by_elim`.\nThe first component should be true if `*` appears at least once.\nThe second component should contain each term `t`in the arguments.\nThe third component should contain `t` for each `-t` in the arguments.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.parseArgs\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">parseArgs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Std.Tactic.SolveByElim.args</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L379-L380","name":"Std.Tactic.SolveByElim.using_","line":379,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.using_","doc":"Syntax for using all lemmas labelled with an attribute in `solve_by_elim`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.using_\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">using_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L377-L378","name":"Std.Tactic.SolveByElim.args","line":377,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.args","doc":"Syntax for adding and removing terms in `solve_by_elim`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.args\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">args</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L375-L376","name":"Std.Tactic.SolveByElim.arg","line":375,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.arg","doc":"Syntax for adding or removing a term, or `*`, in `solve_by_elim`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.arg\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">arg</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L373-L374","name":"Std.Tactic.SolveByElim.star","line":373,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.star","doc":"Syntax for including all local hypotheses in `solve_by_elim`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.star\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">star</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L371-L372","name":"Std.Tactic.SolveByElim.erase","line":371,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.erase","doc":"Syntax for omitting a local hypothesis in `solve_by_elim`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.erase\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">erase</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L369-L369","name":"Std.Tactic.SolveByElim.mkAssumptionSet.elab'","line":369,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.mkAssumptionSet.elab'","doc":"Run `elabTerm`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.mkAssumptionSet.elab'\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">mkAssumptionSet</span>.<span class=\"name\">elab'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(t : <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L345-L369","name":"Std.Tactic.SolveByElim.mkAssumptionSet","line":345,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.mkAssumptionSet","doc":"`mkAssumptionSet` builds a collection of lemmas for use in\nthe backtracking search in `solve_by_elim`.\n\n* By default, it includes all local hypotheses, along with `rfl`, `trivial`, `congrFun`\n  and `congrArg`.\n* The flag `noDefaults` removes these.\n* The flag `star` includes all local hypotheses, but not `rfl`, `trivial`, `congrFun`,\n  or `congrArg`. (It doesn't make sense to use `star` without `noDefaults`.)\n* The argument `add` is the list of terms inside the square brackets that did not have `-`\n  and can be used to add expressions or local hypotheses\n* The argument `remove` is the list of terms inside the square brackets that had a `-`,\n  and can be used to remove local hypotheses.\n  (It doesn't make sense to remove expressions which are not local hypotheses,\n  to remove local hypotheses unless `!noDefaults || star`,\n  and it does not make sense to use `star` unless you remove at least one local hypothesis.)\n\n`mkAssumptionSet` returns not a `List expr`, but a `List (TermElabM Expr) × TermElabM (List Expr)`.\nThere are two separate problems that need to be solved.\n\n### Stuck metavariables\n\nLemmas with implicit arguments would be filled in with metavariables if we created the\n`Expr` objects immediately, so instead we return thunks that generate the expressions\non demand. This is the first component, with type `List (TermElabM expr)`.\n\nAs an example, we have `def rfl : ∀ {α : Sort u} {a : α}, a = a`, which on elaboration will become\n`@rfl ?m_1 ?m_2`.\n\nBecause `solve_by_elim` works by repeated application of lemmas against subgoals,\nthe first time such a lemma is successfully applied,\nthose metavariables will be unified, and thereafter have fixed values.\nThis would make it impossible to apply the lemma\na second time with different values of the metavariables.\n\nSee https://github.com/leanprover-community/mathlib/issues/2269\n\n### Relevant local hypotheses\n\n`solve_by_elim*` works with multiple goals,\nand we need to use separate sets of local hypotheses for each goal.\nThe second component of the returned value provides these local hypotheses.\n(Essentially using `local_context`, along with some filtering to remove hypotheses\nthat have been explicitly removed via `only` or `[-h]`.)\n\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.mkAssumptionSet\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">mkAssumptionSet</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(noDefaults : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(star : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(add : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(remove : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(use : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Meta.html#Lean.Syntax.Ident\">Lean.Ident</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L289-L292","name":"Lean.MVarId.applyRules","line":289,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Lean.MVarId.applyRules","doc":"A `MetaM` analogue of the `apply_rules` user tactic.\n\nWe pass the lemmas as `TermElabM Expr` rather than just `Expr`,\nso they can be generated fresh for each application, to avoid stuck metavariables.\n\nBy default it uses all local hypotheses, but you can disable this with `only := true`.\nIf you need to remove particular local hypotheses, call `solveByElim` directly.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Lean.MVarId.applyRules\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">applyRules</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config\">Std.Tactic.SolveByElim.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(lemmas : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(only : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L274-L278","name":"Std.Tactic.SolveByElim.solveByElim.run","line":274,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.solveByElim.run","doc":"Run either backtracking search, or repeated application, on the list of goals. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.solveByElim.run\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">solveByElim</span>.<span class=\"name\">run</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config\">Std.Tactic.SolveByElim.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(lemmas : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ctx : <span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L259-L278","name":"Std.Tactic.SolveByElim.solveByElim","line":259,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.solveByElim","doc":"Solve a collection of goals by repeatedly applying lemmas, backtracking as necessary.\n\nArguments:\n* `cfg : Config` additional configuration options\n  (options for `apply`, maximum depth, and custom flow control)\n* `lemmas : List (TermElabM Expr)` lemmas to apply.\n  These are thunks in `TermElabM` to avoid stuck metavariables.\n* `ctx : TermElabM (List Expr)` monadic function returning the local hypotheses to use.\n* `goals : List MVarId` the initial list of goals for `solveByElim`\n\nReturns a list of suspended goals, if it succeeded on all other subgoals.\nBy default `cfg.suspend` is `false,` `cfg.discharge` fails, and `cfg.failAtMaxDepth` is `true`,\nand so the returned list is always empty.\nCustom wrappers (e.g. `apply_assumption` and `apply_rules`) may modify this behaviour.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.solveByElim\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">solveByElim</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config\">Std.Tactic.SolveByElim.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(lemmas : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ctx : <span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(goals : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L235-L241","name":"Std.Tactic.SolveByElim.applyFirstLemma","line":235,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.applyFirstLemma","doc":"Applies the first possible lemma to the goal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.applyFirstLemma\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">applyFirstLemma</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config\">Std.Tactic.SolveByElim.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(lemmas : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ctx : <span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L226-L232","name":"Std.Tactic.SolveByElim.applyLemmas","line":226,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.applyLemmas","doc":"Returns the list of tactics corresponding to applying the available lemmas to the goal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.applyLemmas\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">applyLemmas</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config\">Std.Tactic.SolveByElim.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(lemmas : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ctx : <span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Control/Nondet/Basic.html#Nondet\">Nondet</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L221-L223","name":"Std.Tactic.SolveByElim.elabContextLemmas","line":221,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.elabContextLemmas","doc":"Elaborate a list of lemmas and local context.\nSee `mkAssumptionSet` for an explanation of why this is needed.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.elabContextLemmas\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">elabContextLemmas</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(lemmas : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ctx : <span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L211-L213","name":"Std.Tactic.SolveByElim.Config.requireUsingAll","line":211,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.requireUsingAll","doc":"Create or modify a `Config` which only accept solutions\nfor which every expression in `use` appears as a subexpression.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.requireUsingAll\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">Config</span>.<span class=\"name\">requireUsingAll</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cfg : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config\">Std.Tactic.SolveByElim.Config</a>\n  <span class=\"fn\">{\n    <span class=\"fn\">toApplyRulesConfig</span> :=\n      <span class=\"fn\">{\n        <span class=\"fn\">toBacktrackConfig</span> :=\n          <span class=\"fn\">{ <span class=\"fn\">maxDepth</span> := <span class=\"fn\">6</span>, <span class=\"fn\">proc</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> x : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <span class=\"fn\">none</span></span></span>,\n            <span class=\"fn\">suspend</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span></span>, <span class=\"fn\">discharge</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>) =&gt; <span class=\"fn\">failure</span></span>,\n            <span class=\"fn\">commitIndependentGoals</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a> }</span>,\n        <span class=\"fn\">toApplyConfig</span> :=\n          <span class=\"fn\">{ <span class=\"fn\">newGoals</span> := <a href=\"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals.nonDependentFirst\">Lean.Meta.ApplyNewGoals.nonDependentFirst</a>, <span class=\"fn\">synthAssignedInstances</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>,\n            <span class=\"fn\">allowSynthFailures</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>, <span class=\"fn\">approx</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span>,\n        <span class=\"fn\">transparency</span> := <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode.default\">Lean.Meta.TransparencyMode.default</a>, <span class=\"fn\">symm</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">exfalso</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span>,\n    <span class=\"fn\">backtracking</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(use : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config\">Std.Tactic.SolveByElim.Config</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L200-L205","name":"Std.Tactic.SolveByElim.Config.testSolutions","line":200,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.testSolutions","doc":"Create or modify a `Config` which rejects complete solutions for which `test`,\napplied to the instantiations of the original goals, fails or returns `false`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.testSolutions\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">Config</span>.<span class=\"name\">testSolutions</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cfg : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config\">Std.Tactic.SolveByElim.Config</a>\n  <span class=\"fn\">{\n    <span class=\"fn\">toApplyRulesConfig</span> :=\n      <span class=\"fn\">{\n        <span class=\"fn\">toBacktrackConfig</span> :=\n          <span class=\"fn\">{ <span class=\"fn\">maxDepth</span> := <span class=\"fn\">6</span>, <span class=\"fn\">proc</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> x : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <span class=\"fn\">none</span></span></span>,\n            <span class=\"fn\">suspend</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span></span>, <span class=\"fn\">discharge</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>) =&gt; <span class=\"fn\">failure</span></span>,\n            <span class=\"fn\">commitIndependentGoals</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a> }</span>,\n        <span class=\"fn\">toApplyConfig</span> :=\n          <span class=\"fn\">{ <span class=\"fn\">newGoals</span> := <a href=\"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals.nonDependentFirst\">Lean.Meta.ApplyNewGoals.nonDependentFirst</a>, <span class=\"fn\">synthAssignedInstances</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>,\n            <span class=\"fn\">allowSynthFailures</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>, <span class=\"fn\">approx</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span>,\n        <span class=\"fn\">transparency</span> := <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode.default\">Lean.Meta.TransparencyMode.default</a>, <span class=\"fn\">symm</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">exfalso</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span>,\n    <span class=\"fn\">backtracking</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(test : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config\">Std.Tactic.SolveByElim.Config</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L190-L194","name":"Std.Tactic.SolveByElim.Config.testPartialSolutions","line":190,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.testPartialSolutions","doc":"Create or modify a `Config` which rejects branches for which `test`,\napplied to the instantiations of the original goals, fails or returns `false`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.testPartialSolutions\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">Config</span>.<span class=\"name\">testPartialSolutions</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cfg : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config\">Std.Tactic.SolveByElim.Config</a>\n  <span class=\"fn\">{\n    <span class=\"fn\">toApplyRulesConfig</span> :=\n      <span class=\"fn\">{\n        <span class=\"fn\">toBacktrackConfig</span> :=\n          <span class=\"fn\">{ <span class=\"fn\">maxDepth</span> := <span class=\"fn\">6</span>, <span class=\"fn\">proc</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> x : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <span class=\"fn\">none</span></span></span>,\n            <span class=\"fn\">suspend</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span></span>, <span class=\"fn\">discharge</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>) =&gt; <span class=\"fn\">failure</span></span>,\n            <span class=\"fn\">commitIndependentGoals</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a> }</span>,\n        <span class=\"fn\">toApplyConfig</span> :=\n          <span class=\"fn\">{ <span class=\"fn\">newGoals</span> := <a href=\"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals.nonDependentFirst\">Lean.Meta.ApplyNewGoals.nonDependentFirst</a>, <span class=\"fn\">synthAssignedInstances</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>,\n            <span class=\"fn\">allowSynthFailures</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>, <span class=\"fn\">approx</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span>,\n        <span class=\"fn\">transparency</span> := <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode.default\">Lean.Meta.TransparencyMode.default</a>, <span class=\"fn\">symm</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">exfalso</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span>,\n    <span class=\"fn\">backtracking</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(test : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config\">Std.Tactic.SolveByElim.Config</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L183-L184","name":"Std.Tactic.SolveByElim.Config.synthInstanceAfter","line":183,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.synthInstanceAfter","doc":"Create or modify a `Config` which\ncalls `synthInstance` on any goal for which no lemma applies. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.synthInstanceAfter\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">Config</span>.<span class=\"name\">synthInstanceAfter</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cfg : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config\">Std.Tactic.SolveByElim.Config</a>\n  <span class=\"fn\">{\n    <span class=\"fn\">toApplyRulesConfig</span> :=\n      <span class=\"fn\">{\n        <span class=\"fn\">toBacktrackConfig</span> :=\n          <span class=\"fn\">{ <span class=\"fn\">maxDepth</span> := <span class=\"fn\">6</span>, <span class=\"fn\">proc</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> x : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <span class=\"fn\">none</span></span></span>,\n            <span class=\"fn\">suspend</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span></span>, <span class=\"fn\">discharge</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>) =&gt; <span class=\"fn\">failure</span></span>,\n            <span class=\"fn\">commitIndependentGoals</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a> }</span>,\n        <span class=\"fn\">toApplyConfig</span> :=\n          <span class=\"fn\">{ <span class=\"fn\">newGoals</span> := <a href=\"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals.nonDependentFirst\">Lean.Meta.ApplyNewGoals.nonDependentFirst</a>, <span class=\"fn\">synthAssignedInstances</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>,\n            <span class=\"fn\">allowSynthFailures</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>, <span class=\"fn\">approx</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span>,\n        <span class=\"fn\">transparency</span> := <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode.default\">Lean.Meta.TransparencyMode.default</a>, <span class=\"fn\">symm</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">exfalso</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span>,\n    <span class=\"fn\">backtracking</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config\">Std.Tactic.SolveByElim.Config</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L178-L179","name":"Std.Tactic.SolveByElim.Config.introsAfter","line":178,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.introsAfter","doc":"Create or modify a `Config` which calls `intro` on any goal for which no lemma applies. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.introsAfter\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">Config</span>.<span class=\"name\">introsAfter</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cfg : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config\">Std.Tactic.SolveByElim.Config</a>\n  <span class=\"fn\">{\n    <span class=\"fn\">toApplyRulesConfig</span> :=\n      <span class=\"fn\">{\n        <span class=\"fn\">toBacktrackConfig</span> :=\n          <span class=\"fn\">{ <span class=\"fn\">maxDepth</span> := <span class=\"fn\">6</span>, <span class=\"fn\">proc</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> x : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <span class=\"fn\">none</span></span></span>,\n            <span class=\"fn\">suspend</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span></span>, <span class=\"fn\">discharge</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>) =&gt; <span class=\"fn\">failure</span></span>,\n            <span class=\"fn\">commitIndependentGoals</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a> }</span>,\n        <span class=\"fn\">toApplyConfig</span> :=\n          <span class=\"fn\">{ <span class=\"fn\">newGoals</span> := <a href=\"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals.nonDependentFirst\">Lean.Meta.ApplyNewGoals.nonDependentFirst</a>, <span class=\"fn\">synthAssignedInstances</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>,\n            <span class=\"fn\">allowSynthFailures</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>, <span class=\"fn\">approx</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span>,\n        <span class=\"fn\">transparency</span> := <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode.default\">Lean.Meta.TransparencyMode.default</a>, <span class=\"fn\">symm</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">exfalso</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span>,\n    <span class=\"fn\">backtracking</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config\">Std.Tactic.SolveByElim.Config</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L171-L175","name":"Std.Tactic.SolveByElim.Config.withDischarge","line":171,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.withDischarge","doc":"Add a discharging tactic, falling back to the original discharging tactic if it fails.\nReturn `none` to return the goal as a new subgoal, or `some goals` to replace it. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.withDischarge\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">Config</span>.<span class=\"name\">withDischarge</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cfg : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config\">Std.Tactic.SolveByElim.Config</a>\n  <span class=\"fn\">{\n    <span class=\"fn\">toApplyRulesConfig</span> :=\n      <span class=\"fn\">{\n        <span class=\"fn\">toBacktrackConfig</span> :=\n          <span class=\"fn\">{ <span class=\"fn\">maxDepth</span> := <span class=\"fn\">6</span>, <span class=\"fn\">proc</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> x : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <span class=\"fn\">none</span></span></span>,\n            <span class=\"fn\">suspend</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span></span>, <span class=\"fn\">discharge</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>) =&gt; <span class=\"fn\">failure</span></span>,\n            <span class=\"fn\">commitIndependentGoals</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a> }</span>,\n        <span class=\"fn\">toApplyConfig</span> :=\n          <span class=\"fn\">{ <span class=\"fn\">newGoals</span> := <a href=\"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals.nonDependentFirst\">Lean.Meta.ApplyNewGoals.nonDependentFirst</a>, <span class=\"fn\">synthAssignedInstances</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>,\n            <span class=\"fn\">allowSynthFailures</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>, <span class=\"fn\">approx</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span>,\n        <span class=\"fn\">transparency</span> := <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode.default\">Lean.Meta.TransparencyMode.default</a>, <span class=\"fn\">symm</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">exfalso</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span>,\n    <span class=\"fn\">backtracking</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(discharge : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config\">Std.Tactic.SolveByElim.Config</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L166-L167","name":"Std.Tactic.SolveByElim.Config.synthInstance","line":166,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.synthInstance","doc":"Attempt typeclass inference on each goal, before applying lemmas. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.synthInstance\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">Config</span>.<span class=\"name\">synthInstance</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cfg : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config\">Std.Tactic.SolveByElim.Config</a>\n  <span class=\"fn\">{\n    <span class=\"fn\">toApplyRulesConfig</span> :=\n      <span class=\"fn\">{\n        <span class=\"fn\">toBacktrackConfig</span> :=\n          <span class=\"fn\">{ <span class=\"fn\">maxDepth</span> := <span class=\"fn\">6</span>, <span class=\"fn\">proc</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> x : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <span class=\"fn\">none</span></span></span>,\n            <span class=\"fn\">suspend</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span></span>, <span class=\"fn\">discharge</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>) =&gt; <span class=\"fn\">failure</span></span>,\n            <span class=\"fn\">commitIndependentGoals</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a> }</span>,\n        <span class=\"fn\">toApplyConfig</span> :=\n          <span class=\"fn\">{ <span class=\"fn\">newGoals</span> := <a href=\"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals.nonDependentFirst\">Lean.Meta.ApplyNewGoals.nonDependentFirst</a>, <span class=\"fn\">synthAssignedInstances</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>,\n            <span class=\"fn\">allowSynthFailures</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>, <span class=\"fn\">approx</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span>,\n        <span class=\"fn\">transparency</span> := <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode.default\">Lean.Meta.TransparencyMode.default</a>, <span class=\"fn\">symm</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">exfalso</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span>,\n    <span class=\"fn\">backtracking</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config\">Std.Tactic.SolveByElim.Config</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L159-L160","name":"Std.Tactic.SolveByElim.Config.intros","line":159,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.intros","doc":"Create or modify a `Config` which calls `intro` on each goal before applying lemmas. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.intros\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">Config</span>.<span class=\"name\">intros</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cfg : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config\">Std.Tactic.SolveByElim.Config</a>\n  <span class=\"fn\">{\n    <span class=\"fn\">toApplyRulesConfig</span> :=\n      <span class=\"fn\">{\n        <span class=\"fn\">toBacktrackConfig</span> :=\n          <span class=\"fn\">{ <span class=\"fn\">maxDepth</span> := <span class=\"fn\">6</span>, <span class=\"fn\">proc</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> x : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <span class=\"fn\">none</span></span></span>,\n            <span class=\"fn\">suspend</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span></span>, <span class=\"fn\">discharge</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>) =&gt; <span class=\"fn\">failure</span></span>,\n            <span class=\"fn\">commitIndependentGoals</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a> }</span>,\n        <span class=\"fn\">toApplyConfig</span> :=\n          <span class=\"fn\">{ <span class=\"fn\">newGoals</span> := <a href=\"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals.nonDependentFirst\">Lean.Meta.ApplyNewGoals.nonDependentFirst</a>, <span class=\"fn\">synthAssignedInstances</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>,\n            <span class=\"fn\">allowSynthFailures</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>, <span class=\"fn\">approx</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span>,\n        <span class=\"fn\">transparency</span> := <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode.default\">Lean.Meta.TransparencyMode.default</a>, <span class=\"fn\">symm</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">exfalso</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span>,\n    <span class=\"fn\">backtracking</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config\">Std.Tactic.SolveByElim.Config</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L147-L153","name":"Std.Tactic.SolveByElim.Config.mainGoalProc","line":147,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.mainGoalProc","doc":"Create or modify a `Config` which runs a tactic on the main goal.\nIf that tactic fails, fall back to the `proc` behaviour of `cfg`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.mainGoalProc\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">Config</span>.<span class=\"name\">mainGoalProc</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cfg : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config\">Std.Tactic.SolveByElim.Config</a>\n  <span class=\"fn\">{\n    <span class=\"fn\">toApplyRulesConfig</span> :=\n      <span class=\"fn\">{\n        <span class=\"fn\">toBacktrackConfig</span> :=\n          <span class=\"fn\">{ <span class=\"fn\">maxDepth</span> := <span class=\"fn\">6</span>, <span class=\"fn\">proc</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> x : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <span class=\"fn\">none</span></span></span>,\n            <span class=\"fn\">suspend</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span></span>, <span class=\"fn\">discharge</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>) =&gt; <span class=\"fn\">failure</span></span>,\n            <span class=\"fn\">commitIndependentGoals</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a> }</span>,\n        <span class=\"fn\">toApplyConfig</span> :=\n          <span class=\"fn\">{ <span class=\"fn\">newGoals</span> := <a href=\"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals.nonDependentFirst\">Lean.Meta.ApplyNewGoals.nonDependentFirst</a>, <span class=\"fn\">synthAssignedInstances</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>,\n            <span class=\"fn\">allowSynthFailures</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>, <span class=\"fn\">approx</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span>,\n        <span class=\"fn\">transparency</span> := <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode.default\">Lean.Meta.TransparencyMode.default</a>, <span class=\"fn\">symm</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">exfalso</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span>,\n    <span class=\"fn\">backtracking</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(proc : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config\">Std.Tactic.SolveByElim.Config</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L135-L141","name":"Std.Tactic.SolveByElim.Config.accept","line":135,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.accept","doc":"Create or modify a `Config` which allows a class of goals to be returned as subgoals. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.accept\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">Config</span>.<span class=\"name\">accept</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cfg : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config\">Std.Tactic.SolveByElim.Config</a>\n  <span class=\"fn\">{\n    <span class=\"fn\">toApplyRulesConfig</span> :=\n      <span class=\"fn\">{\n        <span class=\"fn\">toBacktrackConfig</span> :=\n          <span class=\"fn\">{ <span class=\"fn\">maxDepth</span> := <span class=\"fn\">6</span>, <span class=\"fn\">proc</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> x : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <span class=\"fn\">none</span></span></span>,\n            <span class=\"fn\">suspend</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>) =&gt; <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span></span>, <span class=\"fn\">discharge</span> := <span class=\"fn\">fun (<span class=\"fn\">x</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>) =&gt; <span class=\"fn\">failure</span></span>,\n            <span class=\"fn\">commitIndependentGoals</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a> }</span>,\n        <span class=\"fn\">toApplyConfig</span> :=\n          <span class=\"fn\">{ <span class=\"fn\">newGoals</span> := <a href=\"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals.nonDependentFirst\">Lean.Meta.ApplyNewGoals.nonDependentFirst</a>, <span class=\"fn\">synthAssignedInstances</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>,\n            <span class=\"fn\">allowSynthFailures</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>, <span class=\"fn\">approx</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span>,\n        <span class=\"fn\">transparency</span> := <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode.default\">Lean.Meta.TransparencyMode.default</a>, <span class=\"fn\">symm</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">exfalso</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span>,\n    <span class=\"fn\">backtracking</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(test : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config\">Std.Tactic.SolveByElim.Config</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L123-L126","name":"Std.Tactic.SolveByElim.elabApplyRulesConfig","line":123,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.elabApplyRulesConfig","doc":"Allow elaboration of `ApplyRulesConfig` arguments to tactics.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.elabApplyRulesConfig\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">elabApplyRulesConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig\">Std.Tactic.SolveByElim.ApplyRulesConfig</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L118-L121","name":"Std.Tactic.SolveByElim.elabConfig","line":118,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.elabConfig","doc":"Allow elaboration of `Config` arguments to tactics.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.elabConfig\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">elabConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config\">Std.Tactic.SolveByElim.Config</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L116-L116","name":"Std.Tactic.SolveByElim.instCoeConfigBacktrackConfig","line":116,"kind":"instance","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.instCoeConfigBacktrackConfig","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.instCoeConfigBacktrackConfig\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">instCoeConfigBacktrackConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> <a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config\">Std.Tactic.SolveByElim.Config</a> <a href=\"./Std/Tactic/SolveByElim/Backtrack.html#Std.Tactic.BacktrackConfig\">Std.Tactic.BacktrackConfig</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L113-L113","name":"Std.Tactic.SolveByElim.Config.backtracking","line":113,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.backtracking","doc":"Enable backtracking search. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.backtracking\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">Config</span>.<span class=\"name\">backtracking</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config\">Std.Tactic.SolveByElim.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L111-L111","name":"Std.Tactic.SolveByElim.Config.mk","line":111,"kind":"ctor","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.mk\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">Config</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(toApplyRulesConfig : <a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig\">Std.Tactic.SolveByElim.ApplyRulesConfig</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(backtracking : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config\">Std.Tactic.SolveByElim.Config</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L111-L114","name":"Std.Tactic.SolveByElim.Config","line":111,"kind":"structure","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config","doc":"Configuration structure to control the behaviour of `solve_by_elim`:\n* transparency mode for calls to `apply`\n* whether to use `symm` on hypotheses and `exfalso` on the goal as needed,\n* see also `BacktrackConfig` for hooks allowing flow control.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">Config</span></a></span><span class=\"decl_extends\">extends</span><span class=\"decl_parent\">\n<span class=\"fn\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">ApplyRulesConfig</span></a></span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L102-L102","name":"Std.Tactic.SolveByElim.ApplyRulesConfig.exfalso","line":102,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig.exfalso","doc":"Try proving the goal via `exfalso` if `solve_by_elim` otherwise fails.\nThis is only used when operating on a single goal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig.exfalso\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">ApplyRulesConfig</span>.<span class=\"name\">exfalso</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig\">Std.Tactic.SolveByElim.ApplyRulesConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L99-L99","name":"Std.Tactic.SolveByElim.ApplyRulesConfig.symm","line":99,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig.symm","doc":"Also use symmetric versions (via `@[symm]`) of local hypotheses. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig.symm\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">ApplyRulesConfig</span>.<span class=\"name\">symm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig\">Std.Tactic.SolveByElim.ApplyRulesConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L97-L97","name":"Std.Tactic.SolveByElim.ApplyRulesConfig.transparency","line":97,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig.transparency","doc":"Transparency mode for calls to `apply`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig.transparency\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">ApplyRulesConfig</span>.<span class=\"name\">transparency</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig\">Std.Tactic.SolveByElim.ApplyRulesConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L95-L95","name":"Std.Tactic.SolveByElim.ApplyRulesConfig.mk","line":95,"kind":"ctor","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig.mk\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">ApplyRulesConfig</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(toBacktrackConfig : <a href=\"./Std/Tactic/SolveByElim/Backtrack.html#Std.Tactic.BacktrackConfig\">Std.Tactic.BacktrackConfig</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(toApplyConfig : <a href=\"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyConfig\">Lean.Meta.ApplyConfig</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(transparency : <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(symm : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(exfalso : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig\">Std.Tactic.SolveByElim.ApplyRulesConfig</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L95-L103","name":"Std.Tactic.SolveByElim.ApplyRulesConfig","line":95,"kind":"structure","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig","doc":"The default `maxDepth` for `apply_rules` is higher. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">ApplyRulesConfig</span></a></span><span class=\"decl_extends\">extends</span><span class=\"decl_parent\">\n<span class=\"fn\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim/Backtrack.html#Std.Tactic.BacktrackConfig\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">BacktrackConfig</span></a></span></span>\n, <span class=\"decl_parent\">\n<span class=\"fn\"><a class=\"break_within\" href=\"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyConfig\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">ApplyConfig</span></a></span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L90-L92","name":"Std.Tactic.SolveByElim.applyFirst","line":90,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.applyFirst","doc":"`applyFirst lemmas goal` applies the first of the `lemmas`\nwhich can be successfully applied to `goal`, and fails if none apply.\n\nWe use this in `apply_rules` and `apply_assumption` where backtracking is not needed.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.applyFirst\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">applyFirst</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cfg : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyConfig\">Lean.Meta.ApplyConfig</a>\n  <span class=\"fn\">{ <span class=\"fn\">newGoals</span> := <a href=\"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals.nonDependentFirst\">Lean.Meta.ApplyNewGoals.nonDependentFirst</a>, <span class=\"fn\">synthAssignedInstances</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">allowSynthFailures</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>,\n    <span class=\"fn\">approx</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(transparency : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a> <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode.default\">Lean.Meta.TransparencyMode.default</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(lemmas : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L72-L82","name":"Std.Tactic.SolveByElim.applyTactics","line":72,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.applyTactics","doc":"`applyTactics lemmas goal` will return a list of tactics,\ncorresponding to applying each one of the lemmas to the goal `goal`.\n\nProviding this to the `backtracking` tactic,\nwe can perform backtracking search based on applying a list of lemmas.\n\n``applyTactics (trace := `name)`` will construct trace nodes for ``name` indicating which\ncalls to `apply` succeeded or failed.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.applyTactics\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">SolveByElim</span>.<span class=\"name\">applyTactics</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cfg : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyConfig\">Lean.Meta.ApplyConfig</a>\n  <span class=\"fn\">{ <span class=\"fn\">newGoals</span> := <a href=\"./Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals.nonDependentFirst\">Lean.Meta.ApplyNewGoals.nonDependentFirst</a>, <span class=\"fn\">synthAssignedInstances</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">allowSynthFailures</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>,\n    <span class=\"fn\">approx</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a> }</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(transparency : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a> <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode.default\">Lean.Meta.TransparencyMode.default</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(lemmas : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Control/Nondet/Basic.html#Nondet\">Nondet</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L54-L56","name":"Std.Tactic.tacticSymm_saturate","line":54,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Std.Tactic.tacticSymm_saturate","doc":"For every hypothesis `h : a ~ b` where a `@[symm]` lemma is available,\nadd a hypothesis `h_symm : b ~ a`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Std.Tactic.tacticSymm_saturate\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticSymm_saturate</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L36-L46","name":"Lean.MVarId.symmSaturate","line":36,"kind":"def","docLink":"./Std/Tactic/SolveByElim.html#Lean.MVarId.symmSaturate","doc":"For every hypothesis `h : a ~ b` where a `@[symm]` lemma is available,\nadd a hypothesis `h_symm : b ~ a`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/SolveByElim.html#Lean.MVarId.symmSaturate\"><span class=\"name\">Lean</span>.<span class=\"name\">MVarId</span>.<span class=\"name\">symmSaturate</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span></div></div>"}]}