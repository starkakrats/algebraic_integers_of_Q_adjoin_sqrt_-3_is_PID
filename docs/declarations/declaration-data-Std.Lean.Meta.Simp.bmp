{"name":"Std.Lean.Meta.Simp","instances":[],"imports":["Init","Lean.Elab.Tactic.Simp","Std.Tactic.OpenPrivate"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Lean/Meta/Simp.lean#L42-L73","name":"Lean.Meta.Simp.mkSimpContext'","line":42,"kind":"def","docLink":"./Std/Lean/Meta/Simp.html#Lean.Meta.Simp.mkSimpContext'","doc":"If `ctx == false`, the config argument is assumed to have type `Meta.Simp.Config`,\nand `Meta.Simp.ConfigCtx` otherwise.\nIf `ctx == false`, the `discharge` option must be none\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Lean/Meta/Simp.html#Lean.Meta.Simp.mkSimpContext'\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Simp</span>.<span class=\"name\">mkSimpContext'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(simpTheorems : <a href=\"./Lean/Meta/Tactic/Simp/SimpTheorems.html#Lean.Meta.SimpTheorems\">Lean.Meta.SimpTheorems</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(stx : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(eraseLocal : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(kind : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Lean/Elab/Tactic/Simp.html#Lean.Elab.Tactic.SimpKind\">Lean.Elab.Tactic.SimpKind</a> <a href=\"./Lean/Elab/Tactic/Simp.html#Lean.Elab.Tactic.SimpKind.simp\">Lean.Elab.Tactic.SimpKind.simp</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ctx : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ignoreStarArg : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Lean/Elab/Tactic/Simp.html#Lean.Elab.Tactic.MkSimpContextResult\">Lean.Elab.Tactic.MkSimpContextResult</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Lean/Meta/Simp.lean#L33-L34","name":"Lean.Elab.Tactic.mkDischargeWrapper","line":33,"kind":"def","docLink":"./Std/Lean/Meta/Simp.html#Lean.Elab.Tactic.mkDischargeWrapper","doc":"Construct a `Simp.DischargeWrapper` from the `Syntax` for a `simp` discharger. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Lean/Meta/Simp.html#Lean.Elab.Tactic.mkDischargeWrapper\"><span class=\"name\">Lean</span>.<span class=\"name\">Elab</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mkDischargeWrapper</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(optDischargeSyntax : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Lean/Elab/Tactic/Simp.html#Lean.Elab.Tactic.Simp.DischargeWrapper\">Lean.Elab.Tactic.Simp.DischargeWrapper</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Lean/Meta/Simp.lean#L28-L29","name":"Lean.Meta.Simp.mkCast","line":28,"kind":"def","docLink":"./Std/Lean/Meta/Simp.html#Lean.Meta.Simp.mkCast","doc":"Construct the `Expr` `cast h e`, from a `Simp.Result` with proof `h`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Lean/Meta/Simp.html#Lean.Meta.Simp.mkCast\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Simp</span>.<span class=\"name\">mkCast</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(r : <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Lean/Meta/Simp.lean#L21-L25","name":"Lean.Meta.Simp.mkEqSymm","line":21,"kind":"def","docLink":"./Std/Lean/Meta/Simp.html#Lean.Meta.Simp.mkEqSymm","doc":"Flip the proof in a `Simp.Result`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Lean/Meta/Simp.html#Lean.Meta.Simp.mkEqSymm\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Simp</span>.<span class=\"name\">mkEqSymm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(r : <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>"}]}