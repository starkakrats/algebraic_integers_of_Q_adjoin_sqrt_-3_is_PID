{"name":"Mathlib.Lean.Meta.DiscrTree","instances":[],"imports":["Init","Lean.Meta.DiscrTree","Mathlib.Lean.Expr.Traverse"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Lean/Meta/DiscrTree.lean#L49-L50","name":"Lean.Meta.DiscrTree.keysSpecific","line":49,"kind":"def","docLink":"./Mathlib/Lean/Meta/DiscrTree.html#Lean.Meta.DiscrTree.keysSpecific","doc":"Check if a `keys : Array DiscTree.Key` is \"specific\",\ni.e. something other than `[*]` or `[=, *, *, *]`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/DiscrTree.html#Lean.Meta.DiscrTree.keysSpecific\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">DiscrTree</span>.<span class=\"name\">keysSpecific</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(keys : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Meta/DiscrTreeTypes.html#Lean.Meta.DiscrTree.Key\">Lean.Meta.DiscrTree.Key</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Lean/Meta/DiscrTree.lean#L28-L43","name":"Lean.Meta.DiscrTree.getSubexpressionMatches","line":28,"kind":"opaque","docLink":"./Mathlib/Lean/Meta/DiscrTree.html#Lean.Meta.DiscrTree.getSubexpressionMatches","doc":"Find keys which match the expression, or some subexpression.\n\nNote that repeated subexpressions will be visited each time they appear,\nmaking this operation potentially very expensive.\nIt would be good to solve this problem!\n\nImplementation: we reverse the results from `getMatch`,\nso that we return lemmas matching larger subexpressions first,\nand amongst those we return more specific lemmas first.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/DiscrTree.html#Lean.Meta.DiscrTree.getSubexpressionMatches\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">DiscrTree</span>.<span class=\"name\">getSubexpressionMatches</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(d : <span class=\"fn\"><a href=\"./Lean/Meta/DiscrTreeTypes.html#Lean.Meta.DiscrTree\">Lean.Meta.DiscrTree</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(config : <a href=\"./Lean/Meta/WHNF.html#Lean.Meta.WhnfCoreConfig\">Lean.Meta.WhnfCoreConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">α</span></span>)</span></span></div></div>"}]}