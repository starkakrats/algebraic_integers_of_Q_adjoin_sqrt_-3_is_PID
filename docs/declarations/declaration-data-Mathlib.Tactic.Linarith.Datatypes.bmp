{"name":"Mathlib.Tactic.Linarith.Datatypes","instances":[{"typeNames":["Eq"],"name":"Linarith.instDecidableEqIneq","className":"Decidable"},{"typeNames":["Linarith.Ineq"],"name":"Linarith.instInhabitedIneq","className":"Inhabited"},{"typeNames":["Linarith.Ineq"],"name":"Linarith.instReprIneq","className":"Repr"},{"typeNames":["Linarith.Ineq"],"name":"Linarith.Ineq.instToStringIneq","className":"ToString"},{"typeNames":["Linarith.Ineq"],"name":"Linarith.Ineq.instToFormatIneq","className":"Std.ToFormat"},{"typeNames":["Linarith.Comp"],"name":"Linarith.instInhabitedComp","className":"Inhabited"},{"typeNames":["Linarith.Comp"],"name":"Linarith.instReprComp","className":"Repr"},{"typeNames":["Linarith.Comp"],"name":"Linarith.Comp.ToFormat","className":"Std.ToFormat"},{"typeNames":["Linarith.Preprocessor","Linarith.GlobalBranchingPreprocessor"],"name":"Linarith.PreprocessorToGlobalBranchingPreprocessor","className":"Coe"},{"typeNames":["Linarith.GlobalPreprocessor","Linarith.GlobalBranchingPreprocessor"],"name":"Linarith.GlobalPreprocessorToGlobalBranchingPreprocessor","className":"Coe"}],"imports":["Init","Mathlib.Tactic.Linarith.Lemmas","Mathlib.Tactic.Ring.Basic","Mathlib.Util.SynthesizeUsing"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L394-L406","name":"Linarith.mkSingleCompZeroOf","line":394,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.mkSingleCompZeroOf","doc":"`mkSingleCompZeroOf c h` assumes that `h` is a proof of `t R 0`.\nIt produces a pair `(R', h')`, where `h'` is a proof of `c*t R' 0`.\nTypically `R` and `R'` will be the same, except when `c = 0`, in which case `R'` is `=`.\nIf `c = 1`, `h'` is the same as `h` -- specifically, it does *not* change the type to `1*t R 0`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.mkSingleCompZeroOf\"><span class=\"name\">Linarith</span>.<span class=\"name\">mkSingleCompZeroOf</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq\">Linarith.Ineq</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L386-L386","name":"Linarith.parseCompAndExpr.throwNotZero","line":386,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.parseCompAndExpr.throwNotZero","doc":"helper function for error message "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.parseCompAndExpr.throwNotZero\"><span class=\"name\">Linarith</span>.<span class=\"name\">parseCompAndExpr</span>.<span class=\"name\">throwNotZero</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(z : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq\">Linarith.Ineq</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L378-L386","name":"Linarith.parseCompAndExpr","line":378,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.parseCompAndExpr","doc":"`parseCompAndExpr e` checks if `e` is of the form `t < 0`, `t ≤ 0`, or `t = 0`.\nIf it is, it returns the comparison along with `t`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.parseCompAndExpr\"><span class=\"name\">Linarith</span>.<span class=\"name\">parseCompAndExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq\">Linarith.Ineq</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L364-L372","name":"Linarith.getRelSides","line":364,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.getRelSides","doc":"`getRelSides e` returns the left and right hand sides of `e` if `e` is a comparison,\nand fails otherwise.\nThis function is more naturally in the `Option` monad, but it is convenient to put in `MetaM`\nfor compositionality.\n "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.getRelSides\"><span class=\"name\">Linarith</span>.<span class=\"name\">getRelSides</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L346-L350","name":"Linarith.LinarithConfig.updateReducibility","line":346,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig.updateReducibility","doc":"`cfg.updateReducibility reduce_default` will change the transparency setting of `cfg` to\n`default` if `reduce_default` is true. In this case, it also sets the discharger to `ring!`,\nsince this is typically needed when using stronger unification.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig.updateReducibility\"><span class=\"name\">Linarith</span>.<span class=\"name\">LinarithConfig</span>.<span class=\"name\">updateReducibility</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig\">Linarith.LinarithConfig</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(reduce_default : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig\">Linarith.LinarithConfig</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L339-L339","name":"Linarith.LinarithConfig.oracle","line":339,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig.oracle","doc":"Specify an oracle for identifying candidate contradictions.\nThe only implementation here is Fourier-Motzkin elimination. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig.oracle\"><span class=\"name\">Linarith</span>.<span class=\"name\">LinarithConfig</span>.<span class=\"name\">oracle</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig\">Linarith.LinarithConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.CertificateOracle\">Linarith.CertificateOracle</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L336-L336","name":"Linarith.LinarithConfig.preprocessors","line":336,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig.preprocessors","doc":"Override the list of preprocessors. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig.preprocessors\"><span class=\"name\">Linarith</span>.<span class=\"name\">LinarithConfig</span>.<span class=\"name\">preprocessors</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig\">Linarith.LinarithConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalBranchingPreprocessor\">Linarith.GlobalBranchingPreprocessor</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L334-L334","name":"Linarith.LinarithConfig.splitNe","line":334,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig.splitNe","doc":"Split `≠` in hypotheses, by branching in cases `<` and `>`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig.splitNe\"><span class=\"name\">Linarith</span>.<span class=\"name\">LinarithConfig</span>.<span class=\"name\">splitNe</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig\">Linarith.LinarithConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L332-L332","name":"Linarith.LinarithConfig.splitHypotheses","line":332,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig.splitHypotheses","doc":"Split conjunctions in hypotheses. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig.splitHypotheses\"><span class=\"name\">Linarith</span>.<span class=\"name\">LinarithConfig</span>.<span class=\"name\">splitHypotheses</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig\">Linarith.LinarithConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L330-L330","name":"Linarith.LinarithConfig.transparency","line":330,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig.transparency","doc":"Transparency mode for identifying atomic expressions in comparisons. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig.transparency\"><span class=\"name\">Linarith</span>.<span class=\"name\">LinarithConfig</span>.<span class=\"name\">transparency</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig\">Linarith.LinarithConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L328-L328","name":"Linarith.LinarithConfig.exfalso","line":328,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig.exfalso","doc":"Prove goals which are not linear comparisons by first calling `exfalso`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig.exfalso\"><span class=\"name\">Linarith</span>.<span class=\"name\">LinarithConfig</span>.<span class=\"name\">exfalso</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig\">Linarith.LinarithConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L321-L321","name":"Linarith.LinarithConfig.discharger","line":321,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig.discharger","doc":"Discharger to prove that a candidate linear combination of hypothesis is zero. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig.discharger\"><span class=\"name\">Linarith</span>.<span class=\"name\">LinarithConfig</span>.<span class=\"name\">discharger</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig\">Linarith.LinarithConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L318-L318","name":"Linarith.LinarithConfig.mk","line":318,"kind":"ctor","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig.mk\"><span class=\"name\">Linarith</span>.<span class=\"name\">LinarithConfig</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(discharger : <span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(exfalso : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(transparency : <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(splitHypotheses : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(splitNe : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(preprocessors : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalBranchingPreprocessor\">Linarith.GlobalBranchingPreprocessor</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(oracle : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.CertificateOracle\">Linarith.CertificateOracle</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig\">Linarith.LinarithConfig</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L318-L339","name":"Linarith.LinarithConfig","line":318,"kind":"structure","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig","doc":"A configuration object for `linarith`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig\"><span class=\"name\">Linarith</span>.<span class=\"name\">LinarithConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L312-L313","name":"Linarith.CertificateOracle","line":312,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.CertificateOracle","doc":"A `CertificateOracle` is a function\n`produceCertificate : List Comp → Nat → MetaM (HashMap Nat Nat)`.\n`produceCertificate hyps max_var` tries to derive a contradiction from the comparisons in `hyps`\nby eliminating all variables ≤ `max_var`.\nIf successful, it returns a map `coeff : Nat → Nat` as a certificate.\nThis map represents that we can find a contradiction by taking the sum `∑ (coeff i) * hyps[i]`.\n\nThe default `CertificateOracle` used by `linarith` is\n`Linarith.FourierMotzkin.produceCertificate`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.CertificateOracle\"><span class=\"name\">Linarith</span>.<span class=\"name\">CertificateOracle</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L297-L299","name":"Linarith.GlobalPreprocessorToGlobalBranchingPreprocessor","line":297,"kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalPreprocessorToGlobalBranchingPreprocessor","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalPreprocessorToGlobalBranchingPreprocessor\"><span class=\"name\">Linarith</span>.<span class=\"name\">GlobalPreprocessorToGlobalBranchingPreprocessor</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalPreprocessor\">Linarith.GlobalPreprocessor</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalBranchingPreprocessor\">Linarith.GlobalBranchingPreprocessor</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L293-L295","name":"Linarith.PreprocessorToGlobalBranchingPreprocessor","line":293,"kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.PreprocessorToGlobalBranchingPreprocessor","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.PreprocessorToGlobalBranchingPreprocessor\"><span class=\"name\">Linarith</span>.<span class=\"name\">PreprocessorToGlobalBranchingPreprocessor</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Preprocessor\">Linarith.Preprocessor</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalBranchingPreprocessor\">Linarith.GlobalBranchingPreprocessor</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L283-L291","name":"Linarith.GlobalBranchingPreprocessor.process","line":283,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalBranchingPreprocessor.process","doc":"`process pp l` runs `pp.transform` on `l` and returns the result,\ntracing the result if `trace.linarith` is on.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalBranchingPreprocessor.process\"><span class=\"name\">Linarith</span>.<span class=\"name\">GlobalBranchingPreprocessor</span>.<span class=\"name\">process</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(pp : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalBranchingPreprocessor\">Linarith.GlobalBranchingPreprocessor</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Branch\">Linarith.Branch</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L275-L277","name":"Linarith.GlobalPreprocessor.branching","line":275,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalPreprocessor.branching","doc":"A `GlobalPreprocessor` lifts to a `GlobalBranchingPreprocessor` by producing only one branch.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalPreprocessor.branching\"><span class=\"name\">Linarith</span>.<span class=\"name\">GlobalPreprocessor</span>.<span class=\"name\">branching</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(pp : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalPreprocessor\">Linarith.GlobalPreprocessor</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalBranchingPreprocessor\">Linarith.GlobalBranchingPreprocessor</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L268-L270","name":"Linarith.Preprocessor.globalize","line":268,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Preprocessor.globalize","doc":"A `Preprocessor` lifts to a `GlobalPreprocessor` by folding it over the input list.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Preprocessor.globalize\"><span class=\"name\">Linarith</span>.<span class=\"name\">Preprocessor</span>.<span class=\"name\">globalize</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(pp : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Preprocessor\">Linarith.Preprocessor</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalPreprocessor\">Linarith.GlobalPreprocessor</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L263-L263","name":"Linarith.GlobalBranchingPreprocessor.transform","line":263,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalBranchingPreprocessor.transform","doc":"Given a goal, and a list of hypotheses,\nproduce a list of pairs (consisting of a goal and list of hypotheses). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalBranchingPreprocessor.transform\"><span class=\"name\">Linarith</span>.<span class=\"name\">GlobalBranchingPreprocessor</span>.<span class=\"name\">transform</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalBranchingPreprocessor\">Linarith.GlobalBranchingPreprocessor</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Branch\">Linarith.Branch</a></span>)</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L260-L260","name":"Linarith.GlobalBranchingPreprocessor.name","line":260,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalBranchingPreprocessor.name","doc":"The name of the global branching preprocessor, used in trace output. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalBranchingPreprocessor.name\"><span class=\"name\">Linarith</span>.<span class=\"name\">GlobalBranchingPreprocessor</span>.<span class=\"name\">name</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalBranchingPreprocessor\">Linarith.GlobalBranchingPreprocessor</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#String\">String</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L258-L258","name":"Linarith.GlobalBranchingPreprocessor.mk","line":258,"kind":"ctor","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalBranchingPreprocessor.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalBranchingPreprocessor.mk\"><span class=\"name\">Linarith</span>.<span class=\"name\">GlobalBranchingPreprocessor</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(name : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(transform : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Branch\">Linarith.Branch</a></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalBranchingPreprocessor\">Linarith.GlobalBranchingPreprocessor</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L258-L263","name":"Linarith.GlobalBranchingPreprocessor","line":258,"kind":"structure","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalBranchingPreprocessor","doc":"Some preprocessors perform branching case splits.\nA `GlobalBranchingPreprocessor` produces a list of branches to run.\nEach branch is independent, so hypotheses that appear in multiple branches should be duplicated.\nThe preprocessor is responsible for making sure that each branch contains the correct goal\nmetavariable.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalBranchingPreprocessor\"><span class=\"name\">Linarith</span>.<span class=\"name\">GlobalBranchingPreprocessor</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L249-L249","name":"Linarith.Branch","line":249,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Branch","doc":"Some preprocessors perform branching case splits. A `Branch` is used to track one of these case\nsplits. The first component, an `MVarId`, is the goal corresponding to this branch of the split,\ngiven as a metavariable. The `List Expr` component is the list of hypotheses for `linarith`\nin this branch.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Branch\"><span class=\"name\">Linarith</span>.<span class=\"name\">Branch</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L241-L241","name":"Linarith.GlobalPreprocessor.transform","line":241,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalPreprocessor.transform","doc":"Replace the collection of all hypotheses with new hypotheses.\nThese expressions are proof terms. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalPreprocessor.transform\"><span class=\"name\">Linarith</span>.<span class=\"name\">GlobalPreprocessor</span>.<span class=\"name\">transform</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalPreprocessor\">Linarith.GlobalPreprocessor</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L238-L238","name":"Linarith.GlobalPreprocessor.name","line":238,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalPreprocessor.name","doc":"The name of the global preprocessor, used in trace output. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalPreprocessor.name\"><span class=\"name\">Linarith</span>.<span class=\"name\">GlobalPreprocessor</span>.<span class=\"name\">name</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalPreprocessor\">Linarith.GlobalPreprocessor</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#String\">String</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L236-L236","name":"Linarith.GlobalPreprocessor.mk","line":236,"kind":"ctor","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalPreprocessor.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalPreprocessor.mk\"><span class=\"name\">Linarith</span>.<span class=\"name\">GlobalPreprocessor</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(name : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(transform : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalPreprocessor\">Linarith.GlobalPreprocessor</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L236-L241","name":"Linarith.GlobalPreprocessor","line":236,"kind":"structure","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalPreprocessor","doc":"Some preprocessors need to examine the full list of hypotheses instead of working item by item.\nAs with `Preprocessor`, the input to a `GlobalPreprocessor` is replaced by, not added to, its\noutput.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.GlobalPreprocessor\"><span class=\"name\">Linarith</span>.<span class=\"name\">GlobalPreprocessor</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L229-L229","name":"Linarith.Preprocessor.transform","line":229,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Preprocessor.transform","doc":"Replace a hypothesis by a list of hypotheses. These expressions are the proof terms. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Preprocessor.transform\"><span class=\"name\">Linarith</span>.<span class=\"name\">Preprocessor</span>.<span class=\"name\">transform</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Preprocessor\">Linarith.Preprocessor</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L227-L227","name":"Linarith.Preprocessor.name","line":227,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Preprocessor.name","doc":"The name of the preprocessor, used in trace output. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Preprocessor.name\"><span class=\"name\">Linarith</span>.<span class=\"name\">Preprocessor</span>.<span class=\"name\">name</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Preprocessor\">Linarith.Preprocessor</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#String\">String</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L225-L225","name":"Linarith.Preprocessor.mk","line":225,"kind":"ctor","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Preprocessor.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Preprocessor.mk\"><span class=\"name\">Linarith</span>.<span class=\"name\">Preprocessor</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(name : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(transform : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Preprocessor\">Linarith.Preprocessor</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L225-L229","name":"Linarith.Preprocessor","line":225,"kind":"structure","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Preprocessor","doc":"A preprocessor transforms a proof of a proposition into a proof of a different proposition.\nThe return type is `List Expr`, since some preprocessing steps may create multiple new hypotheses,\nand some may remove a hypothesis from the list.\nA \"no-op\" preprocessor should return its input as a singleton list.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Preprocessor\"><span class=\"name\">Linarith</span>.<span class=\"name\">Preprocessor</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L211-L212","name":"Linarith.Comp.ToFormat","line":211,"kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp.ToFormat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp.ToFormat\"><span class=\"name\">Linarith</span>.<span class=\"name\">Comp</span>.<span class=\"name\">ToFormat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Format/Basic.html#Std.ToFormat\">Lean.ToFormat</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp\">Linarith.Comp</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L209-L209","name":"Linarith.Comp.isContr","line":209,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp.isContr","doc":"A `Comp` represents a contradiction if its expression has no coefficients and its strength is <,\nthat is, it represents the fact `0 < 0`.\n "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp.isContr\"><span class=\"name\">Linarith</span>.<span class=\"name\">Comp</span>.<span class=\"name\">isContr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp\">Linarith.Comp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L198-L203","name":"Linarith.Comp.cmp","line":198,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp.cmp","doc":"`Comp` has a lex order. First the `ineq`s are compared, then the `coeff`s. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp.cmp\"><span class=\"name\">Linarith</span>.<span class=\"name\">Comp</span>.<span class=\"name\">cmp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp\">Linarith.Comp</a> → <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp\">Linarith.Comp</a> → <a href=\"./Init/Data/Ord.html#Ordering\">Ordering</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L194-L195","name":"Linarith.Comp.add","line":194,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp.add","doc":"`Comp.add c1 c2` adds the expressions represented by `c1` and `c2`.\nThe coefficient of variable `a` in `c1.add c2`\nis the sum of the coefficients of `a` in `c1` and `c2`.\n "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp.add\"><span class=\"name\">Linarith</span>.<span class=\"name\">Comp</span>.<span class=\"name\">add</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c1 : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp\">Linarith.Comp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(c2 : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp\">Linarith.Comp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp\">Linarith.Comp</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L186-L187","name":"Linarith.Comp.scale","line":186,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp.scale","doc":"`c.scale n` scales the coefficients of `c` by `n`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp.scale\"><span class=\"name\">Linarith</span>.<span class=\"name\">Comp</span>.<span class=\"name\">scale</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp\">Linarith.Comp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp\">Linarith.Comp</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L182-L183","name":"Linarith.Comp.coeffOf","line":182,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp.coeffOf","doc":"`c.coeffOf a` projects the coefficient of variable `a` out of `c`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp.coeffOf\"><span class=\"name\">Linarith</span>.<span class=\"name\">Comp</span>.<span class=\"name\">coeffOf</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp\">Linarith.Comp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L179-L179","name":"Linarith.Comp.vars","line":179,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp.vars","doc":"`c.vars` returns the list of variables that appear in the linear expression contained in `c`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp.vars\"><span class=\"name\">Linarith</span>.<span class=\"name\">Comp</span>.<span class=\"name\">vars</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp\">Linarith.Comp</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L176-L176","name":"Linarith.instReprComp","line":176,"kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.instReprComp","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.instReprComp\"><span class=\"name\">Linarith</span>.<span class=\"name\">instReprComp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp\">Linarith.Comp</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L176-L176","name":"Linarith.instInhabitedComp","line":176,"kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.instInhabitedComp","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.instInhabitedComp\"><span class=\"name\">Linarith</span>.<span class=\"name\">instInhabitedComp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp\">Linarith.Comp</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L175-L175","name":"Linarith.Comp.coeffs","line":175,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp.coeffs","doc":"The coefficients of the comparison, stored as list of pairs `(i, a)`,\nwhere `i` is the index of a recorded atom, and `a` is the coefficient. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp.coeffs\"><span class=\"name\">Linarith</span>.<span class=\"name\">Comp</span>.<span class=\"name\">coeffs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp\">Linarith.Comp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp\">Linarith.Linexp</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L172-L172","name":"Linarith.Comp.str","line":172,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp.str","doc":"The strength of the comparison, `<`, `≤`, or `=`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp.str\"><span class=\"name\">Linarith</span>.<span class=\"name\">Comp</span>.<span class=\"name\">str</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp\">Linarith.Comp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq\">Linarith.Ineq</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L170-L170","name":"Linarith.Comp.mk","line":170,"kind":"ctor","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp.mk\"><span class=\"name\">Linarith</span>.<span class=\"name\">Comp</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(str : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq\">Linarith.Ineq</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(coeffs : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp\">Linarith.Linexp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp\">Linarith.Comp</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L170-L176","name":"Linarith.Comp","line":170,"kind":"structure","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp","doc":"The main datatype for FM elimination.\nVariables are represented by natural numbers, each of which has an integer coefficient.\nIndex 0 is reserved for constants, i.e. `coeffs.find 0` is the coefficient of 1.\nThe represented term is `coeffs.sum (λ ⟨k, v⟩, v * Var[k])`.\nstr determines the strength of the comparison -- is it < 0, ≤ 0, or = 0?\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Comp\"><span class=\"name\">Linarith</span>.<span class=\"name\">Comp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L157-L157","name":"Linarith.Ineq.instToFormatIneq","line":157,"kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq.instToFormatIneq","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq.instToFormatIneq\"><span class=\"name\">Linarith</span>.<span class=\"name\">Ineq</span>.<span class=\"name\">instToFormatIneq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Format/Basic.html#Std.ToFormat\">Lean.ToFormat</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq\">Linarith.Ineq</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L155-L155","name":"Linarith.Ineq.instToStringIneq","line":155,"kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq.instToStringIneq","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq.instToStringIneq\"><span class=\"name\">Linarith</span>.<span class=\"name\">Ineq</span>.<span class=\"name\">instToStringIneq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/ToString/Basic.html#ToString\">ToString</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq\">Linarith.Ineq</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L150-L153","name":"Linarith.Ineq.toConstMulName","line":150,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq.toConstMulName","doc":"Finds the name of a multiplicative lemma corresponding to an inequality strength. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq.toConstMulName\"><span class=\"name\">Linarith</span>.<span class=\"name\">Ineq</span>.<span class=\"name\">toConstMulName</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq\">Linarith.Ineq</a> → <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L144-L147","name":"Linarith.Ineq.toString","line":144,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq.toString","doc":"Prints an `Ineq` as the corresponding infix symbol. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq.toString\"><span class=\"name\">Linarith</span>.<span class=\"name\">Ineq</span>.<span class=\"name\">toString</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq\">Linarith.Ineq</a> → <a href=\"./Init/Prelude.html#String\">String</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L135-L141","name":"Linarith.Ineq.cmp","line":135,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq.cmp","doc":"`Ineq` is ordered `eq < le < lt`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq.cmp\"><span class=\"name\">Linarith</span>.<span class=\"name\">Ineq</span>.<span class=\"name\">cmp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq\">Linarith.Ineq</a> → <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq\">Linarith.Ineq</a> → <a href=\"./Init/Data/Ord.html#Ordering\">Ordering</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L127-L132","name":"Linarith.Ineq.max","line":127,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq.max","doc":"`max R1 R2` computes the strength of the sum of two inequalities. If `t1 R1 0` and `t2 R2 0`,\nthen `t1 + t2 (max R1 R2) 0`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq.max\"><span class=\"name\">Linarith</span>.<span class=\"name\">Ineq</span>.<span class=\"name\">max</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq\">Linarith.Ineq</a> → <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq\">Linarith.Ineq</a> → <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq\">Linarith.Ineq</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L119-L119","name":"Linarith.instReprIneq","line":119,"kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.instReprIneq","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.instReprIneq\"><span class=\"name\">Linarith</span>.<span class=\"name\">instReprIneq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq\">Linarith.Ineq</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L119-L119","name":"Linarith.instInhabitedIneq","line":119,"kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.instInhabitedIneq","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.instInhabitedIneq\"><span class=\"name\">Linarith</span>.<span class=\"name\">instInhabitedIneq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq\">Linarith.Ineq</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L119-L119","name":"Linarith.instDecidableEqIneq","line":119,"kind":"instance","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.instDecidableEqIneq","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.instDecidableEqIneq\"><span class=\"name\">Linarith</span>.<span class=\"name\">instDecidableEqIneq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq\">Linarith.Ineq</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L118-L118","name":"Linarith.Ineq.lt","line":118,"kind":"ctor","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq.lt","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq.lt\"><span class=\"name\">Linarith</span>.<span class=\"name\">Ineq</span>.<span class=\"name\">lt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq\">Linarith.Ineq</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L118-L118","name":"Linarith.Ineq.le","line":118,"kind":"ctor","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq.le","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq.le\"><span class=\"name\">Linarith</span>.<span class=\"name\">Ineq</span>.<span class=\"name\">le</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq\">Linarith.Ineq</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L118-L118","name":"Linarith.Ineq.eq","line":118,"kind":"ctor","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq.eq","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq.eq\"><span class=\"name\">Linarith</span>.<span class=\"name\">Ineq</span>.<span class=\"name\">eq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq\">Linarith.Ineq</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L117-L119","name":"Linarith.Ineq","line":117,"kind":"inductive","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq","doc":"The three-element type `Ineq` is used to represent the strength of a comparison between\nterms. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Ineq\"><span class=\"name\">Linarith</span>.<span class=\"name\">Ineq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L100-L109","name":"Linarith.Linexp.cmp","line":100,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp.cmp","doc":"Defines a lex ordering on `Linexp`. This function is performance critical.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp.cmp\"><span class=\"name\">Linarith</span>.<span class=\"name\">Linexp</span>.<span class=\"name\">cmp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp\">Linarith.Linexp</a> → <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp\">Linarith.Linexp</a> → <a href=\"./Init/Data/Ord.html#Ordering\">Ordering</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L94-L95","name":"Linarith.Linexp.vars","line":94,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp.vars","doc":"`l.vars` returns the list of variables that occur in `l`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp.vars\"><span class=\"name\">Linarith</span>.<span class=\"name\">Linexp</span>.<span class=\"name\">vars</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(l : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp\">Linarith.Linexp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L88-L91","name":"Linarith.Linexp.zfind","line":88,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp.zfind","doc":"`l.zfind n` returns the value associated with key `n` if there is one, and 0 otherwise.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp.zfind\"><span class=\"name\">Linarith</span>.<span class=\"name\">Linexp</span>.<span class=\"name\">zfind</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(l : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp\">Linarith.Linexp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L83-L83","name":"Linarith.Linexp.contains","line":83,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp.contains","doc":"`l.contains n` is true iff `n` is the first element of a pair in `l`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp.contains\"><span class=\"name\">Linarith</span>.<span class=\"name\">Linexp</span>.<span class=\"name\">contains</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp\">Linarith.Linexp</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L73-L78","name":"Linarith.Linexp.get","line":73,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp.get","doc":"`l.get n` returns the value in `l` associated with key `n`, if it exists, and `none` otherwise.\nThis function assumes that `l` is sorted in decreasing order of the first argument,\nthat is, it will return `none` as soon as it finds a key smaller than `n`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp.get\"><span class=\"name\">Linarith</span>.<span class=\"name\">Linexp</span>.<span class=\"name\">get</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp\">Linarith.Linexp</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L63-L66","name":"Linarith.Linexp.scale","line":63,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp.scale","doc":"`l.scale c` scales the values in `l` by `c` without modifying the order or keys. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp.scale\"><span class=\"name\">Linarith</span>.<span class=\"name\">Linexp</span>.<span class=\"name\">scale</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(c : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(l : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp\">Linarith.Linexp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp\">Linarith.Linexp</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L52-L60","name":"Linarith.Linexp.add","line":52,"kind":"opaque","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp.add","doc":"Add two `Linexp`s together componentwise.\nPreserves sorting and uniqueness of the first argument.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp.add\"><span class=\"name\">Linarith</span>.<span class=\"name\">Linexp</span>.<span class=\"name\">add</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp\">Linarith.Linexp</a> → <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp\">Linarith.Linexp</a> → <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp\">Linarith.Linexp</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L45-L45","name":"Linarith.Linexp","line":45,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp","doc":"A linear expression is a list of pairs of variable indices and coefficients,\nrepresenting the sum of the products of each coefficient with its corresponding variable.\n\nSome functions on `Linexp` assume that `n : Nat` occurs at most once as the first element of a pair,\nand that the list is sorted in decreasing order of the first argument.\nThis is not enforced by the type but the operations here preserve it.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.Linexp\"><span class=\"name\">Linarith</span>.<span class=\"name\">Linexp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Datatypes.lean#L30-L32","name":"Linarith.linarithTraceProofs","line":30,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.linarithTraceProofs","doc":"A shorthand for tracing the types of a list of proof terms\nwhen the `trace.linarith` option is set to true.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.linarithTraceProofs\"><span class=\"name\">Linarith</span>.<span class=\"name\">linarithTraceProofs</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Lean/Message.html#Lean.ToMessageData\">Lean.ToMessageData</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"}]}