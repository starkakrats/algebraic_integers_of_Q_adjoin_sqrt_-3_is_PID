{"name":"Mathlib.Lean.Meta.CongrTheorems","instances":[],"imports":["Init","Lean.Meta.Tactic.Cleanup","Mathlib.Lean.Meta"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Lean/Meta/CongrTheorems.lean#L256-L263","name":"Lean.Meta.mkRichHCongr.trySolve","line":256,"kind":"def","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.trySolve","doc":"Driver for `trySolveCore`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.trySolve\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkRichHCongr</span>.<span class=\"name\">trySolve</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ty : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Lean/Meta/CongrTheorems.lean#L241-L254","name":"Lean.Meta.mkRichHCongr.trySolveCore","line":241,"kind":"def","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.trySolveCore","doc":"Given a type that is a bunch of equalities implying a goal (for example, a basic\ncongruence lemma), prove it if possible. Basic congruence lemmas should be provable by this.\nThere are some extra tricks for handling arguments to richer congruence lemmas. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.trySolveCore\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkRichHCongr</span>.<span class=\"name\">trySolveCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(mvarId : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Lean/Meta/CongrTheorems.lean#L220-L236","name":"Lean.Meta.mkRichHCongr.withNewEqs.loop","line":220,"kind":"opaque","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.withNewEqs.loop","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.withNewEqs.loop\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkRichHCongr</span>.<span class=\"name\">withNewEqs</span>.<span class=\"name\">loop</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(info : <a href=\"./Lean/Meta/Basic.html#Lean.Meta.FunInfo\">Lean.Meta.FunInfo</a>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(xs : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ys : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fixedParams : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrArgKind\">Lean.Meta.CongrArgKind</a></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span>)</span></span>)</span></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(i : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(kinds : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrArgKind\">Lean.Meta.CongrArgKind</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(eqs : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span>)</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Lean/Meta/CongrTheorems.lean#L218-L237","name":"Lean.Meta.mkRichHCongr.withNewEqs","line":218,"kind":"def","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.withNewEqs","doc":"Introduce variables for equalities between the arrays of variables. Uses `fixedParams`\nto control whether to introduce an equality for each pair. The array of triples passed to `k`\nconsists of (1) the simple congr lemma HEq arg, (2) the richer HEq arg, and (3) how to\ncompute 1 in terms of 2. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.withNewEqs\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkRichHCongr</span>.<span class=\"name\">withNewEqs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(info : <a href=\"./Lean/Meta/Basic.html#Lean.Meta.FunInfo\">Lean.Meta.FunInfo</a>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(xs : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ys : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fixedParams : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrArgKind\">Lean.Meta.CongrArgKind</a></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span>)</span></span>)</span></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Lean/Meta/CongrTheorems.lean#L192-L212","name":"Lean.Meta.mkRichHCongr.doubleTelescope.loop","line":192,"kind":"opaque","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.doubleTelescope.loop","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.doubleTelescope.loop\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkRichHCongr</span>.<span class=\"name\">doubleTelescope</span>.<span class=\"name\">loop</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(numVars : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fixed : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(i : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ftyx : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ftyy : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(xs : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ys : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fixed' : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Lean/Meta/CongrTheorems.lean#L190-L213","name":"Lean.Meta.mkRichHCongr.doubleTelescope","line":190,"kind":"def","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.doubleTelescope","doc":"Similar to doing `forallBoundedTelescope` twice, but makes use of the `fixed` array, which\nis used as a hint for whether both variables should be the same. This is only a hint though,\nsince we respect it only if the binding domains are equal.\nWe affix `'` to the second list of variables, and all the variables are introduced\nwith default binder info. Calls `k` with the xs, ys, and a revised `fixed` array "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr.doubleTelescope\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkRichHCongr</span>.<span class=\"name\">doubleTelescope</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(fty : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(numVars : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fixed : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Lean/Meta/CongrTheorems.lean#L117-L263","name":"Lean.Meta.mkRichHCongr","line":117,"kind":"def","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr","doc":"`mkRichHCongr fType funInfo fixedFun fixedParams forceHEq`\ncreate a congruence lemma to prove that `Eq/HEq (f a₁ ... aₙ) (f' a₁' ... aₙ')`.\nThe functions have type `fType` and the number of arguments is governed by the `funInfo` data.\nEach argument produces an `Eq/HEq aᵢ aᵢ'` hypothesis, but we also provide these hypotheses\nthe additional facts that the preceding equalities have been proved (unlike in `mkHCongrWithArity`).\nThe first two arguments of the resulting theorem are for `f` and `f'`, followed by a proof\nof `f = f'`, unless `fixedFun` is `true` (see below).\n\nWhen including hypotheses about previous hypotheses, we make use of dependency information\nand only include relevant equalities.\n\nThe argument `fty` denotes the type of `f`. The arity of the resulting congruence lemma is\ncontrolled by the size of the `info` array.\n\nFor the purpose of generating nicer lemmas (to help `to_additive` for example),\nthis function supports generating lemmas where certain parameters\nare meant to be fixed:\n\n* If `fixedFun` is `false` (the default) then the lemma starts with three arguments for `f`, `f'`,\nand `h : f = f'`. Otherwise, if `fixedFun` is `true` then the lemma starts with just `f`.\n\n* If the `fixedParams` argument has `true` for a particular argument index, then this is a hint\nthat the congruence lemma may use the same parameter for both sides of the equality. There is\nno guarantee -- it respects it if the types are equal for that parameter (i.e., if the parameter\ndoes not depend on non-fixed parameters).\n\nIf `forceHEq` is `true` then the conclusion of the generated theorem is a `HEq`.\nOtherwise it might be an `Eq` if the equality is homogeneous.\n\nThis is the interpretation of the `CongrArgKind`s in the generated congruence theorem:\n* `.eq` corresponds to having three arguments `(x : α) (x' : α) (h : x = x')`.\n  Note that `h` might have additional hypotheses.\n* `.heq` corresponds to having three arguments `(x : α) (x' : α') (h : HEq x x')`\n  Note that `h` might have additional hypotheses.\n* `.fixed` corresponds to having a single argument `(x : α)` that is fixed between the LHS and RHS\n* `.subsingletonInst` corresponds to having two arguments `(x : α) (x' : α')` for which the\n  congruence generator was able to prove that `HEq x x'` already. This is a slight abuse of\n  this `CongrArgKind` since this is used even for types that are not subsingleton typeclasses.\n\nNote that the first entry in this array is for the function itself.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkRichHCongr\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkRichHCongr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(fType : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(info : <a href=\"./Lean/Meta/Basic.html#Lean.Meta.FunInfo\">Lean.Meta.FunInfo</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fixedFun : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fixedParams : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span>)</span> <span class=\"fn\">#[]</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(forceHEq : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.false\">false</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrTheorem\">Lean.Meta.CongrTheorem</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Lean/Meta/CongrTheorems.lean#L59-L73","name":"Lean.Meta.mkHCongrWithArity'.prove","line":59,"kind":"def","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkHCongrWithArity'.prove","doc":"Close the goal given only the fvars in `params`, or else fails. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkHCongrWithArity'.prove\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkHCongrWithArity'</span>.<span class=\"name\">prove</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(params : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Lean/Meta/CongrTheorems.lean#L34-L57","name":"Lean.Meta.mkHCongrWithArity'.process","line":34,"kind":"def","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkHCongrWithArity'.process","doc":"Process the congruence theorem by trying to pre-prove arguments using `prove`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkHCongrWithArity'.process\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkHCongrWithArity'</span>.<span class=\"name\">process</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cthm : <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrTheorem\">Lean.Meta.CongrTheorem</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(type : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(argKinds : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrArgKind\">Lean.Meta.CongrArgKind</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(argKinds' : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrArgKind\">Lean.Meta.CongrArgKind</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(params : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(args : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrTheorem\">Lean.Meta.CongrTheorem</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Lean/Meta/CongrTheorems.lean#L29-L73","name":"Lean.Meta.mkHCongrWithArity'","line":29,"kind":"def","docLink":"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkHCongrWithArity'","doc":"Generates a congruence lemma for a function `f` for `numArgs` of its arguments.\nThe only `Lean.Meta.CongrArgKind` kinds that appear in such a lemma\nare `.eq`, `.heq`, and `.subsingletonInst`.\nThe resulting lemma proves either an `Eq` or a `HEq` depending on whether the types\nof the LHS and RHS are equal or not.\n\nThis function is a wrapper around `Lean.Meta.mkHCongrWithArity`.\nIt transforms the resulting congruence lemma by trying to automatically prove hypotheses\nusing subsingleton lemmas, and if they are so provable they are recorded with `.subsingletonInst`.\nNote that this is slightly abusing `.subsingletonInst` since\n(1) the argument might not be for a `Decidable` instance and\n(2) the argument might not even be an instance. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Lean/Meta/CongrTheorems.html#Lean.Meta.mkHCongrWithArity'\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkHCongrWithArity'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(f : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(numArgs : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/CongrTheorems.html#Lean.Meta.CongrTheorem\">Lean.Meta.CongrTheorem</a></span></div></div>"}]}