{"name":"Mathlib.Tactic.Ring.RingNF","instances":[{"typeNames":["Mathlib.Tactic.RingNF.RingMode"],"name":"Mathlib.Tactic.RingNF.instInhabitedRingMode","className":"Inhabited"},{"typeNames":["Mathlib.Tactic.RingNF.RingMode"],"name":"Mathlib.Tactic.RingNF.instBEqRingMode","className":"BEq"},{"typeNames":["Mathlib.Tactic.RingNF.RingMode"],"name":"Mathlib.Tactic.RingNF.instReprRingMode","className":"Repr"},{"typeNames":["Mathlib.Tactic.RingNF.Config"],"name":"Mathlib.Tactic.RingNF.instInhabitedConfig","className":"Inhabited"},{"typeNames":["Mathlib.Tactic.RingNF.Config"],"name":"Mathlib.Tactic.RingNF.instBEqConfig","className":"BEq"},{"typeNames":["Mathlib.Tactic.RingNF.Config"],"name":"Mathlib.Tactic.RingNF.instReprConfig","className":"Repr"}],"imports":["Init","Mathlib.Tactic.Ring.Basic","Mathlib.Tactic.Conv","Mathlib.Util.Qq"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L267-L268","name":"Mathlib.Tactic.RingNF.convRing!","line":267,"kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.convRing!","doc":"The tactic `ring` evaluates expressions in *commutative* (semi)rings.\nThis is the conv tactic version, which rewrites a target which is a ring equality to `True`.\n\nSee also the `ring` tactic.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.convRing!\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">convRing!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L265-L266","name":"Mathlib.Tactic.RingNF.ringConv","line":265,"kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ringConv","doc":"The tactic `ring` evaluates expressions in *commutative* (semi)rings.\nThis is the conv tactic version, which rewrites a target which is a ring equality to `True`.\n\nSee also the `ring` tactic.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ringConv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">ringConv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L256-L257","name":"Mathlib.Tactic.RingNF.tacticRing!","line":256,"kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.tacticRing!","doc":"Tactic for evaluating expressions in *commutative* (semi)rings, allowing for variables in the\nexponent.\n\n* `ring!` will use a more aggressive reducibility setting to determine equality of atoms.\n* `ring1` fails if the target is not an equality.\n\nFor example:\n```\nexample (n : ℕ) (m : ℤ) : 2^(n+1) * m = 2 * 2^n * m := by ring\nexample (a b : ℤ) (n : ℕ) : (a + b)^(n + 2) = (a^2 + b^2 + a * b + b * a) * (a + b)^n := by ring\nexample (x y : ℕ) : x + id y = y + id x := by ring!\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.tacticRing!\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">tacticRing!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L254-L255","name":"Mathlib.Tactic.RingNF.ring","line":254,"kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ring","doc":"Tactic for evaluating expressions in *commutative* (semi)rings, allowing for variables in the\nexponent.\n\n* `ring!` will use a more aggressive reducibility setting to determine equality of atoms.\n* `ring1` fails if the target is not an equality.\n\nFor example:\n```\nexample (n : ℕ) (m : ℤ) : 2^(n+1) * m = 2 * 2^n * m := by ring\nexample (a b : ℤ) (n : ℕ) : (a + b)^(n + 2) = (a^2 + b^2 + a * b + b * a) * (a + b)^n := by ring\nexample (x y : ℕ) : x + id y = y + id x := by ring!\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ring\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">ring</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L238-L238","name":"Mathlib.Tactic.RingNF.convRing_nf!_","line":238,"kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.convRing_nf!_","doc":"Simplification tactic for expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form.\n* `ring_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `ring_nf (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `ring_nf` will also recurse into atoms\n* `ring_nf` works as both a tactic and a conv tactic.\n  In tactic mode, `ring_nf at h` can be used to rewrite in a hypothesis.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.convRing_nf!_\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">convRing_nf!_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L230-L236","name":"Mathlib.Tactic.RingNF.elabRingNFConv","line":230,"kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.elabRingNFConv","doc":"Elaborator for the `ring_nf` tactic. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.elabRingNFConv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">elabRingNFConv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.Tactic\">Lean.Elab.Tactic.Tactic</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L227-L227","name":"Mathlib.Tactic.RingNF.tacticRing1_nf!_","line":227,"kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.tacticRing1_nf!_","doc":"Tactic for solving equations of *commutative* (semi)rings, allowing variables in the exponent.\n\n* This version of `ring1` uses `ring_nf` to simplify in atoms.\n* The variant `ring1_nf!` will use a more aggressive reducibility setting\n  to determine equality of atoms.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.tacticRing1_nf!_\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">tacticRing1_nf!_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L214-L225","name":"Mathlib.Tactic.RingNF.ring1NF","line":214,"kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ring1NF","doc":"Tactic for solving equations of *commutative* (semi)rings, allowing variables in the exponent.\n\n* This version of `ring1` uses `ring_nf` to simplify in atoms.\n* The variant `ring1_nf!` will use a more aggressive reducibility setting\n  to determine equality of atoms.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ring1NF\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">ring1NF</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L212-L212","name":"Mathlib.Tactic.RingNF.ringNFConv","line":212,"kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ringNFConv","doc":"Simplification tactic for expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form.\n* `ring_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `ring_nf (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `ring_nf` will also recurse into atoms\n* `ring_nf` works as both a tactic and a conv tactic.\n  In tactic mode, `ring_nf at h` can be used to rewrite in a hypothesis.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ringNFConv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">ringNFConv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L209-L210","name":"Mathlib.Tactic.RingNF.tacticRing_nf!__","line":209,"kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.tacticRing_nf!__","doc":"Simplification tactic for expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form.\n* `ring_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `ring_nf (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `ring_nf` will also recurse into atoms\n* `ring_nf` works as both a tactic and a conv tactic.\n  In tactic mode, `ring_nf at h` can be used to rewrite in a hypothesis.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.tacticRing_nf!__\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">tacticRing_nf!__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L191-L207","name":"Mathlib.Tactic.RingNF.ringNF","line":191,"kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ringNF","doc":"Simplification tactic for expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form.\n* `ring_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `ring_nf (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `recursive`: if true, `ring_nf` will also recurse into atoms\n* `ring_nf` works as both a tactic and a conv tactic.\n  In tactic mode, `ring_nf at h` can be used to rewrite in a hypothesis.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ringNF\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">ringNF</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L182-L189","name":"Mathlib.Tactic.RingNF.ringNFLocalDecl","line":182,"kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ringNFLocalDecl","doc":"Use `ring_nf` to rewrite hypothesis `h`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ringNFLocalDecl\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">ringNFLocalDecl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Init/System/IO.html#IO.Ref\">IO.Ref</a> <a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State\">Mathlib.Tactic.AtomM.State</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config\">Mathlib.Tactic.RingNF.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fvarId : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L171-L179","name":"Mathlib.Tactic.RingNF.ringNFTarget","line":171,"kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ringNFTarget","doc":"Use `ring_nf` to rewrite the main goal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.ringNFTarget\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">ringNFTarget</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Init/System/IO.html#IO.Ref\">IO.Ref</a> <a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State\">Mathlib.Tactic.AtomM.State</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config\">Mathlib.Tactic.RingNF.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L159-L161","name":"Mathlib.Tactic.RingNF.M.run.evalAtom","line":159,"kind":"opaque","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.M.run.evalAtom","doc":"The atom evaluator calls either `RingNF.rewrite` recursively,\nor nothing depending on `cfg.recursive`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.M.run.evalAtom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">M</span>.<span class=\"name\">run</span>.<span class=\"name\">evalAtom</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Init/System/IO.html#IO.Ref\">IO.Ref</a> <a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State\">Mathlib.Tactic.AtomM.State</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config\">Mathlib.Tactic.RingNF.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(nctx : <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Context\">Mathlib.Tactic.RingNF.Context</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L156-L156","name":"Mathlib.Tactic.RingNF.M.run.rctx","line":156,"kind":"opaque","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.M.run.rctx","doc":"The recursive context. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.M.run.rctx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">M</span>.<span class=\"name\">run</span>.<span class=\"name\">rctx</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Init/System/IO.html#IO.Ref\">IO.Ref</a> <a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State\">Mathlib.Tactic.AtomM.State</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config\">Mathlib.Tactic.RingNF.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(nctx : <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Context\">Mathlib.Tactic.RingNF.Context</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.Context\">Mathlib.Tactic.AtomM.Context</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L136-L162","name":"Mathlib.Tactic.RingNF.M.run","line":136,"kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.M.run","doc":"Runs a tactic in the `RingNF.M` monad, given initial data:\n\n* `s`: a reference to the mutable state of `ring`, for persisting across calls.\n  This ensures that atom ordering is used consistently.\n* `cfg`: the configuration options\n* `x`: the tactic to run\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.M.run\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">M</span>.<span class=\"name\">run</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\"><a href=\"./Init/System/IO.html#IO.Ref\">IO.Ref</a> <a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM.State\">Mathlib.Tactic.AtomM.State</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config\">Mathlib.Tactic.RingNF.Config</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.M\">Mathlib.Tactic.RingNF.M</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L125-L126","name":"Mathlib.Tactic.RingNF.rat_rawCast_neg","line":125,"kind":"theorem","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.rat_rawCast_neg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.rat_rawCast_neg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">rat_rawCast_neg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{d : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{R : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionRing\">DivisionRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Rat.rawCast\">Rat.rawCast</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Data/Int/Basic.html#Int.negOfNat\">Int.negOfNat</a> <span class=\"fn\">n</span></span>)</span> <span class=\"fn\">d</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Int.rawCast\">Int.rawCast</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Data/Int/Basic.html#Int.negOfNat\">Int.negOfNat</a> <span class=\"fn\">n</span></span>)</span></span> <a href=\"./Init/Prelude.html#HDiv.hDiv\">/</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">d</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L123-L124","name":"Mathlib.Tactic.RingNF.rat_rawCast_pos","line":123,"kind":"theorem","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.rat_rawCast_pos","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.rat_rawCast_pos\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">rat_rawCast_pos</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{d : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{R : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Field/Defs.html#DivisionRing\">DivisionRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Rat.rawCast\">Rat.rawCast</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Data/Int/Basic.html#Int.ofNat\">Int.ofNat</a> <span class=\"fn\">n</span></span>)</span> <span class=\"fn\">d</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#HDiv.hDiv\">/</a> <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">d</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L122-L122","name":"Mathlib.Tactic.RingNF.int_rawCast_neg","line":122,"kind":"theorem","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.int_rawCast_neg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.int_rawCast_neg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">int_rawCast_neg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{R : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Int.rawCast\">Int.rawCast</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Data/Int/Basic.html#Int.negOfNat\">Int.negOfNat</a> <span class=\"fn\">n</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">n</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L121-L121","name":"Mathlib.Tactic.RingNF.nat_rawCast_2","line":121,"kind":"theorem","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.nat_rawCast_2","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.nat_rawCast_2\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">nat_rawCast_2</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{R : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{n : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Data/Nat/Cast/Defs.html#Nat.AtLeastTwo\">Nat.AtLeastTwo</a> <span class=\"fn\">n</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#OfNat.ofNat\">OfNat.ofNat</a> <span class=\"fn\">n</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L120-L120","name":"Mathlib.Tactic.RingNF.nat_rawCast_1","line":120,"kind":"theorem","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.nat_rawCast_1","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.nat_rawCast_1\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">nat_rawCast_1</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{R : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">1</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">1</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L119-L119","name":"Mathlib.Tactic.RingNF.nat_rawCast_0","line":119,"kind":"theorem","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.nat_rawCast_0","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.nat_rawCast_0\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">nat_rawCast_0</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{R : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Nat.rawCast\">Nat.rawCast</a> <span class=\"fn\">0</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L118-L118","name":"Mathlib.Tactic.RingNF.add_neg","line":118,"kind":"theorem","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.add_neg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.add_neg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">add_neg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{R : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">b</span></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">b</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L117-L117","name":"Mathlib.Tactic.RingNF.mul_neg","line":117,"kind":"theorem","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.mul_neg","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.mul_neg\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">mul_neg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{R : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">b</span></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L116-L116","name":"Mathlib.Tactic.RingNF.mul_assoc_rev","line":116,"kind":"theorem","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.mul_assoc_rev","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.mul_assoc_rev\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">mul_assoc_rev</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{R : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(c : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">c</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">c</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L115-L115","name":"Mathlib.Tactic.RingNF.add_assoc_rev","line":115,"kind":"theorem","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.add_assoc_rev","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.add_assoc_rev\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">add_assoc_rev</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{R : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(c : <span class=\"fn\">R</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">c</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">c</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L92-L111","name":"Mathlib.Tactic.RingNF.rewrite","line":92,"kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.rewrite","doc":"A tactic in the `RingNF.M` monad which will simplify expression `parent` to a normal form.\n* `root`: true if this is a direct call to the function.\n  `RingNF.M.run` sets this to `false` in recursive mode.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.rewrite\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">rewrite</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(parent : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(root : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.M\">Mathlib.Tactic.RingNF.M</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L85-L85","name":"Mathlib.Tactic.RingNF.M","line":85,"kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.M","doc":"The monad for `RingNF` contains, in addition to the `AtomM` state,\na simp context for the main traversal and a simp function (which has another simp context)\nto simplify normalized polynomials. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.M\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">M</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./foundational_types.html\">Type</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L80-L80","name":"Mathlib.Tactic.RingNF.Context.simp","line":80,"kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Context.simp","doc":"A cleanup routine, which simplifies normalized polynomials to a more human-friendly\nformat. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Context.simp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">Context</span>.<span class=\"name\">simp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Context\">Mathlib.Tactic.RingNF.Context</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.SimpM\">Lean.Meta.SimpM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L77-L77","name":"Mathlib.Tactic.RingNF.Context.ctx","line":77,"kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Context.ctx","doc":"A basically empty simp context, passed to the `simp` traversal in `RingNF.rewrite`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Context.ctx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">Context</span>.<span class=\"name\">ctx</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Context\">Mathlib.Tactic.RingNF.Context</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Context\">Lean.Meta.Simp.Context</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L75-L75","name":"Mathlib.Tactic.RingNF.Context.mk","line":75,"kind":"ctor","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Context.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Context.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">Context</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ctx : <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Context\">Lean.Meta.Simp.Context</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(simp : <span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.SimpM\">Lean.Meta.SimpM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Context\">Mathlib.Tactic.RingNF.Context</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L75-L80","name":"Mathlib.Tactic.RingNF.Context","line":75,"kind":"structure","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Context","doc":"The read-only state of the `RingNF` monad. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Context\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">Context</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L71-L72","name":"Mathlib.Tactic.RingNF.elabConfig","line":71,"kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.elabConfig","doc":"Function elaborating `RingNF.Config`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.elabConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">elabConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config\">Mathlib.Tactic.RingNF.Config</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L69-L69","name":"Mathlib.Tactic.RingNF.instReprConfig","line":69,"kind":"instance","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instReprConfig","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instReprConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">instReprConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config\">Mathlib.Tactic.RingNF.Config</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L69-L69","name":"Mathlib.Tactic.RingNF.instBEqConfig","line":69,"kind":"instance","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instBEqConfig","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instBEqConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">instBEqConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config\">Mathlib.Tactic.RingNF.Config</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L69-L69","name":"Mathlib.Tactic.RingNF.instInhabitedConfig","line":69,"kind":"instance","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instInhabitedConfig","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instInhabitedConfig\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">instInhabitedConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config\">Mathlib.Tactic.RingNF.Config</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L68-L68","name":"Mathlib.Tactic.RingNF.Config.mode","line":68,"kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config.mode","doc":"The normalization style. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config.mode\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">Config</span>.<span class=\"name\">mode</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config\">Mathlib.Tactic.RingNF.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode\">Mathlib.Tactic.RingNF.RingMode</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L66-L66","name":"Mathlib.Tactic.RingNF.Config.recursive","line":66,"kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config.recursive","doc":"if true, atoms inside ring expressions will be reduced recursively "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config.recursive\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">Config</span>.<span class=\"name\">recursive</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config\">Mathlib.Tactic.RingNF.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L64-L64","name":"Mathlib.Tactic.RingNF.Config.red","line":64,"kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config.red","doc":"the reducibility setting to use when comparing atoms for defeq "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config.red\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">Config</span>.<span class=\"name\">red</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config\">Mathlib.Tactic.RingNF.Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L62-L62","name":"Mathlib.Tactic.RingNF.Config.mk","line":62,"kind":"ctor","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">Config</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(red : <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(recursive : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(mode : <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode\">Mathlib.Tactic.RingNF.RingMode</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config\">Mathlib.Tactic.RingNF.Config</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L62-L69","name":"Mathlib.Tactic.RingNF.Config","line":62,"kind":"structure","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config","doc":"Configuration for `ring_nf`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.Config\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">Config</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L59-L59","name":"Mathlib.Tactic.RingNF.instReprRingMode","line":59,"kind":"instance","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instReprRingMode","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instReprRingMode\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">instReprRingMode</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode\">Mathlib.Tactic.RingNF.RingMode</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L59-L59","name":"Mathlib.Tactic.RingNF.instBEqRingMode","line":59,"kind":"instance","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instBEqRingMode","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instBEqRingMode\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">instBEqRingMode</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode\">Mathlib.Tactic.RingNF.RingMode</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L59-L59","name":"Mathlib.Tactic.RingNF.instInhabitedRingMode","line":59,"kind":"instance","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instInhabitedRingMode","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.instInhabitedRingMode\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">instInhabitedRingMode</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode\">Mathlib.Tactic.RingNF.RingMode</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L57-L58","name":"Mathlib.Tactic.RingNF.RingMode.raw","line":57,"kind":"ctor","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode.raw","doc":"Raw form: the representation `ring` uses internally. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode.raw\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">RingMode</span>.<span class=\"name\">raw</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode\">Mathlib.Tactic.RingNF.RingMode</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L55-L56","name":"Mathlib.Tactic.RingNF.RingMode.SOP","line":55,"kind":"ctor","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode.SOP","doc":"Sum-of-products form, like `x + x * y * 2 + z ^ 2`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode.SOP\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">RingMode</span>.<span class=\"name\">SOP</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode\">Mathlib.Tactic.RingNF.RingMode</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L54-L59","name":"Mathlib.Tactic.RingNF.RingMode","line":54,"kind":"inductive","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode","doc":"The normalization style for `ring_nf`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.RingNF.RingMode\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RingNF</span>.<span class=\"name\">RingMode</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L42-L46","name":"Mathlib.Tactic.Ring.ExSum.isAtom","line":42,"kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.Ring.ExSum.isAtom","doc":"True if this represents an atomic expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.Ring.ExSum.isAtom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExSum</span>.<span class=\"name\">isAtom</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">{<span class=\"fn\">a</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>} →\n  <span class=\"fn\">{<span class=\"fn\">arg</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> a)</span>} → <span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$arg»</span></span>)</span>} → <span class=\"fn\">{<span class=\"fn\">a_1</span> : <span class=\"fn\">Q(<span class=\"fn\">«$arg»</span>)</span>} → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExSum\">Mathlib.Tactic.Ring.ExSum</a> <span class=\"fn\">sα</span> <span class=\"fn\">a_1</span></span> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L37-L39","name":"Mathlib.Tactic.Ring.ExProd.isAtom","line":37,"kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.Ring.ExProd.isAtom","doc":"True if this represents an atomic expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.Ring.ExProd.isAtom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExProd</span>.<span class=\"name\">isAtom</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">{<span class=\"fn\">a</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>} →\n  <span class=\"fn\">{<span class=\"fn\">arg</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> a)</span>} → <span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$arg»</span></span>)</span>} → <span class=\"fn\">{<span class=\"fn\">a_1</span> : <span class=\"fn\">Q(<span class=\"fn\">«$arg»</span>)</span>} → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExProd\">Mathlib.Tactic.Ring.ExProd</a> <span class=\"fn\">sα</span> <span class=\"fn\">a_1</span></span> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Ring/RingNF.lean#L32-L34","name":"Mathlib.Tactic.Ring.ExBase.isAtom","line":32,"kind":"def","docLink":"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.Ring.ExBase.isAtom","doc":"True if this represents an atomic expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Ring/RingNF.html#Mathlib.Tactic.Ring.ExBase.isAtom\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ring</span>.<span class=\"name\">ExBase</span>.<span class=\"name\">isAtom</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">{<span class=\"fn\">a</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>} →\n  <span class=\"fn\">{<span class=\"fn\">arg</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> a)</span>} → <span class=\"fn\">{<span class=\"fn\">sα</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">«$arg»</span></span>)</span>} → <span class=\"fn\">{<span class=\"fn\">a_1</span> : <span class=\"fn\">Q(<span class=\"fn\">«$arg»</span>)</span>} → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Ring/Basic.html#Mathlib.Tactic.Ring.ExBase\">Mathlib.Tactic.Ring.ExBase</a> <span class=\"fn\">sα</span> <span class=\"fn\">a_1</span></span> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></span></span></span></span></div></div>"}]}