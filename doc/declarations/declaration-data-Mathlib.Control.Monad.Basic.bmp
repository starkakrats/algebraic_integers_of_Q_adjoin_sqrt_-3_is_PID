{"name":"Mathlib.Control.Monad.Basic","instances":[],"imports":["Init","Mathlib.Logic.Equiv.Defs"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Control/Monad/Basic.lean#L63-L65","name":"ReaderT.equiv","line":63,"kind":"def","docLink":"./Mathlib/Control/Monad/Basic.html#ReaderT.equiv","doc":"reduce the equivalence between two reader monads to the equivalence between\ntheir respective function spaces "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Control/Monad/Basic.html#ReaderT.equiv\"><span class=\"name\">ReaderT</span>.<span class=\"name\">equiv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ρ₁ : <a href=\"./foundational_types.html\">Type</a> u₀}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α₁ : <a href=\"./foundational_types.html\">Type</a> u₀}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ρ₂ : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α₂ : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{m₁ : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> u₀ → <a href=\"./foundational_types.html\">Type</a> v₀</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{m₂ : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> u₁ → <a href=\"./foundational_types.html\">Type</a> v₁</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">ρ₁</span> → <span class=\"fn\"><span class=\"fn\">m₁</span> <span class=\"fn\">α₁</span></span></span>)</span> <a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv\">≃</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">ρ₂</span> → <span class=\"fn\"><span class=\"fn\">m₂</span> <span class=\"fn\">α₂</span></span></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#ReaderT\">ReaderT</a> <span class=\"fn\">ρ₁</span> <span class=\"fn\">m₁</span> <span class=\"fn\">α₁</span></span> <a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv\">≃</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#ReaderT\">ReaderT</a> <span class=\"fn\">ρ₂</span> <span class=\"fn\">m₂</span> <span class=\"fn\">α₂</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Control/Monad/Basic.lean#L56-L58","name":"StateT.equiv","line":56,"kind":"def","docLink":"./Mathlib/Control/Monad/Basic.html#StateT.equiv","doc":"reduce the equivalence between two state monads to the equivalence between\ntheir respective function spaces "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Control/Monad/Basic.html#StateT.equiv\"><span class=\"name\">StateT</span>.<span class=\"name\">equiv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{σ₁ : <a href=\"./foundational_types.html\">Type</a> u₀}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α₁ : <a href=\"./foundational_types.html\">Type</a> u₀}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{σ₂ : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α₂ : <a href=\"./foundational_types.html\">Type</a> u₁}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{m₁ : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> u₀ → <a href=\"./foundational_types.html\">Type</a> v₀</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{m₂ : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> u₁ → <a href=\"./foundational_types.html\">Type</a> v₁</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(F : <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">σ₁</span> → <span class=\"fn\"><span class=\"fn\">m₁</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">α₁</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">σ₁</span></span>)</span></span></span>)</span> <a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv\">≃</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">σ₂</span> → <span class=\"fn\"><span class=\"fn\">m₂</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">α₂</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">σ₂</span></span>)</span></span></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Control/State.html#StateT\">StateT</a> <span class=\"fn\">σ₁</span> <span class=\"fn\">m₁</span> <span class=\"fn\">α₁</span></span> <a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv\">≃</a> <span class=\"fn\"><a href=\"./Init/Control/State.html#StateT\">StateT</a> <span class=\"fn\">σ₂</span> <span class=\"fn\">m₂</span> <span class=\"fn\">α₂</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Control/Monad/Basic.lean#L50-L51","name":"StateT.eval","line":50,"kind":"def","docLink":"./Mathlib/Control/Monad/Basic.html#StateT.eval","doc":"run a `StateT` program and discard the final state "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Control/Monad/Basic.html#StateT.eval\"><span class=\"name\">StateT</span>.<span class=\"name\">eval</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{σ : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{m : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> u → <a href=\"./foundational_types.html\">Type</a> v</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Functor\">Functor</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(cmd : <span class=\"fn\"><a href=\"./Init/Control/State.html#StateT\">StateT</a> <span class=\"fn\">σ</span> <span class=\"fn\">m</span> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(s : <span class=\"fn\">σ</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Control/Monad/Basic.lean#L44-L46","name":"map_eq_bind_pure_comp","line":44,"kind":"theorem","docLink":"./Mathlib/Control/Monad/Basic.html#map_eq_bind_pure_comp","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Control/Monad/Basic.html#map_eq_bind_pure_comp\"><span class=\"name\">map_eq_bind_pure_comp</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(m : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> u → <a href=\"./foundational_types.html\">Type</a> v</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Control/Lawful.html#LawfulMonad\">LawfulMonad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Functor.map\">&lt;$&gt;</a> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Bind.bind\">&gt;&gt;=</a> <span class=\"fn\"><span class=\"fn\">pure</span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\">f</span></span></span></span></div></div>"}]}