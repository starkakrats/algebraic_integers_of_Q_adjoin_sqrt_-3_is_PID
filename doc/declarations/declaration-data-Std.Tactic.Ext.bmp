{"name":"Std.Tactic.Ext","instances":[],"imports":["Init","Std.Tactic.Basic","Std.Tactic.RCases","Std.Tactic.Ext.Attr"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Ext.lean#L233-L233","name":"Unit.ext","line":233,"kind":"theorem","docLink":"./Std/Tactic/Ext.html#Unit.ext","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Ext.html#Unit.ext\"><span class=\"name\">Unit</span>.<span class=\"name\">ext</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(x : <a href=\"./Init/Prelude.html#Unit\">Unit</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(y : <a href=\"./Init/Prelude.html#Unit\">Unit</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Ext.lean#L232-L232","name":"PUnit.ext","line":232,"kind":"theorem","docLink":"./Std/Tactic/Ext.html#PUnit.ext","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Ext.html#PUnit.ext\"><span class=\"name\">PUnit</span>.<span class=\"name\">ext</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(x : <a href=\"./Init/Prelude.html#PUnit\">PUnit</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(y : <a href=\"./Init/Prelude.html#PUnit\">PUnit</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Ext.lean#L229-L230","name":"PSigma.ext","line":229,"kind":"theorem","docLink":"./Std/Tactic/Ext.html#PSigma.ext","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Ext.html#PSigma.ext\"><span class=\"name\">PSigma</span>.<span class=\"name\">ext</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∀ {<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Sort</a> u_1} {<span class=\"fn\">β</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Sort</a> u_2</span>} {<span class=\"fn\">x </span>y : <span class=\"fn\"><a href=\"./Init/Core.html#PSigma\">PSigma</a> <span class=\"fn\">β</span></span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x</span>.fst</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">y</span>.fst</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#HEq\">HEq</a> <span class=\"fn\"><span class=\"fn\">x</span>.snd</span> <span class=\"fn\"><span class=\"fn\">y</span>.snd</span></span> → <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Ext.lean#L226-L227","name":"Sigma.ext","line":226,"kind":"theorem","docLink":"./Std/Tactic/Ext.html#Sigma.ext","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Ext.html#Sigma.ext\"><span class=\"name\">Sigma</span>.<span class=\"name\">ext</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∀ {<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1} {<span class=\"fn\">β</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Type</a> u_2</span>} {<span class=\"fn\">x </span>y : <span class=\"fn\"><a href=\"./Init/Core.html#Sigma\">Sigma</a> <span class=\"fn\">β</span></span>}, <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x</span>.fst</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">y</span>.fst</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#HEq\">HEq</a> <span class=\"fn\"><span class=\"fn\">x</span>.snd</span> <span class=\"fn\"><span class=\"fn\">y</span>.snd</span></span> → <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Ext.lean#L223-L224","name":"PProd.ext","line":223,"kind":"theorem","docLink":"./Std/Tactic/Ext.html#PProd.ext","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Ext.html#PProd.ext\"><span class=\"name\">PProd</span>.<span class=\"name\">ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{x : <span class=\"fn\"><a href=\"./Init/Prelude.html#PProd\">PProd</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{y : <span class=\"fn\"><a href=\"./Init/Prelude.html#PProd\">PProd</a> <span class=\"fn\">α</span> <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x</span>.fst</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">y</span>.fst</span></span> → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x</span>.snd</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">y</span>.snd</span></span> → <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Ext.lean#L220-L221","name":"Prod.ext","line":220,"kind":"theorem","docLink":"./Std/Tactic/Ext.html#Prod.ext","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Ext.html#Prod.ext\"><span class=\"name\">Prod</span>.<span class=\"name\">ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{x : <span class=\"fn\"><span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{y : <span class=\"fn\"><span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">β</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x</span>.fst</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">y</span>.fst</span></span> → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">x</span>.snd</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">y</span>.snd</span></span> → <span class=\"fn\"><span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">y</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Ext.lean#L213-L214","name":"Std.Tactic.Ext.«tacticExt?___:_»","line":213,"kind":"def","docLink":"./Std/Tactic/Ext.html#Std.Tactic.Ext.«tacticExt?___:_»","doc":"`ext? pat*` is like `ext pat*` but gives a suggestion on what pattern to use "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Ext.html#Std.Tactic.Ext.«tacticExt?___:_»\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ext</span>.<span class=\"name\">«tacticExt?___:_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Ext.lean#L211-L212","name":"Std.Tactic.Ext.tacticExt1?___","line":211,"kind":"def","docLink":"./Std/Tactic/Ext.html#Std.Tactic.Ext.tacticExt1?___","doc":"`ext1? pat*` is like `ext1 pat*` but gives a suggestion on what pattern to use "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Ext.html#Std.Tactic.Ext.tacticExt1?___\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ext</span>.<span class=\"name\">tacticExt1?___</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Ext.lean#L206-L208","name":"Std.Tactic.Ext.tacticExt1___","line":206,"kind":"def","docLink":"./Std/Tactic/Ext.html#Std.Tactic.Ext.tacticExt1___","doc":"`ext1 pat*` is like `ext pat*` except that it only applies a single extensionality lemma rather\nthan recursively applying as many extensionality lemmas as possible.\n\nThe `pat*` patterns are processed using the `rintro` tactic.\nIf no patterns are supplied, then variables are introduced anonymously using the `intros` tactic.\n\nThe `ext1?` tactic (note: unimplemented) has the same syntax as the `ext1?` tactic,\nand it gives a suggestion of an equivalent tactic to use in place of `ext1`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Ext.html#Std.Tactic.Ext.tacticExt1___\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ext</span>.<span class=\"name\">tacticExt1___</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Ext.lean#L171-L184","name":"Std.Tactic.Ext.«tacticExt___:_»","line":171,"kind":"def","docLink":"./Std/Tactic/Ext.html#Std.Tactic.Ext.«tacticExt___:_»","doc":"* `ext pat*` applies extensionality lemmas as much as possible,\n  using `pat*` to introduce the variables in extensionality lemmas using `rintro`.\n  For example, this names the variables introduced by lemmas such as `funext`.\n* `ext` applies extensionality lemmas as much as possible\n  but introduces anonymous variables whenever needed.\n* `ext pat* : n` applies ext lemmas only up to depth `n`.\n\nThe `ext1 pat*` tactic is like `ext pat*` except that it only applies a single extensionality lemma.\n\nThe `ext?` tactic (note: unimplemented) has the same syntax as the `ext` tactic,\nand it gives a suggestion of an equivalent tactic to use in place of `ext`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Ext.html#Std.Tactic.Ext.«tacticExt___:_»\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ext</span>.<span class=\"name\">«tacticExt___:_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Ext.lean#L165-L169","name":"Std.Tactic.Ext.extCore","line":165,"kind":"def","docLink":"./Std/Tactic/Ext.html#Std.Tactic.Ext.extCore","doc":"Apply extensionality lemmas as much as possible, using `pats` to introduce the variables\nin extensionality lemmas like `funext`. Returns a list of subgoals.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Ext.html#Std.Tactic.Ext.extCore\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ext</span>.<span class=\"name\">extCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(pats : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`rcasesPat</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(depth : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <span class=\"fn\">1000000</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(failIfUnchanged : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">Nat</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`rcasesPat</span></span>)</span></span></span>)</span></span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Ext.lean#L149-L159","name":"Std.Tactic.Ext.withExtN","line":149,"kind":"def","docLink":"./Std/Tactic/Ext.html#Std.Tactic.Ext.withExtN","doc":"Applies a extensionality lemmas recursively, using `pats` to introduce variables in the result.\nRuns continuation `k` on each subgoal.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Ext.html#Std.Tactic.Ext.withExtN\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ext</span>.<span class=\"name\">withExtN</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{m : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a> u_1</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadLiftT\">MonadLiftT</a> <a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadExcept\">MonadExcept</a> <a href=\"./Lean/Exception.html#Lean.Exception\">Lean.Exception</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(pats : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`rcasesPat</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`rcasesPat</span></span>)</span></span> → <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(depth : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Nat\">Nat</a> <span class=\"fn\">1000000</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(failIfUnchanged : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Ext.lean#L138-L143","name":"Std.Tactic.Ext.withExt1","line":138,"kind":"def","docLink":"./Std/Tactic/Ext.html#Std.Tactic.Ext.withExt1","doc":"Applies a single extensionality lemma, using `pats` to introduce variables in the result.\nRuns continuation `k` on each subgoal.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Ext.html#Std.Tactic.Ext.withExt1\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ext</span>.<span class=\"name\">withExt1</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{m : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a> u_1</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadLiftT\">MonadLiftT</a> <a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(pats : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`rcasesPat</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`rcasesPat</span></span>)</span></span> → <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Ext.lean#L122-L132","name":"Std.Tactic.Ext.tryIntros","line":122,"kind":"def","docLink":"./Std/Tactic/Ext.html#Std.Tactic.Ext.tryIntros","doc":"Postprocessor for `withExt` which runs `rintro` with the given patterns when the target is a\npi type.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Ext.html#Std.Tactic.Ext.tryIntros\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ext</span>.<span class=\"name\">tryIntros</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{m : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a> u_1</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#MonadLiftT\">MonadLiftT</a> <a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(pats : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`rcasesPat</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`rcasesPat</span></span>)</span></span> → <span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <a href=\"./Init/Prelude.html#Nat\">Nat</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Ext.lean#L115-L116","name":"Std.Tactic.Ext.tacticApply_ext_lemma","line":115,"kind":"def","docLink":"./Std/Tactic/Ext.html#Std.Tactic.Ext.tacticApply_ext_lemma","doc":"Apply a single extensionality lemma to the current goal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Ext.html#Std.Tactic.Ext.tacticApply_ext_lemma\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ext</span>.<span class=\"name\">tacticApply_ext_lemma</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Ext.lean#L92-L113","name":"Std.Tactic.Ext.applyExtLemma","line":92,"kind":"def","docLink":"./Std/Tactic/Ext.html#Std.Tactic.Ext.applyExtLemma","doc":"Apply a single extensionality lemma to `goal`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Ext.html#Std.Tactic.Ext.applyExtLemma\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ext</span>.<span class=\"name\">applyExtLemma</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(goal : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Ext.lean#L66-L73","name":"Std.Tactic.Ext.«termExt_iff_type%___»","line":66,"kind":"def","docLink":"./Std/Tactic/Ext.html#Std.Tactic.Ext.«termExt_iff_type%___»","doc":"Creates the type of the iff-variant of the extensionality lemma for the given structure,\nelaborating to `x = y ↔ x.1 = y.1 ∧ x.2 = y.2`, for example.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Ext.html#Std.Tactic.Ext.«termExt_iff_type%___»\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ext</span>.<span class=\"name\">«termExt_iff_type%___»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Ext.lean#L61-L64","name":"Std.Tactic.Ext.mkAndN","line":61,"kind":"def","docLink":"./Std/Tactic/Ext.html#Std.Tactic.Ext.mkAndN","doc":"Make an n-ary `And` application. `mkAndN []` returns `True`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Ext.html#Std.Tactic.Ext.mkAndN\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ext</span>.<span class=\"name\">mkAndN</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Ext.lean#L58-L58","name":"Std.Tactic.Ext.mkIff","line":58,"kind":"def","docLink":"./Std/Tactic/Ext.html#Std.Tactic.Ext.mkIff","doc":"Make an `Iff` application. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Ext.html#Std.Tactic.Ext.mkIff\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ext</span>.<span class=\"name\">mkIff</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(q : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Ext.lean#L47-L55","name":"Std.Tactic.Ext.«termExt_type%___»","line":47,"kind":"def","docLink":"./Std/Tactic/Ext.html#Std.Tactic.Ext.«termExt_type%___»","doc":"Creates the type of the extensionality lemma for the given structure,\nelaborating to `x.1 = y.1 → x.2 = y.2 → x = y`, for example.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Ext.html#Std.Tactic.Ext.«termExt_type%___»\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ext</span>.<span class=\"name\">«termExt_type%___»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Ext.lean#L19-L45","name":"Std.Tactic.Ext.withExtHyps","line":19,"kind":"def","docLink":"./Std/Tactic/Ext.html#Std.Tactic.Ext.withExtHyps","doc":"Constructs the hypotheses for the extensionality lemma.\nCalls the continuation `k` with the list of parameters to the structure,\ntwo structure variables `x` and `y`, and a list of pairs `(field, ty)`\nwhere `ty` is `x.field = y.field` or `HEq x.field y.field`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Ext.html#Std.Tactic.Ext.withExtHyps\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Ext</span>.<span class=\"name\">withExtHyps</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(struct : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(flat : <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> → <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">α</span></span></div></div>"}]}