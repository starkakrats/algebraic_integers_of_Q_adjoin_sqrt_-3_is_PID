{"name":"Std.Tactic.Omega.Config","instances":[],"imports":["Init","Lean.Elab.Tactic.Config"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Config.lean#L36-L39","name":"Std.Tactic.Omega.elabOmegaConfig","line":36,"kind":"def","docLink":"./Std/Tactic/Omega/Config.html#Std.Tactic.Omega.elabOmegaConfig","doc":"Allow elaboration of `OmegaConfig` arguments to tactics.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Config.html#Std.Tactic.Omega.elabOmegaConfig\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">elabOmegaConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Std/Tactic/Omega/Config.html#Std.Tactic.Omega.OmegaConfig\">Std.Tactic.Omega.OmegaConfig</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Config.lean#L34-L34","name":"Std.Tactic.Omega.OmegaConfig.splitNatAbs","line":34,"kind":"def","docLink":"./Std/Tactic/Omega/Config.html#Std.Tactic.Omega.OmegaConfig.splitNatAbs","doc":"Whenever `Int.natAbs a` is found, register the disjunction\n`0 ≤ a ∧ Int.natAbs a = a ∨ a < 0 ∧ Int.natAbs a = - a` for later splitting.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Config.html#Std.Tactic.Omega.OmegaConfig.splitNatAbs\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">OmegaConfig</span>.<span class=\"name\">splitNatAbs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Std/Tactic/Omega/Config.html#Std.Tactic.Omega.OmegaConfig\">Std.Tactic.Omega.OmegaConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Config.lean#L29-L29","name":"Std.Tactic.Omega.OmegaConfig.splitNatSub","line":29,"kind":"def","docLink":"./Std/Tactic/Omega/Config.html#Std.Tactic.Omega.OmegaConfig.splitNatSub","doc":"Whenever `((a - b : Nat) : Int)` is found, register the disjunction\n`b ≤ a ∧ ((a - b : Nat) : Int) = a - b ∨ a < b ∧ ((a - b : Nat) : Int) = 0`\nfor later splitting.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Config.html#Std.Tactic.Omega.OmegaConfig.splitNatSub\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">OmegaConfig</span>.<span class=\"name\">splitNatSub</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Std/Tactic/Omega/Config.html#Std.Tactic.Omega.OmegaConfig\">Std.Tactic.Omega.OmegaConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Config.lean#L23-L23","name":"Std.Tactic.Omega.OmegaConfig.splitDisjunctions","line":23,"kind":"def","docLink":"./Std/Tactic/Omega/Config.html#Std.Tactic.Omega.OmegaConfig.splitDisjunctions","doc":"Split disjunctions in the context.\n\nNote that with `splitDisjunctions := false` omega will not be able to solve `x = y` goals\nas these are usually handled by introducing `¬ x = y` as a hypothesis, then replacing this with\n`x < y ∨ x > y`.\n\nOn the other hand, `omega` does not currently detect disjunctions which, when split,\nintroduce no new useful information, so the presence of irrelevant disjunctions in the context\ncan significantly increase run time.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Config.html#Std.Tactic.Omega.OmegaConfig.splitDisjunctions\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">OmegaConfig</span>.<span class=\"name\">splitDisjunctions</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Std/Tactic/Omega/Config.html#Std.Tactic.Omega.OmegaConfig\">Std.Tactic.Omega.OmegaConfig</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Config.lean#L11-L11","name":"Std.Tactic.Omega.OmegaConfig.mk","line":11,"kind":"ctor","docLink":"./Std/Tactic/Omega/Config.html#Std.Tactic.Omega.OmegaConfig.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Config.html#Std.Tactic.Omega.OmegaConfig.mk\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">OmegaConfig</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(splitDisjunctions : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(splitNatSub : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(splitNatAbs : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Omega/Config.html#Std.Tactic.Omega.OmegaConfig\">Std.Tactic.Omega.OmegaConfig</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/Omega/Config.lean#L11-L34","name":"Std.Tactic.Omega.OmegaConfig","line":11,"kind":"structure","docLink":"./Std/Tactic/Omega/Config.html#Std.Tactic.Omega.OmegaConfig","doc":"Configures the behaviour of the `omega` tactic. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Omega/Config.html#Std.Tactic.Omega.OmegaConfig\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Omega</span>.<span class=\"name\">OmegaConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"}]}