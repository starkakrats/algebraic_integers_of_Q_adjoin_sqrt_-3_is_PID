{"name":"Mathlib.Data.ByteArray","instances":[{"typeNames":["ByteSlice","UInt8"],"name":"ByteSlice.instForInByteSliceUInt8","className":"ForIn"},{"typeNames":["ByteSlice"],"name":"instToStringByteSlice","className":"ToString"}],"imports":["Init","Mathlib.Data.Nat.Basic","Mathlib.Data.Char","Mathlib.Data.UInt"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/ByteArray.lean#L95-L99","name":"instToStringByteSlice","line":95,"kind":"instance","docLink":"./Mathlib/Data/ByteArray.html#instToStringByteSlice","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/ByteArray.html#instToStringByteSlice\"><span class=\"name\">instToStringByteSlice</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/ToString/Basic.html#ToString\">ToString</a> <a href=\"./Mathlib/Data/ByteArray.html#ByteSlice\">ByteSlice</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/ByteArray.lean#L90-L93","name":"ByteSlice.toString","line":90,"kind":"def","docLink":"./Mathlib/Data/ByteArray.html#ByteSlice.toString","doc":"Convert a byte slice into a string. This does not handle non-ASCII characters correctly:\nevery byte will become a unicode character with codepoint < 256. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/ByteArray.html#ByteSlice.toString\"><span class=\"name\">ByteSlice</span>.<span class=\"name\">toString</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(bs : <a href=\"./Mathlib/Data/ByteArray.html#ByteSlice\">ByteSlice</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#String\">String</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/ByteArray.lean#L78-L84","name":"String.toAsciiByteArray.loop","line":78,"kind":"def","docLink":"./Mathlib/Data/ByteArray.html#String.toAsciiByteArray.loop","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/ByteArray.html#String.toAsciiByteArray.loop\"><span class=\"name\">String</span>.<span class=\"name\">toAsciiByteArray</span>.<span class=\"name\">loop</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Init/Prelude.html#String.Pos\">String.Pos</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(out : <a href=\"./Init/Data/ByteArray/Basic.html#ByteArray\">ByteArray</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/ByteArray/Basic.html#ByteArray\">ByteArray</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/ByteArray.lean#L77-L86","name":"String.toAsciiByteArray","line":77,"kind":"def","docLink":"./Mathlib/Data/ByteArray.html#String.toAsciiByteArray","doc":"Convert a string of assumed-ASCII characters into a byte array.\n(If any characters are non-ASCII they will be reduced modulo 256.) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/ByteArray.html#String.toAsciiByteArray\"><span class=\"name\">String</span>.<span class=\"name\">toAsciiByteArray</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/ByteArray/Basic.html#ByteArray\">ByteArray</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/ByteArray.lean#L73-L73","name":"ByteArray.toSlice","line":73,"kind":"def","docLink":"./Mathlib/Data/ByteArray.html#ByteArray.toSlice","doc":"Convert a byte array into a byte slice. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/ByteArray.html#ByteArray.toSlice\"><span class=\"name\">ByteArray</span>.<span class=\"name\">toSlice</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(arr : <a href=\"./Init/Data/ByteArray/Basic.html#ByteArray\">ByteArray</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Data/ByteArray.html#ByteSlice\">ByteSlice</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/ByteArray.lean#L69-L70","name":"ByteSliceT.toSlice","line":69,"kind":"def","docLink":"./Mathlib/Data/ByteArray.html#ByteSliceT.toSlice","doc":"Convert a terminal byte slice into a regular byte slice. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/ByteArray.html#ByteSliceT.toSlice\"><span class=\"name\">ByteSliceT</span>.<span class=\"name\">toSlice</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/ByteArray.html#ByteSliceT\">ByteSliceT</a> → <a href=\"./Mathlib/Data/ByteArray.html#ByteSlice\">ByteSlice</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/ByteArray.lean#L63-L64","name":"ByteSlice.instForInByteSliceUInt8","line":63,"kind":"instance","docLink":"./Mathlib/Data/ByteArray.html#ByteSlice.instForInByteSliceUInt8","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/ByteArray.html#ByteSlice.instForInByteSliceUInt8\"><span class=\"name\">ByteSlice</span>.<span class=\"name\">instForInByteSliceUInt8</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{m : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> u_1 → <a href=\"./foundational_types.html\">Type</a> u_2</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#ForIn\">ForIn</a> <span class=\"fn\">m</span> <a href=\"./Mathlib/Data/ByteArray.html#ByteSlice\">ByteSlice</a> <a href=\"./Init/Prelude.html#UInt8\">UInt8</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/ByteArray.lean#L54-L61","name":"ByteSlice.forIn.loop","line":54,"kind":"def","docLink":"./Mathlib/Data/ByteArray.html#ByteSlice.forIn.loop","doc":"The inner loop of the `forIn` implementation for byte slices. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/ByteArray.html#ByteSlice.forIn.loop\"><span class=\"name\">ByteSlice</span>.<span class=\"name\">forIn</span>.<span class=\"name\">loop</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{m : <span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> u_1 → <a href=\"./foundational_types.html\">Type</a> u_2</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{β : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#Monad\">Monad</a> <span class=\"fn\">m</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><a href=\"./Init/Prelude.html#UInt8\">UInt8</a> → <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Core.html#ForInStep\">ForInStep</a> <span class=\"fn\">β</span></span>)</span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(arr : <a href=\"./Init/Data/ByteArray/Basic.html#ByteArray\">ByteArray</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(off : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(_end : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(i : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <span class=\"fn\">β</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">m</span> <span class=\"fn\">β</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/ByteArray.lean#L50-L50","name":"ByteSlice.getOp","line":50,"kind":"def","docLink":"./Mathlib/Data/ByteArray.html#ByteSlice.getOp","doc":"Index into a byte slice. The `getOp` function allows the use of the `buf[i]` notation. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/ByteArray.html#ByteSlice.getOp\"><span class=\"name\">ByteSlice</span>.<span class=\"name\">getOp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Data/ByteArray.html#ByteSlice\">ByteSlice</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(idx : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#UInt8\">UInt8</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/ByteArray.lean#L46-L47","name":"ByteSlice.toArray","line":46,"kind":"def","docLink":"./Mathlib/Data/ByteArray.html#ByteSlice.toArray","doc":"Convert a byte slice into an array, by copying the data if necessary. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/ByteArray.html#ByteSlice.toArray\"><span class=\"name\">ByteSlice</span>.<span class=\"name\">toArray</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/ByteArray.html#ByteSlice\">ByteSlice</a> → <a href=\"./Init/Data/ByteArray/Basic.html#ByteArray\">ByteArray</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/ByteArray.lean#L41-L41","name":"ByteSlice.len","line":41,"kind":"def","docLink":"./Mathlib/Data/ByteArray.html#ByteSlice.len","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/ByteArray.html#ByteSlice.len\"><span class=\"name\">ByteSlice</span>.<span class=\"name\">len</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Data/ByteArray.html#ByteSlice\">ByteSlice</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/ByteArray.lean#L41-L41","name":"ByteSlice.off","line":41,"kind":"def","docLink":"./Mathlib/Data/ByteArray.html#ByteSlice.off","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/ByteArray.html#ByteSlice.off\"><span class=\"name\">ByteSlice</span>.<span class=\"name\">off</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Data/ByteArray.html#ByteSlice\">ByteSlice</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/ByteArray.lean#L41-L41","name":"ByteSlice.arr","line":41,"kind":"def","docLink":"./Mathlib/Data/ByteArray.html#ByteSlice.arr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/ByteArray.html#ByteSlice.arr\"><span class=\"name\">ByteSlice</span>.<span class=\"name\">arr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Data/ByteArray.html#ByteSlice\">ByteSlice</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/ByteArray/Basic.html#ByteArray\">ByteArray</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/ByteArray.lean#L41-L41","name":"ByteSlice.mk","line":41,"kind":"ctor","docLink":"./Mathlib/Data/ByteArray.html#ByteSlice.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/ByteArray.html#ByteSlice.mk\"><span class=\"name\">ByteSlice</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(arr : <a href=\"./Init/Data/ByteArray/Basic.html#ByteArray\">ByteArray</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(off : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(len : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Data/ByteArray.html#ByteSlice\">ByteSlice</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/ByteArray.lean#L41-L41","name":"ByteSlice","line":41,"kind":"structure","docLink":"./Mathlib/Data/ByteArray.html#ByteSlice","doc":"A byte slice, given by a backing byte array, and an offset and length. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/ByteArray.html#ByteSlice\"><span class=\"name\">ByteSlice</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/ByteArray.lean#L38-L38","name":"ByteArray.toSliceT","line":38,"kind":"def","docLink":"./Mathlib/Data/ByteArray.html#ByteArray.toSliceT","doc":"Convert a byte array into a terminal slice. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/ByteArray.html#ByteArray.toSliceT\"><span class=\"name\">ByteArray</span>.<span class=\"name\">toSliceT</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(arr : <a href=\"./Init/Data/ByteArray/Basic.html#ByteArray\">ByteArray</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Data/ByteArray.html#ByteSliceT\">ByteSliceT</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/ByteArray.lean#L33-L33","name":"ByteSliceT.getOp","line":33,"kind":"def","docLink":"./Mathlib/Data/ByteArray.html#ByteSliceT.getOp","doc":"Index into a byte slice. The `getOp` function allows the use of the `buf[i]` notation. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/ByteArray.html#ByteSliceT.getOp\"><span class=\"name\">ByteSliceT</span>.<span class=\"name\">getOp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Data/ByteArray.html#ByteSliceT\">ByteSliceT</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(idx : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#UInt8\">UInt8</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/ByteArray.lean#L30-L30","name":"ByteSliceT.size","line":30,"kind":"def","docLink":"./Mathlib/Data/ByteArray.html#ByteSliceT.size","doc":"The number of elements in the byte slice. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/ByteArray.html#ByteSliceT.size\"><span class=\"name\">ByteSliceT</span>.<span class=\"name\">size</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Data/ByteArray.html#ByteSliceT\">ByteSliceT</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/ByteArray.lean#L25-L25","name":"ByteSliceT.off","line":25,"kind":"def","docLink":"./Mathlib/Data/ByteArray.html#ByteSliceT.off","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/ByteArray.html#ByteSliceT.off\"><span class=\"name\">ByteSliceT</span>.<span class=\"name\">off</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Data/ByteArray.html#ByteSliceT\">ByteSliceT</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/ByteArray.lean#L25-L25","name":"ByteSliceT.arr","line":25,"kind":"def","docLink":"./Mathlib/Data/ByteArray.html#ByteSliceT.arr","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/ByteArray.html#ByteSliceT.arr\"><span class=\"name\">ByteSliceT</span>.<span class=\"name\">arr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(self : <a href=\"./Mathlib/Data/ByteArray.html#ByteSliceT\">ByteSliceT</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/ByteArray/Basic.html#ByteArray\">ByteArray</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/ByteArray.lean#L25-L25","name":"ByteSliceT.mk","line":25,"kind":"ctor","docLink":"./Mathlib/Data/ByteArray.html#ByteSliceT.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/ByteArray.html#ByteSliceT.mk\"><span class=\"name\">ByteSliceT</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(arr : <a href=\"./Init/Data/ByteArray/Basic.html#ByteArray\">ByteArray</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(off : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Data/ByteArray.html#ByteSliceT\">ByteSliceT</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/ByteArray.lean#L25-L25","name":"ByteSliceT","line":25,"kind":"structure","docLink":"./Mathlib/Data/ByteArray.html#ByteSliceT","doc":"A terminal byte slice, a suffix of a byte array. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/ByteArray.html#ByteSliceT\"><span class=\"name\">ByteSliceT</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/ByteArray.lean#L20-L20","name":"Nat.upRel","line":20,"kind":"def","docLink":"./Mathlib/Data/ByteArray.html#Nat.upRel","doc":"A well-ordered relation for \"upwards\" induction on the natural numbers up to some bound `ub`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/ByteArray.html#Nat.upRel\"><span class=\"name\">Nat</span>.<span class=\"name\">upRel</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ub : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/WF.html#WellFoundedRelation\">WellFoundedRelation</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/ByteArray.lean#L16-L17","name":"Nat.Up.WF","line":16,"kind":"theorem","docLink":"./Mathlib/Data/ByteArray.html#Nat.Up.WF","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/ByteArray.html#Nat.Up.WF\"><span class=\"name\">Nat</span>.<span class=\"name\">Up</span>.<span class=\"name\">WF</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ub : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/WF.html#WellFounded\">WellFounded</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/ByteArray.html#Nat.Up\">Nat.Up</a> <span class=\"fn\">ub</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/ByteArray.lean#L14-L14","name":"Nat.Up.next","line":14,"kind":"theorem","docLink":"./Mathlib/Data/ByteArray.html#Nat.Up.next","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/ByteArray.html#Nat.Up.next\"><span class=\"name\">Nat</span>.<span class=\"name\">Up</span>.<span class=\"name\">next</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{ub : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{i : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><span class=\"fn\">i</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">ub</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/ByteArray.html#Nat.Up\">Nat.Up</a> <span class=\"fn\">ub</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">i</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span></span>)</span> <span class=\"fn\">i</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Data/ByteArray.lean#L12-L12","name":"Nat.Up","line":12,"kind":"def","docLink":"./Mathlib/Data/ByteArray.html#Nat.Up","doc":"A well-ordered relation for \"upwards\" induction on the natural numbers up to some bound `ub`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/ByteArray.html#Nat.Up\"><span class=\"name\">Nat</span>.<span class=\"name\">Up</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ub : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(i : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"}]}