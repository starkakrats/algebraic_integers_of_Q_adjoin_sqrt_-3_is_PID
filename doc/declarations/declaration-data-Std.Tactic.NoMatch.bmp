{"name":"Std.Tactic.NoMatch","instances":[],"imports":["Init","Std.Tactic.OpenPrivate","Lean.Elab.Match","Lean.Elab.ElabRules"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NoMatch.lean#L65-L65","name":"Std.Tactic.«tacticIntro.»","line":65,"kind":"def","docLink":"./Std/Tactic/NoMatch.html#Std.Tactic.«tacticIntro.»","doc":"The tactic `intro.` is shorthand for `exact fun.`: it introduces the assumptions, then performs an\nempty pattern match, closing the goal if the introduced pattern is impossible.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NoMatch.html#Std.Tactic.«tacticIntro.»\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«tacticIntro</span>.<span class=\"name\">»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NoMatch.lean#L58-L59","name":"Std.Tactic.«tacticMatch_,,With.»","line":58,"kind":"def","docLink":"./Std/Tactic/NoMatch.html#Std.Tactic.«tacticMatch_,,With.»","doc":"The syntax `match x with.` is a variant of `nomatch x` which supports pattern matching on multiple\ndiscriminants, like regular `match`, and simply has no alternatives in the match.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NoMatch.html#Std.Tactic.«tacticMatch_,,With.»\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«tacticMatch_,,With</span>.<span class=\"name\">»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NoMatch.lean#L56-L56","name":"Std.Tactic.«termλ.»","line":56,"kind":"def","docLink":"./Std/Tactic/NoMatch.html#Std.Tactic.«termλ.»","doc":"The syntax  `fun.` or `λ.` (dot required) is shorthand for an empty pattern match function,\ni.e. `fun x y z => match x, y, z with.` for an appropriate number of arguments.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NoMatch.html#Std.Tactic.«termλ.»\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«termλ</span>.<span class=\"name\">»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NoMatch.lean#L45-L54","name":"Std.Tactic.noFun","line":45,"kind":"def","docLink":"./Std/Tactic/NoMatch.html#Std.Tactic.noFun","doc":"The syntax  `fun.` or `λ.` (dot required) is shorthand for an empty pattern match function,\ni.e. `fun x y z => match x, y, z with.` for an appropriate number of arguments.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NoMatch.html#Std.Tactic.noFun\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">noFun</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NoMatch.lean#L30-L43","name":"Std.Tactic.elabNoMatch'","line":30,"kind":"def","docLink":"./Std/Tactic/NoMatch.html#Std.Tactic.elabNoMatch'","doc":"Elaborator for `match x with.` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NoMatch.html#Std.Tactic.elabNoMatch'\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">elabNoMatch'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElab\">Lean.Elab.Term.TermElab</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/NoMatch.lean#L22-L26","name":"Std.Tactic.noMatch","line":22,"kind":"def","docLink":"./Std/Tactic/NoMatch.html#Std.Tactic.noMatch","doc":"The syntax `match x with.` is a variant of `nomatch x` which supports pattern matching on multiple\ndiscriminants, like regular `match`, and simply has no alternatives in the match.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/NoMatch.html#Std.Tactic.noMatch\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">noMatch</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"}]}