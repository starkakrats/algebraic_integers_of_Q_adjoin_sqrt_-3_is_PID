{"name":"Std.Tactic.GuardExpr","instances":[],"imports":["Init","Lean.Elab.Command","Lean.Elab.Tactic.Conv.Basic","Lean.Meta.Basic","Lean.Meta.Eval","Std.Util.TermUnsafe"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L219-L245","name":"Std.Tactic.GuardExpr.«command#guard_»","line":219,"kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.«command#guard_»","doc":"Command to check that an expression evaluates to `true`.\n\n`#guard e` elaborates `e` ensuring its type is `Bool` then evaluates `e` and checks that\nthe result is `true`. The term is elaborated *without* variables declared using `variable`, since\nthese cannot be evaluated.\n\nSince this makes use of coercions, so long as a proposition `p` is decidable, one can write\n`#guard p` rather than `#guard decide p`. A consequence to this is that if there is decidable\nequality one can write `#guard a = b`. Note that this is not exactly the same as checking\nif `a` and `b` evaluate to the same thing since it uses the `DecidableEq` instance to do\nthe evaluation.\n\nNote: this uses the untrusted evaluator, so `#guard` passing is *not* a proof that the\nexpression equals `true`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.«command#guard_»\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">«command#guard_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L210-L217","name":"Std.Tactic.GuardExpr.evalGuardExprCmd","line":210,"kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.evalGuardExprCmd","doc":"Command to check equality of two expressions.\n* `#guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `#guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `#guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `#guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nThis is a command version of the `guard_expr` tactic. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.evalGuardExprCmd\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">evalGuardExprCmd</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Command.html#Lean.Elab.Command.CommandElab\">Lean.Elab.Command.CommandElab</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L199-L207","name":"Std.Tactic.GuardExpr.guardExprCmd","line":199,"kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.guardExprCmd","doc":"Command to check equality of two expressions.\n* `#guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `#guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `#guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `#guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nThis is a command version of the `guard_expr` tactic. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.guardExprCmd\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">guardExprCmd</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L173-L197","name":"Std.Tactic.GuardExpr.evalGuardHyp","line":173,"kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.evalGuardHyp","doc":"Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.evalGuardHyp\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">evalGuardHyp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.Tactic\">Lean.Elab.Tactic.Tactic</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L169-L170","name":"Std.Tactic.GuardExpr.guardHypConv","line":169,"kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.guardHypConv","doc":"Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.guardHypConv\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">guardHypConv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L153-L168","name":"Std.Tactic.GuardExpr.guardHyp","line":153,"kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.guardHyp","doc":"Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.guardHyp\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">guardHyp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L141-L151","name":"Std.Tactic.GuardExpr.evalGuardTarget","line":141,"kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.evalGuardTarget","doc":"Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.evalGuardTarget\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">evalGuardTarget</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.Tactic\">Lean.Elab.Tactic.Tactic</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L138-L138","name":"Std.Tactic.GuardExpr.guardTargetConv","line":138,"kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.guardTargetConv","doc":"Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.guardTargetConv\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">guardTargetConv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L127-L137","name":"Std.Tactic.GuardExpr.guardTarget","line":127,"kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.guardTarget","doc":"Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.guardTarget\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">guardTarget</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L118-L125","name":"Std.Tactic.GuardExpr.evalGuardExpr","line":118,"kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.evalGuardExpr","doc":"Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.evalGuardExpr\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">evalGuardExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.Tactic\">Lean.Elab.Tactic.Tactic</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L108-L115","name":"Std.Tactic.GuardExpr.elabAndEvalMatchKind","line":108,"kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.elabAndEvalMatchKind","doc":"Elaborate `a` and `b` and then do the given equality test `mk`. We make sure to unify\nthe types of `a` and `b` after elaboration so that when synthesizing pending metavariables\nwe don't get the wrong instances due to default instances (for example, for nat literals). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.elabAndEvalMatchKind\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">elabAndEvalMatchKind</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(mk : <a href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.MatchKind\">Std.Tactic.GuardExpr.MatchKind</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L103-L103","name":"Std.Tactic.GuardExpr.guardExprConv","line":103,"kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.guardExprConv","doc":"Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.guardExprConv\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">guardExprConv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L91-L102","name":"Std.Tactic.GuardExpr.guardExpr","line":91,"kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.guardExpr","doc":"Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.guardExpr\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">guardExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L86-L89","name":"Std.Tactic.GuardExpr.MatchKind.isEq","line":86,"kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.MatchKind.isEq","doc":"Applies the selected matching rule to two expressions. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.MatchKind.isEq\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">MatchKind</span>.<span class=\"name\">isEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(a : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.MatchKind\">Std.Tactic.GuardExpr.MatchKind</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L78-L83","name":"Std.Tactic.GuardExpr.equal.toMatchKind","line":78,"kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.equal.toMatchKind","doc":"Converts a `equal` syntax into a `MatchKind` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.equal.toMatchKind\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">equal</span>.<span class=\"name\">toMatchKind</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Std.Tactic.GuardExpr.equal</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.MatchKind\">Std.Tactic.GuardExpr.MatchKind</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L70-L75","name":"Std.Tactic.GuardExpr.colonEq.toMatchKind","line":70,"kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colonEq.toMatchKind","doc":"Converts a `colonEq` syntax into a `MatchKind` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colonEq.toMatchKind\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">colonEq</span>.<span class=\"name\">toMatchKind</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Std.Tactic.GuardExpr.colonEq</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.MatchKind\">Std.Tactic.GuardExpr.MatchKind</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L62-L67","name":"Std.Tactic.GuardExpr.colon.toMatchKind","line":62,"kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colon.toMatchKind","doc":"Converts a `colon` syntax into a `MatchKind` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colon.toMatchKind\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">colon</span>.<span class=\"name\">toMatchKind</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Std.Tactic.GuardExpr.colon</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.MatchKind\">Std.Tactic.GuardExpr.MatchKind</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L58-L59","name":"Std.Tactic.GuardExpr.equal","line":58,"kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.equal","doc":"The `guard_expr` matching specifier, one of `=`, `=~`, `=ₛ`, `=ₐ` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.equal\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">equal</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L56-L57","name":"Std.Tactic.GuardExpr.equalA","line":56,"kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.equalA","doc":"Alpha-eq matching for `guard_expr` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.equalA\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">equalA</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L54-L55","name":"Std.Tactic.GuardExpr.equalS","line":54,"kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.equalS","doc":"Syntactic matching for `guard_expr` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.equalS\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">equalS</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L52-L53","name":"Std.Tactic.GuardExpr.equalD","line":52,"kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.equalD","doc":"Default-reducibility defeq matching for `guard_expr` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.equalD\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">equalD</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L50-L51","name":"Std.Tactic.GuardExpr.equalR","line":50,"kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.equalR","doc":"Reducible defeq matching for `guard_expr` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.equalR\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">equalR</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L47-L48","name":"Std.Tactic.GuardExpr.colonEq","line":47,"kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colonEq","doc":"The `guard_hyp` value specifier, one of `:=`, `:=~`, `:=ₛ`, `:=ₐ` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colonEq\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">colonEq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L45-L46","name":"Std.Tactic.GuardExpr.colonEqA","line":45,"kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colonEqA","doc":"Alpha-eq matching for `guard_hyp` values "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colonEqA\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">colonEqA</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L43-L44","name":"Std.Tactic.GuardExpr.colonEqS","line":43,"kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colonEqS","doc":"Syntactic matching for `guard_hyp` values "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colonEqS\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">colonEqS</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L41-L42","name":"Std.Tactic.GuardExpr.colonEqD","line":41,"kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colonEqD","doc":"Default-reducibility defeq matching for `guard_hyp` values "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colonEqD\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">colonEqD</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L39-L40","name":"Std.Tactic.GuardExpr.colonEqR","line":39,"kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colonEqR","doc":"Reducible defeq matching for `guard_hyp` values "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colonEqR\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">colonEqR</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L36-L37","name":"Std.Tactic.GuardExpr.colon","line":36,"kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colon","doc":"The `guard_hyp` type specifier, one of `:`, `:~`, `:ₛ`, `:ₐ` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colon\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">colon</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L34-L35","name":"Std.Tactic.GuardExpr.colonA","line":34,"kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colonA","doc":"Alpha-eq matching for `guard_hyp` types "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colonA\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">colonA</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L32-L33","name":"Std.Tactic.GuardExpr.colonS","line":32,"kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colonS","doc":"Syntactic matching for `guard_hyp` types "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colonS\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">colonS</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L30-L31","name":"Std.Tactic.GuardExpr.colonD","line":30,"kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colonD","doc":"Default-reducibility defeq matching for `guard_hyp` types "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colonD\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">colonD</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L28-L29","name":"Std.Tactic.GuardExpr.colonR","line":28,"kind":"def","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colonR","doc":"Reducible defeq matching for `guard_hyp` types "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.colonR\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">colonR</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L25-L26","name":"Std.Tactic.GuardExpr.MatchKind.alphaEq","line":25,"kind":"ctor","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.MatchKind.alphaEq","doc":"An alpha-eq match means that `Expr.eqv` returns true. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.MatchKind.alphaEq\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">MatchKind</span>.<span class=\"name\">alphaEq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.MatchKind\">Std.Tactic.GuardExpr.MatchKind</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L23-L24","name":"Std.Tactic.GuardExpr.MatchKind.defEq","line":23,"kind":"ctor","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.MatchKind.defEq","doc":"A defeq match `isDefEqGuarded` returns true. (Note that unification is allowed here.) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.MatchKind.defEq\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">MatchKind</span>.<span class=\"name\">defEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(red : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode\">Lean.Meta.TransparencyMode</a> <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode.reducible\">Lean.Meta.TransparencyMode.reducible</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.MatchKind\">Std.Tactic.GuardExpr.MatchKind</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L21-L22","name":"Std.Tactic.GuardExpr.MatchKind.syntactic","line":21,"kind":"ctor","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.MatchKind.syntactic","doc":"A syntactic match means that the `Expr`s are `==` after stripping `MData` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.MatchKind.syntactic\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">MatchKind</span>.<span class=\"name\">syntactic</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.MatchKind\">Std.Tactic.GuardExpr.MatchKind</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/GuardExpr.lean#L20-L26","name":"Std.Tactic.GuardExpr.MatchKind","line":20,"kind":"inductive","docLink":"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.MatchKind","doc":"The various `guard_*` tactics have similar matching specifiers for how equal expressions\nhave to be to pass the tactic.\nThis inductive gives the different specifiers that can be selected.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/GuardExpr.html#Std.Tactic.GuardExpr.MatchKind\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">GuardExpr</span>.<span class=\"name\">MatchKind</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"}]}