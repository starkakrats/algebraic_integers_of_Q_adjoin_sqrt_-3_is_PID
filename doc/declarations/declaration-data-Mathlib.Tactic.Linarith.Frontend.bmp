{"name":"Mathlib.Tactic.Linarith.Frontend","instances":[],"imports":["Init","Mathlib.Control.Basic","Mathlib.Data.HashMap","Mathlib.Tactic.Linarith.Verification","Mathlib.Tactic.Linarith.Preprocessing"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Frontend.lean#L400-L403","name":"elabLinarithConfig","line":400,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#elabLinarithConfig","doc":"Allow elaboration of `LinarithConfig` arguments to tactics.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#elabLinarithConfig\"><span class=\"name\">elabLinarithConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a> → <span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig\">Linarith.LinarithConfig</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Frontend.lean#L394-L398","name":"elabLinarithArg","line":394,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#elabLinarithArg","doc":"Elaborate `t` in a way that is suitable for linarith. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#elabLinarithArg\"><span class=\"name\">elabLinarithArg</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(tactic : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Frontend.lean#L390-L391","name":"tacticNlinarith!_","line":390,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#tacticNlinarith!_","doc":"An extension of `linarith` with some preprocessing to allow it to solve some nonlinear arithmetic\nproblems. (Based on Coq's `nra` tactic.) See `linarith` for the available syntax of options,\nwhich are inherited by `nlinarith`; that is, `nlinarith!` and `nlinarith only [h1, h2]` all work as\nin `linarith`. The preprocessing is as follows:\n\n* For every subterm `a ^ 2` or `a * a` in a hypothesis or the goal,\n  the assumption `0 ≤ a ^ 2` or `0 ≤ a * a` is added to the context.\n* For every pair of hypotheses `a1 R1 b1`, `a2 R2 b2` in the context, `R1, R2 ∈ {<, ≤, =}`,\n  the assumption `0 R' (b1 - a1) * (b2 - a2)` is added to the context (non-recursively),\n  where `R ∈ {<, ≤, =}` is the appropriate comparison derived from `R1, R2`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#tacticNlinarith!_\"><span class=\"name\">tacticNlinarith!_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Frontend.lean#L377-L389","name":"nlinarith","line":377,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#nlinarith","doc":"An extension of `linarith` with some preprocessing to allow it to solve some nonlinear arithmetic\nproblems. (Based on Coq's `nra` tactic.) See `linarith` for the available syntax of options,\nwhich are inherited by `nlinarith`; that is, `nlinarith!` and `nlinarith only [h1, h2]` all work as\nin `linarith`. The preprocessing is as follows:\n\n* For every subterm `a ^ 2` or `a * a` in a hypothesis or the goal,\n  the assumption `0 ≤ a ^ 2` or `0 ≤ a * a` is added to the context.\n* For every pair of hypotheses `a1 R1 b1`, `a2 R2 b2` in the context, `R1, R2 ∈ {<, ≤, =}`,\n  the assumption `0 R' (b1 - a1) * (b2 - a2)` is added to the context (non-recursively),\n  where `R ∈ {<, ≤, =}` is the appropriate comparison derived from `R1, R2`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#nlinarith\"><span class=\"name\">nlinarith</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Frontend.lean#L374-L375","name":"tacticLinarith!_","line":374,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#tacticLinarith!_","doc":"`linarith` attempts to find a contradiction between hypotheses that are linear (in)equalities.\nEquivalently, it can prove a linear inequality by assuming its negation and proving `False`.\n\nIn theory, `linarith` should prove any goal that is true in the theory of linear arithmetic over\nthe rationals. While there is some special handling for non-dense orders like `Nat` and `Int`,\nthis tactic is not complete for these theories and will not prove every true goal. It will solve\ngoals over arbitrary types that instantiate `LinearOrderedCommRing`.\n\nAn example:\n```lean\nexample (x y z : ℚ) (h1 : 2*x < 3*y) (h2 : -4*x + 2*z < 0)\n        (h3 : 12*y - 4* z < 0)  : False :=\nby linarith\n```\n\n`linarith` will use all appropriate hypotheses and the negation of the goal, if applicable.\nDisequality hypotheses require case splitting and are not normally considered\n(see the `splitNe` option below).\n\n`linarith [t1, t2, t3]` will additionally use proof terms `t1, t2, t3`.\n\n`linarith only [h1, h2, h3, t1, t2, t3]` will use only the goal (if relevant), local hypotheses\n`h1`, `h2`, `h3`, and proofs `t1`, `t2`, `t3`. It will ignore the rest of the local context.\n\n`linarith!` will use a stronger reducibility setting to try to identify atoms. For example,\n```lean\nexample (x : ℚ) : id x ≥ x :=\nby linarith\n```\nwill fail, because `linarith` will not identify `x` and `id x`. `linarith!` will.\nThis can sometimes be expensive.\n\n`linarith (config := { .. })` takes a config object with five\noptional arguments:\n* `discharger` specifies a tactic to be used for reducing an algebraic equation in the\n  proof stage. The default is `ring`. Other options include `simp` for basic\n  problems.\n* `transparency` controls how hard `linarith` will try to match atoms to each other. By default\n  it will only unfold `reducible` definitions.\n* If `splitHypotheses` is true, `linarith` will split conjunctions in the context into separate\n  hypotheses.\n* If `splitNe` is `true`, `linarith` will case split on disequality hypotheses.\n  For a given `x ≠ y` hypothesis, `linarith` is run with both `x < y` and `x > y`,\n  and so this runs linarith exponentially many times with respect to the number of\n  disequality hypotheses. (False by default.)\n* If `exfalso` is false, `linarith` will fail when the goal is neither an inequality nor `false`.\n  (True by default.)\n* `restrict_type` (not yet implemented in mathlib4)\n  will only use hypotheses that are inequalities over `tp`. This is useful\n  if you have e.g. both integer and rational valued inequalities in the local context, which can\n  sometimes confuse the tactic.\n\nA variant, `nlinarith`, does some basic preprocessing to handle some nonlinear goals.\n\nThe option `set_option trace.linarith true` will trace certain intermediate stages of the `linarith`\nroutine.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#tacticLinarith!_\"><span class=\"name\">tacticLinarith!_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Frontend.lean#L314-L372","name":"linarith","line":314,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#linarith","doc":"`linarith` attempts to find a contradiction between hypotheses that are linear (in)equalities.\nEquivalently, it can prove a linear inequality by assuming its negation and proving `False`.\n\nIn theory, `linarith` should prove any goal that is true in the theory of linear arithmetic over\nthe rationals. While there is some special handling for non-dense orders like `Nat` and `Int`,\nthis tactic is not complete for these theories and will not prove every true goal. It will solve\ngoals over arbitrary types that instantiate `LinearOrderedCommRing`.\n\nAn example:\n```lean\nexample (x y z : ℚ) (h1 : 2*x < 3*y) (h2 : -4*x + 2*z < 0)\n        (h3 : 12*y - 4* z < 0)  : False :=\nby linarith\n```\n\n`linarith` will use all appropriate hypotheses and the negation of the goal, if applicable.\nDisequality hypotheses require case splitting and are not normally considered\n(see the `splitNe` option below).\n\n`linarith [t1, t2, t3]` will additionally use proof terms `t1, t2, t3`.\n\n`linarith only [h1, h2, h3, t1, t2, t3]` will use only the goal (if relevant), local hypotheses\n`h1`, `h2`, `h3`, and proofs `t1`, `t2`, `t3`. It will ignore the rest of the local context.\n\n`linarith!` will use a stronger reducibility setting to try to identify atoms. For example,\n```lean\nexample (x : ℚ) : id x ≥ x :=\nby linarith\n```\nwill fail, because `linarith` will not identify `x` and `id x`. `linarith!` will.\nThis can sometimes be expensive.\n\n`linarith (config := { .. })` takes a config object with five\noptional arguments:\n* `discharger` specifies a tactic to be used for reducing an algebraic equation in the\n  proof stage. The default is `ring`. Other options include `simp` for basic\n  problems.\n* `transparency` controls how hard `linarith` will try to match atoms to each other. By default\n  it will only unfold `reducible` definitions.\n* If `splitHypotheses` is true, `linarith` will split conjunctions in the context into separate\n  hypotheses.\n* If `splitNe` is `true`, `linarith` will case split on disequality hypotheses.\n  For a given `x ≠ y` hypothesis, `linarith` is run with both `x < y` and `x > y`,\n  and so this runs linarith exponentially many times with respect to the number of\n  disequality hypotheses. (False by default.)\n* If `exfalso` is false, `linarith` will fail when the goal is neither an inequality nor `false`.\n  (True by default.)\n* `restrict_type` (not yet implemented in mathlib4)\n  will only use hypotheses that are inequalities over `tp`. This is useful\n  if you have e.g. both integer and rational valued inequalities in the local context, which can\n  sometimes confuse the tactic.\n\nA variant, `nlinarith`, does some basic preprocessing to handle some nonlinear goals.\n\nThe option `set_option trace.linarith true` will trace certain intermediate stages of the `linarith`\nroutine.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#linarith\"><span class=\"name\">linarith</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Frontend.lean#L311-L312","name":"linarithArgsRest","line":311,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#linarithArgsRest","doc":"Syntax for the arguments of `linarith`, after the optional `!`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#linarithArgsRest\"><span class=\"name\">linarithArgsRest</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Frontend.lean#L266-L303","name":"Linarith.linarith","line":266,"kind":"opaque","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Linarith.linarith","doc":"`linarith only_on hyps cfg` tries to close the goal using linear arithmetic. It fails\nif it does not succeed at doing this.\n\n* `hyps` is a list of proofs of comparisons to include in the search.\n* If `only_on` is true, the search will be restricted to `hyps`. Otherwise it will use all\n  comparisons in the local context.\n* If `cfg.transparency := semireducible`,\n  it will unfold semireducible definitions when trying to match atomic expressions.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Linarith.linarith\"><span class=\"name\">Linarith</span>.<span class=\"name\">linarith</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(only_on : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hyps : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(cfg : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig\">Linarith.LinarithConfig</a>\n  <span class=\"fn\">{\n    <span class=\"fn\">discharger</span> := <span class=\"fn\">do\n      let __do_lift ←\n        <span class=\"fn\">do\n          let info ← <span class=\"fn\">Lean.MonadRef.mkInfoFromRefPos</span>\n          let _ ← <span class=\"fn\">Lean.getCurrMacroScope</span>\n          let _ ← <span class=\"fn\">Lean.getMainModule</span>\n          <span class=\"fn\"><a href=\"./Init/Prelude.html#Pure.pure\">pure</a>\n              <span class=\"fn\">{\n                <span class=\"fn\">raw</span> :=\n                  <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax.node2\">Lean.Syntax.node2</a> <span class=\"fn\">info</span> <span class=\"fn\">`Mathlib.Tactic.Ring.ring1</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax.atom\">Lean.Syntax.atom</a> <span class=\"fn\">info</span> <span class=\"fn\">&quot;ring1&quot;</span></span>)</span>\n                    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Syntax.node\">Lean.Syntax.node</a> <span class=\"fn\">info</span> <span class=\"fn\">`null</span> <span class=\"fn\">#[]</span></span>)</span></span> }</span></span></span>\n      <span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.evalTactic\">Lean.Elab.Tactic.evalTactic</a> <span class=\"fn\"><span class=\"fn\">__do_lift</span>.raw</span></span></span>,\n    <span class=\"fn\">exfalso</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">transparency</span> := <a href=\"./Init/MetaTypes.html#Lean.Meta.TransparencyMode.reducible\">Lean.Meta.TransparencyMode.reducible</a>, <span class=\"fn\">splitHypotheses</span> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>, <span class=\"fn\">splitNe</span> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>,\n    <span class=\"fn\">preprocessors</span> := <span class=\"fn\">none</span>, <span class=\"fn\">oracle</span> := <span class=\"fn\">none</span> }</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Frontend.lean#L222-L243","name":"Linarith.runLinarith","line":222,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Linarith.runLinarith","doc":"Given a list `hyps` of proofs of comparisons, `runLinarith cfg hyps prefType`\npreprocesses `hyps` according to the list of preprocessors in `cfg`.\nThis results in a list of branches (typically only one),\neach of which must succeed in order to close the goal.\n\nIn each branch, we partition the list of hypotheses by type, and run `linarith` on each class\nin the partition; one of these must succeed in order for `linarith` to succeed on this branch.\nIf `prefType` is given, it will first use the class of proofs of comparisons over that type.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Linarith.runLinarith\"><span class=\"name\">Linarith</span>.<span class=\"name\">runLinarith</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig\">Linarith.LinarithConfig</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(prefType : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hyps : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Frontend.lean#L204-L208","name":"Linarith.findLinarithContradiction","line":204,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Linarith.findLinarithContradiction","doc":"Given a list `ls` of lists of proofs of comparisons, `findLinarithContradiction cfg ls` will try to\nprove `false` by calling `linarith` on each list in succession. It will stop at the first proof of\n`false`, and fail if no contradiction is found with any list.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Linarith.findLinarithContradiction\"><span class=\"name\">Linarith</span>.<span class=\"name\">findLinarithContradiction</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(cfg : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Linarith.LinarithConfig\">Linarith.LinarithConfig</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ls : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Frontend.lean#L196-L197","name":"Linarith.partitionByType","line":196,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Linarith.partitionByType","doc":"`partitionByType l` takes a list `l` of proofs of comparisons. It sorts these proofs by\nthe type of the variables in the comparison, e.g. `(a : ℚ) < 1` and `(b : ℤ) > c` will be separated.\nReturns a map from a type to a list of comparisons over that type.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Linarith.partitionByType\"><span class=\"name\">Linarith</span>.<span class=\"name\">partitionByType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Frontend.html#Linarith.ExprMultiMap\">Linarith.ExprMultiMap</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Frontend.lean#L185-L189","name":"Linarith.ExprMultiMap.insert","line":185,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Linarith.ExprMultiMap.insert","doc":"Insert a new value into the map at key `k`. This does a defeq check with all other keys\nin the map. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Linarith.ExprMultiMap.insert\"><span class=\"name\">Linarith</span>.<span class=\"name\">ExprMultiMap</span>.<span class=\"name\">insert</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(self : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Frontend.html#Linarith.ExprMultiMap\">Linarith.ExprMultiMap</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(v : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Frontend.html#Linarith.ExprMultiMap\">Linarith.ExprMultiMap</a> <span class=\"fn\">α</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Frontend.lean#L176-L181","name":"Linarith.ExprMultiMap.find","line":176,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Linarith.ExprMultiMap.find","doc":"Retrieves the list of values at a key, as well as the index of the key for later modification.\n(If the key is not in the map it returns `self.size` as the index.) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Linarith.ExprMultiMap.find\"><span class=\"name\">Linarith</span>.<span class=\"name\">ExprMultiMap</span>.<span class=\"name\">find</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(self : <span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Frontend.html#Linarith.ExprMultiMap\">Linarith.ExprMultiMap</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(k : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Frontend.lean#L172-L172","name":"Linarith.ExprMultiMap","line":172,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Linarith.ExprMultiMap","doc":"A map of keys to values, where the keys are `Expr` up to defeq and one key can be\nassociated to multiple values. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Linarith.ExprMultiMap\"><span class=\"name\">Linarith</span>.<span class=\"name\">ExprMultiMap</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(α : <a href=\"./foundational_types.html\">Type</a> u_1)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u_1</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Frontend.lean#L162-L168","name":"Linarith.applyContrLemma","line":162,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Linarith.applyContrLemma","doc":"`applyContrLemma` inspects the target to see if it can be moved to a hypothesis by negation.\nFor example, a goal `⊢ a ≤ b` can become `a > b ⊢ false`.\nIf this is the case, it applies the appropriate lemma and introduces the new hypothesis.\nIt returns the type of the terms in the comparison (e.g. the type of `a` and `b` above) and the\nnewly introduced local constant.\nOtherwise returns `none`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Linarith.applyContrLemma\"><span class=\"name\">Linarith</span>.<span class=\"name\">applyContrLemma</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Linarith/Frontend.lean#L137-L152","name":"Linarith.getContrLemma","line":137,"kind":"def","docLink":"./Mathlib/Tactic/Linarith/Frontend.html#Linarith.getContrLemma","doc":"If `e` is a comparison `a R b` or the negation of a comparison `¬ a R b`, found in the target,\n`getContrLemma e` returns the name of a lemma that will change the goal to an\nimplication, along with the type of `a` and `b`.\n\nFor example, if `e` is `(a : ℕ) < b`, returns ``(`lt_of_not_ge, ℕ)``.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Frontend.html#Linarith.getContrLemma\"><span class=\"name\">Linarith</span>.<span class=\"name\">getContrLemma</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></div></div>"}]}