{"name":"Std.Tactic.RCases","instances":[{"typeNames":["Lean.Syntax.Ident","Lean.TSyntax"],"name":"Std.Tactic.RCases.instCoeIdentTSyntaxConsSyntaxNodeKindMkStr1Nil","className":"Coe"},{"typeNames":["Lean.TSyntax","Lean.TSyntax"],"name":"Std.Tactic.RCases.instCoeTSyntaxConsSyntaxNodeKindMkStr1NilMkStr4","className":"Coe"},{"typeNames":["Lean.TSyntax","Lean.TSyntax"],"name":"Std.Tactic.RCases.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil","className":"Coe"},{"typeNames":["Lean.TSyntax","Lean.TSyntax"],"name":"Std.Tactic.RCases.instCoeTSyntaxConsSyntaxNodeKindMkStr1Nil","className":"Coe"},{"typeNames":["Std.Tactic.RCases.RCasesPatt"],"name":"Std.Tactic.RCases.instReprRCasesPatt","className":"Repr"},{"typeNames":["Std.Tactic.RCases.RCasesPatt"],"name":"Std.Tactic.RCases.RCasesPatt.instInhabitedRCasesPatt","className":"Inhabited"},{"typeNames":["Std.Tactic.RCases.RCasesPatt"],"name":"Std.Tactic.RCases.RCasesPatt.instToMessageDataRCasesPatt","className":"Lean.ToMessageData"}],"imports":["Init","Lean.Elab.Tactic.Induction"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L740-L753","name":"Std.Tactic.rintro","line":740,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.rintro","doc":"The `rintro` tactic is a combination of the `intros` tactic with `rcases` to\nallow for destructuring patterns while introducing variables. See `rcases` for\na description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables `a d e` and the other with `b c d e`.\n\n`rintro`, unlike `rcases`, also supports the form `(x y : ty)` for introducing\nand type-ascripting multiple variables at once, similar to binders.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.rintro\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rintro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L695-L727","name":"Std.Tactic.obtain","line":695,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.obtain","doc":"The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain ⟨patt⟩ : type := proof\n```\nis equivalent to\n```lean\nhave h : type := proof\nrcases h with ⟨patt⟩\n```\n\nIf `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.obtain\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">obtain</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L642-L693","name":"Std.Tactic.rcases","line":642,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.rcases","doc":"`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like `h1 : a ∧ b ∧ c ∨ d` or\n`h2 : ∃ x y, trans_rel R x y`. Usual usage might be `rcases h1 with ⟨ha, hb, hc⟩ | hd` or\n`rcases h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩` for these examples.\n\nEach element of an `rcases` pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of `rcases` and represent individual elements destructured from\nthe input expression). An `rcases` pattern has the following grammar:\n\n* A name like `x`, which names the active hypothesis as `x`.\n* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the\n  hypothesis).\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the\n  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).\n* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it\n  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)\n* A tuple pattern `⟨p1, p2, p3⟩`, which matches a constructor with many arguments, or a series\n  of nested conjunctions or existentials. For example if the active hypothesis is `a ∧ b ∧ c`,\n  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`\n  and so on.\n* A `@` before a tuple pattern as in `@⟨p1, p2, p3⟩` will bind all arguments in the constructor,\n  while leaving the `@` off will only use the patterns on the explicit arguments.\n* An alteration pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,\n  or a nested disjunction like `a ∨ b ∨ c`.\n\nA pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as `a,b,c` and the\nfirst two of the second constructor `d,e`. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.\nIf there are too many arguments, such as `⟨a, b, c⟩` for splitting on\n`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last\nparameter as necessary.\n\n`rcases` also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor `quot.mk`.\n\n`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an\nassumption `h : e = PAT` will be added to the context.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.rcases\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">rcases</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L623-L625","name":"Std.Tactic.RCases.rintro","line":623,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rintro","doc":"The implementation of the `rintro` tactic. It takes a list of patterns `pats` and\nan optional type ascription `ty?` and introduces the patterns, resulting in zero or more goals.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.rintro\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">rintro</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(pats : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntaxArray\">Lean.TSyntaxArray</a> <span class=\"fn\">`rintroPat</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ty? : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L612-L615","name":"Std.Tactic.RCases.rintroContinue.loop","line":612,"kind":"opaque","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rintroContinue.loop","doc":"Runs `rintroContinue` on `pats[i:]` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.rintroContinue.loop\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">rintroContinue</span>.<span class=\"name\">loop</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(ref : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(pats : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntaxArray\">Lean.TSyntaxArray</a> <span class=\"fn\">`rintroPat</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ty? : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(cont : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Tactic/FVarSubst.html#Lean.Meta.FVarSubst\">Lean.Meta.FVarSubst</a> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">α</span></span></span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(i : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fs : <a href=\"./Lean/Meta/Tactic/FVarSubst.html#Lean.Meta.FVarSubst\">Lean.Meta.FVarSubst</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(clears : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L606-L615","name":"Std.Tactic.RCases.rintroContinue","line":606,"kind":"opaque","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rintroContinue","doc":"This introduces the list of patterns `pats`. It has the same arguments as `rcasesCore`, plus:\n* `ty?`: the nearest enclosing type ascription on the current pattern\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.rintroContinue\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">rintroContinue</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fs : <a href=\"./Lean/Meta/Tactic/FVarSubst.html#Lean.Meta.FVarSubst\">Lean.Meta.FVarSubst</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(clears : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ref : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(pats : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntaxArray\">Lean.TSyntaxArray</a> <span class=\"fn\">`rintroPat</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ty? : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(cont : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Tactic/FVarSubst.html#Lean.Meta.FVarSubst\">Lean.Meta.FVarSubst</a> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">α</span></span></span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L589-L600","name":"Std.Tactic.RCases.rintroCore","line":589,"kind":"opaque","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rintroCore","doc":"This introduces the pattern `pat`. It has the same arguments as `rcasesCore`, plus:\n* `ty?`: the nearest enclosing type ascription on the current pattern\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.rintroCore\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">rintroCore</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fs : <a href=\"./Lean/Meta/Tactic/FVarSubst.html#Lean.Meta.FVarSubst\">Lean.Meta.FVarSubst</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(clears : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ref : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(pat : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`rintroPat</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ty? : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(cont : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Tactic/FVarSubst.html#Lean.Meta.FVarSubst\">Lean.Meta.FVarSubst</a> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">α</span></span></span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L576-L579","name":"Std.Tactic.RCases.expandRIntroPats","line":576,"kind":"opaque","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.expandRIntroPats","doc":"Expand a list of `rintroPat` into an equivalent list of `rcasesPat` patterns. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.expandRIntroPats\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">expandRIntroPats</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(pats : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`rintroPat</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(acc : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`rcasesPat</span></span>)</span></span>)</span> <span class=\"fn\">#[]</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ty? : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a></span>)</span> <span class=\"fn\">none</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`rcasesPat</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L565-L573","name":"Std.Tactic.RCases.expandRIntroPat","line":565,"kind":"opaque","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.expandRIntroPat","doc":"Expand a `rintroPat` into an equivalent list of `rcasesPat` patterns. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.expandRIntroPat\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">expandRIntroPat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(pat : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`rintroPat</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(acc : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`rcasesPat</span></span>)</span></span>)</span> <span class=\"fn\">#[]</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ty? : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a></span>)</span> <span class=\"fn\">none</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`rcasesPat</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L553-L559","name":"Std.Tactic.RCases.obtainNone","line":553,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.obtainNone","doc":"The `obtain` tactic in the no-target case. Given a type `T`, create a goal `|- T` and\nand pattern match `T` against the given pattern. Returns the list of goals, with the assumed goal\nfirst followed by the goals produced by the pattern match.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.obtainNone\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">obtainNone</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(pat : <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ty : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L531-L546","name":"Std.Tactic.RCases.rcases","line":531,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcases","doc":"Given a list of targets of the form `e` or `h : e`, and a pattern, match all the targets\nagainst the pattern. Returns the list of produced subgoals.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcases\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">rcases</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(tgts : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(pat : <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L513-L525","name":"Std.Tactic.RCases.generalizeExceptFVar","line":513,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.generalizeExceptFVar","doc":"Generalize all the arguments as specified in `args` to fvars if they aren't already "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.generalizeExceptFVar\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">generalizeExceptFVar</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(goal : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(args : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Meta/Tactic/Generalize.html#Lean.Meta.GeneralizeArg\">Lean.Meta.GeneralizeArg</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L498-L509","name":"Std.Tactic.RCases.RCasesPatt.parse","line":498,"kind":"opaque","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.parse","doc":"Parses a `Syntax` into the `RCasesPatt` type used by the `RCases` tactic. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.parse\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">RCasesPatt</span>.<span class=\"name\">parse</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(stx : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L490-L493","name":"Std.Tactic.RCases.finish","line":490,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.finish","doc":"The terminating continuation used in `rcasesCore` and `rcasesContinue`. We specialize the type\n`α` to `Array MVarId` to collect the list of goals, and given the list of `clears`, it attempts to\nclear them from the goal and adds the goal to the list.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.finish\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">finish</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fs : <a href=\"./Lean/Meta/Tactic/FVarSubst.html#Lean.Meta.FVarSubst\">Lean.Meta.FVarSubst</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(clears : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(gs : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L478-L483","name":"Std.Tactic.RCases.tryClearMany'","line":478,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.tryClearMany'","doc":"Like `tryClearMany`, but also clears dependent hypotheses if possible "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.tryClearMany'\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">tryClearMany'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(goal : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fvarIds : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L466-L473","name":"Std.Tactic.RCases.rcasesContinue","line":466,"kind":"opaque","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesContinue","doc":"This will match a list of patterns against a list of hypotheses `e`. The arguments are similar\nto `rcasesCore`, but the patterns and local variables are in `pats`. Because the calls are all\nnested in continuations, later arguments can be matched many times, once per goal produced by\nearlier arguments. For example `⟨a | b, ⟨c, d⟩⟩` performs the `⟨c, d⟩` match twice, once on the\n`a` branch and once on `b`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesContinue\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">rcasesContinue</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fs : <a href=\"./Lean/Meta/Tactic/FVarSubst.html#Lean.Meta.FVarSubst\">Lean.Meta.FVarSubst</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(clears : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(pats : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(cont : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Tactic/FVarSubst.html#Lean.Meta.FVarSubst\">Lean.Meta.FVarSubst</a> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">α</span></span></span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L449-L456","name":"Std.Tactic.RCases.rcasesCore.align","line":449,"kind":"opaque","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesCore.align","doc":"Runs `rcasesContinue` on the first pattern in `r` with a matching `ctorName`.\nThe unprocessed patterns (subsequent to the matching pattern) are returned. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesCore.align\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">rcasesCore</span>.<span class=\"name\">align</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(fs : <a href=\"./Lean/Meta/Tactic/FVarSubst.html#Lean.Meta.FVarSubst\">Lean.Meta.FVarSubst</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(clears : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(cont : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Tactic/FVarSubst.html#Lean.Meta.FVarSubst\">Lean.Meta.FVarSubst</a> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">α</span></span></span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(goal : <a href=\"./Lean/Meta/Tactic/Induction.html#Lean.Meta.InductionSubgoal\">Lean.Meta.InductionSubgoal</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ctorName : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span></span>)</span></span> →\n  <span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span></span>)</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">α</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L382-L457","name":"Std.Tactic.RCases.rcasesCore","line":382,"kind":"opaque","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesCore","doc":"This will match a pattern `pat` against a local hypothesis `e`.\n* `g`: The initial subgoal\n* `fs`: A running variable substitution, the result of `cases` operations upstream.\n  The variable `e` must be run through this map before locating it in the context of `g`,\n  and the output variable substitutions will be end extensions of this one.\n* `clears`: The list of variables to clear in all subgoals generated from this point on.\n  We defer clear operations because clearing too early can cause `cases` to fail.\n  The actual clearing happens in `RCases.finish`.\n* `e`: a local hypothesis, the scrutinee to match against.\n* `a`: opaque \"user data\" which is passed through all the goal calls at the end.\n* `pat`: the pattern to match against\n* `cont`: A continuation. This is called on every goal generated by the result of the pattern\n  match, with updated values for `g` , `fs`, `clears`, and `a`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesCore\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">rcasesCore</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{α : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(g : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fs : <a href=\"./Lean/Meta/Tactic/FVarSubst.html#Lean.Meta.FVarSubst\">Lean.Meta.FVarSubst</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(clears : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(pat : <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(cont : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Tactic/FVarSubst.html#Lean.Meta.FVarSubst\">Lean.Meta.FVarSubst</a> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">α</span></span></span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">α</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L339-L363","name":"Std.Tactic.RCases.subst'","line":339,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.subst'","doc":"Like `Lean.Meta.subst`, but preserves the `FVarSubst`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.subst'\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">subst'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(goal : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hFVarId : <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(fvarSubst : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Lean/Meta/Tactic/FVarSubst.html#Lean.Meta.FVarSubst\">Lean.Meta.FVarSubst</a> <span class=\"fn\">{ <span class=\"fn\">map</span> := <a href=\"./Init/Core.html#EmptyCollection.emptyCollection\">∅</a> }</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Lean/Meta/Tactic/FVarSubst.html#Lean.Meta.FVarSubst\">Lean.Meta.FVarSubst</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L321-L333","name":"Std.Tactic.RCases.processConstructors","line":321,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.processConstructors","doc":"Takes a list of constructor names, and an (alternation) list of patterns, and matches each\npattern against its constructor. It returns the list of names that will be passed to `cases`,\nand the list of `(constructor name, patterns)` for each constructor, where `patterns` is the\n(conjunctive) list of patterns to apply to each constructor argument.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.processConstructors\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">processConstructors</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ref : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(params : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(altVarNames : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Meta/Tactic/Induction.html#Lean.Meta.AltVarNames\">Lean.Meta.AltVarNames</a></span>)</span> <span class=\"fn\">#[]</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span> →\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span> →\n    <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Meta/Tactic/Induction.html#Lean.Meta.AltVarNames\">Lean.Meta.AltVarNames</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span></span>)</span></span></span>)</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L298-L313","name":"Std.Tactic.RCases.processConstructor","line":298,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.processConstructor","doc":"Takes the number of fields of a single constructor and patterns to match its fields against\n(not necessarily the same number). The returned lists each contain one element per field of the\nconstructor. The `name` is the name which will be used in the top-level `cases` tactic, and the\n`rcases_patt` is the pattern which the field will be matched against by subsequent `cases`\ntactics.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.processConstructor\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">processConstructor</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ref : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(info : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.ParamInfo\">Lean.Meta.ParamInfo</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(explicit : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(idx : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(ps : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L280-L287","name":"Std.Tactic.RCases.RCasesPatt.instToMessageDataRCasesPatt.fmt","line":280,"kind":"opaque","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.instToMessageDataRCasesPatt.fmt","doc":"format an `RCasesPatt` with the given precedence: 0 = lo, 1 = med, 2 = hi "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.instToMessageDataRCasesPatt.fmt\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">RCasesPatt</span>.<span class=\"name\">instToMessageDataRCasesPatt</span>.<span class=\"name\">fmt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">Nat</a> → <span class=\"fn\"><a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a> → <a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L277-L278","name":"Std.Tactic.RCases.RCasesPatt.instToMessageDataRCasesPatt.parenAbove","line":277,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.instToMessageDataRCasesPatt.parenAbove","doc":"parenthesize the message if the precedence is above `tgt` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.instToMessageDataRCasesPatt.parenAbove\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">RCasesPatt</span>.<span class=\"name\">instToMessageDataRCasesPatt</span>.<span class=\"name\">parenAbove</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(tgt : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(p : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(m : <a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Message.html#Lean.MessageData\">Lean.MessageData</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L275-L287","name":"Std.Tactic.RCases.RCasesPatt.instToMessageDataRCasesPatt","line":275,"kind":"instance","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.instToMessageDataRCasesPatt","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.instToMessageDataRCasesPatt\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">RCasesPatt</span>.<span class=\"name\">instToMessageDataRCasesPatt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Message.html#Lean.ToMessageData\">Lean.ToMessageData</a> <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L269-L272","name":"Std.Tactic.RCases.RCasesPatt.alts₁","line":269,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.alts₁","doc":"This function is used for producing rcases patterns based on a case tree. This is like\n`alts₁Core`, but it produces a cases pattern directly instead of a list of alternatives. We\nspecially translate the empty alternation to `⟨⟩`, and translate `|(a | b)` to `⟨a | b⟩` (because we\ndon't have any syntax for unary alternation). Otherwise we can use the regular merging of\nalternations at the last argument so that `a | b | (c | d)` becomes `a | b | c | d`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.alts₁\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">RCasesPatt</span>.<span class=\"name\">alts₁</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ref : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span>)</span></span> → <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L257-L260","name":"Std.Tactic.RCases.RCasesPatt.alts₁Core","line":257,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.alts₁Core","doc":"This function is used for producing rcases patterns based on a case tree. Here we are given\nthe list of patterns to apply to each argument of each constructor after the main case, and must\nproduce a list of alternatives with the same effect. This function calls `tuple₁` to make the\nindividual alternatives, and handles merging `[a, b, c | d]` to `a | b | c | d` instead of\n`a | b | (c | d)`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.alts₁Core\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">RCasesPatt</span>.<span class=\"name\">alts₁Core</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span>)</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L245-L248","name":"Std.Tactic.RCases.RCasesPatt.tuple₁","line":245,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.tuple₁","doc":"This function is used for producing rcases patterns based on a case tree. This is like\n`tuple₁Core` but it produces a pattern instead of a tuple pattern list, converting `[n]` to `n`\ninstead of `⟨n⟩` and `[]` to `_`, and otherwise just converting `[a, b, c]` to `⟨a, b, c⟩`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.tuple₁\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">RCasesPatt</span>.<span class=\"name\">tuple₁</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span> → <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L234-L238","name":"Std.Tactic.RCases.RCasesPatt.tuple₁Core","line":234,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.tuple₁Core","doc":"This function is used for producing rcases patterns based on a case tree. Suppose that we have\na list of patterns `ps` that will match correctly against the branches of the case tree for one\nconstructor. This function will merge tuples at the end of the list, so that `[a, b, ⟨c, d⟩]`\nbecomes `⟨a, b, c, d⟩` instead of `⟨a, b, ⟨c, d⟩⟩`.\n\nWe must be careful to turn `[a, ⟨⟩]` into `⟨a, ⟨⟩⟩` instead of `⟨a⟩` (which will not perform the\nnested match).\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.tuple₁Core\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">RCasesPatt</span>.<span class=\"name\">tuple₁Core</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L221-L223","name":"Std.Tactic.RCases.RCasesPatt.alts'","line":221,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.alts'","doc":"Convert a list of patterns to an alternation pattern, but mapping `[p]` to `p` instead of\na unary alternation `|p`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.alts'\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">RCasesPatt</span>.<span class=\"name\">alts'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ref : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span> → <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L213-L215","name":"Std.Tactic.RCases.RCasesPatt.tuple'","line":213,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.tuple'","doc":"Convert a list of patterns to a tuple pattern, but mapping `[p]` to `p` instead of `⟨p⟩`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.tuple'\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">RCasesPatt</span>.<span class=\"name\">tuple'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span> → <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L208-L210","name":"Std.Tactic.RCases.RCasesPatt.typed?","line":208,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.typed?","doc":"Convert a list of patterns to a tuple pattern, but mapping `[p]` to `p` instead of `⟨p⟩`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.typed?\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">RCasesPatt</span>.<span class=\"name\">typed?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ref : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a></span> → <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L202-L205","name":"Std.Tactic.RCases.RCasesPatt.asAlts","line":202,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.asAlts","doc":"Interpret an rcases pattern as an alternation, where non-alternations are treated as one\nalternative.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.asAlts\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">RCasesPatt</span>.<span class=\"name\">asAlts</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L192-L196","name":"Std.Tactic.RCases.RCasesPatt.asTuple","line":192,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.asTuple","doc":"Interpret an rcases pattern as a tuple, where `p` becomes `⟨p⟩` if `p` is not already a tuple.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.asTuple\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">RCasesPatt</span>.<span class=\"name\">asTuple</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L180-L187","name":"Std.Tactic.RCases.RCasesPatt.ref","line":180,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.ref","doc":"Get the syntax node from which this pattern was parsed. Used for error messages "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.ref\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">RCasesPatt</span>.<span class=\"name\">ref</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a> → <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L170-L177","name":"Std.Tactic.RCases.RCasesPatt.name?","line":170,"kind":"opaque","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.name?","doc":"Get the name from a pattern, if provided "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.name?\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">RCasesPatt</span>.<span class=\"name\">name?</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L167-L167","name":"Std.Tactic.RCases.RCasesPatt.instInhabitedRCasesPatt","line":167,"kind":"instance","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.instInhabitedRCasesPatt","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.instInhabitedRCasesPatt\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">RCasesPatt</span>.<span class=\"name\">instInhabitedRCasesPatt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L163-L163","name":"Std.Tactic.RCases.instReprRCasesPatt","line":163,"kind":"instance","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.instReprRCasesPatt","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.instReprRCasesPatt\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">instReprRCasesPatt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L161-L162","name":"Std.Tactic.RCases.RCasesPatt.alts","line":161,"kind":"ctor","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.alts","doc":"An alternation / variant pattern `p1 | p2 | p3` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.alts\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">RCasesPatt</span>.<span class=\"name\">alts</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ref : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span> → <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L159-L160","name":"Std.Tactic.RCases.RCasesPatt.tuple","line":159,"kind":"ctor","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.tuple","doc":"A tuple constructor like `⟨p1, p2, p3⟩` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.tuple\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">RCasesPatt</span>.<span class=\"name\">tuple</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ref : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span> → <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L157-L158","name":"Std.Tactic.RCases.RCasesPatt.typed","line":157,"kind":"ctor","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.typed","doc":"A type ascription like `pat : ty` (parentheses are optional) "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.typed\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">RCasesPatt</span>.<span class=\"name\">typed</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ref : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a> → <span class=\"fn\"><a href=\"./Init/Meta.html#Lean.Syntax.Term\">Lean.Term</a> → <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L155-L156","name":"Std.Tactic.RCases.RCasesPatt.explicit","line":155,"kind":"ctor","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.explicit","doc":"An explicit pattern `@pat`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.explicit\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">RCasesPatt</span>.<span class=\"name\">explicit</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ref : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a> → <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L153-L154","name":"Std.Tactic.RCases.RCasesPatt.clear","line":153,"kind":"ctor","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.clear","doc":"A hyphen `-`, which clears the active hypothesis and any dependents. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.clear\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">RCasesPatt</span>.<span class=\"name\">clear</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ref : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L151-L152","name":"Std.Tactic.RCases.RCasesPatt.one","line":151,"kind":"ctor","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.one","doc":"A named pattern like `foo` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.one\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">RCasesPatt</span>.<span class=\"name\">one</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ref : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L149-L150","name":"Std.Tactic.RCases.RCasesPatt.paren","line":149,"kind":"ctor","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.paren","doc":"A parenthesized expression, used for hovers "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt.paren\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">RCasesPatt</span>.<span class=\"name\">paren</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ref : <a href=\"./Init/Prelude.html#Lean.Syntax\">Lean.Syntax</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a> → <a href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\">Std.Tactic.RCases.RCasesPatt</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L148-L163","name":"Std.Tactic.RCases.RCasesPatt","line":148,"kind":"inductive","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt","doc":"An `rcases` pattern can be one of the following, in a nested combination:\n\n* A name like `foo`\n* The special keyword `rfl` (for pattern matching on equality using `subst`)\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* A type ascription like `pat : ty` (parentheses are optional)\n* A tuple constructor like `⟨p1, p2, p3⟩`\n* An alternation / variant pattern `p1 | p2 | p3`\n\nParentheses can be used for grouping; alternation is higher precedence than type ascription, so\n`p1 | p2 | p3 : ty` means `(p1 | p2 | p3) : ty`.\n\nN-ary alternations are treated as a group, so `p1 | p2 | p3` is not the same as `p1 | (p2 | p3)`,\nand similarly for tuples. However, note that an n-ary alternation or tuple can match an n-ary\nconjunction or disjunction, because if the number of patterns exceeds the number of constructors in\nthe type being destructed, the extra patterns will match on the last element, meaning that\n`p1 | p2 | p3` will act like `p1 | (p2 | p3)` when matching `a1 ∨ a2 ∨ a3`. If matching against a\ntype with 3 constructors,  `p1 | (p2 | p3)` will act like `p1 | (p2 | p3) | _` instead.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.RCasesPatt\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">RCasesPatt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L119-L120","name":"Std.Tactic.RCases.instCoeTSyntaxConsSyntaxNodeKindMkStr1Nil","line":119,"kind":"instance","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.instCoeTSyntaxConsSyntaxNodeKindMkStr1Nil","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.instCoeTSyntaxConsSyntaxNodeKindMkStr1Nil\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">instCoeTSyntaxConsSyntaxNodeKindMkStr1Nil</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`rcasesPat</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`rintroPat</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L117-L118","name":"Std.Tactic.RCases.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil","line":117,"kind":"instance","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Std.Tactic.RCases.rcasesPatMed</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Std.Tactic.RCases.rcasesPatLo</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L115-L116","name":"Std.Tactic.RCases.instCoeTSyntaxConsSyntaxNodeKindMkStr1NilMkStr4","line":115,"kind":"instance","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.instCoeTSyntaxConsSyntaxNodeKindMkStr1NilMkStr4","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.instCoeTSyntaxConsSyntaxNodeKindMkStr1NilMkStr4\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">instCoeTSyntaxConsSyntaxNodeKindMkStr1NilMkStr4</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`rcasesPat</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Std.Tactic.RCases.rcasesPatMed</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L113-L114","name":"Std.Tactic.RCases.instCoeIdentTSyntaxConsSyntaxNodeKindMkStr1Nil","line":113,"kind":"instance","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.instCoeIdentTSyntaxConsSyntaxNodeKindMkStr1Nil","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.instCoeIdentTSyntaxConsSyntaxNodeKindMkStr1Nil\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">instCoeIdentTSyntaxConsSyntaxNodeKindMkStr1Nil</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> <a href=\"./Init/Meta.html#Lean.Syntax.Ident\">Lean.Ident</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`rcasesPat</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L107-L111","name":"Std.Tactic.RCases.rintroPat.binder","line":107,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rintroPat.binder","doc":"A multi argument binder `(pat1 pat2 : ty)` binds a list of patterns and gives them all type `ty`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.rintroPat.binder\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">rintroPat</span>.<span class=\"name\">binder</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L105-L106","name":"Std.Tactic.RCases.rintroPat.one","line":105,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rintroPat.one","doc":"An `rcases` pattern is an `rintro` pattern "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.rintroPat.one\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">rintroPat</span>.<span class=\"name\">one</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L103-L104","name":"Lean.Parser.Category.rintroPat","line":103,"kind":"def","docLink":"./Std/Tactic/RCases.html#Lean.Parser.Category.rintroPat","doc":"The syntax category of `rintro` patterns. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Lean.Parser.Category.rintroPat\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Category</span>.<span class=\"name\">rintroPat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Notation.html#Lean.Parser.Category\">Lean.Parser.Category</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L103-L104","name":"Std.Tactic.RCases.rintroPat.quot","line":103,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rintroPat.quot","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.rintroPat.quot\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">rintroPat</span>.<span class=\"name\">quot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L100-L101","name":"Std.Tactic.RCases.rcasesPat.paren","line":100,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesPat.paren","doc":"`(pat)` is a pattern which resets the precedence to low "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesPat.paren\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">rcasesPat</span>.<span class=\"name\">paren</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L95-L99","name":"Std.Tactic.RCases.rcasesPat.tuple","line":95,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesPat.tuple","doc":"`⟨pat, ...⟩` is a pattern which matches on a tuple-like constructor\nor multi-argument inductive constructor\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesPat.tuple\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">rcasesPat</span>.<span class=\"name\">tuple</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L90-L94","name":"Std.Tactic.RCases.rcasesPat.explicit","line":90,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesPat.explicit","doc":"A `@` before a tuple pattern as in `@⟨p1, p2, p3⟩` will bind all arguments in the constructor,\nwhile leaving the `@` off will only use the patterns on the explicit arguments.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesPat.explicit\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">rcasesPat</span>.<span class=\"name\">explicit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L88-L89","name":"Std.Tactic.RCases.rcasesPat.clear","line":88,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesPat.clear","doc":"`-` is a pattern which removes the value from the context "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesPat.clear\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">rcasesPat</span>.<span class=\"name\">clear</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L86-L87","name":"Std.Tactic.RCases.rcasesPat.ignore","line":86,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesPat.ignore","doc":"`_` is a pattern which ignores the value and gives it an inaccessible name "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesPat.ignore\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">rcasesPat</span>.<span class=\"name\">ignore</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L84-L85","name":"Std.Tactic.RCases.rcasesPat.one","line":84,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesPat.one","doc":"`x` is a pattern which binds `x` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesPat.one\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">rcasesPat</span>.<span class=\"name\">one</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L82-L83","name":"Std.Tactic.RCases.rcasesPatLo","line":82,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesPatLo","doc":"A low precedence `rcases` pattern is a `rcasesPatMed` optionally followed by `: ty` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesPatLo\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">rcasesPatLo</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L80-L81","name":"Std.Tactic.RCases.rcasesPatMed","line":80,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesPatMed","doc":"A medium precedence `rcases` pattern is a list of `rcasesPat` separated by `|` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesPatMed\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">rcasesPatMed</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L78-L79","name":"Lean.Parser.Category.rcasesPat","line":78,"kind":"def","docLink":"./Std/Tactic/RCases.html#Lean.Parser.Category.rcasesPat","doc":"The syntax category of `rcases` patterns. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Lean.Parser.Category.rcasesPat\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Category</span>.<span class=\"name\">rcasesPat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Notation.html#Lean.Parser.Category\">Lean.Parser.Category</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L78-L79","name":"Std.Tactic.RCases.rcasesPat.quot","line":78,"kind":"def","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesPat.quot","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.rcasesPat.quot\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">rcasesPat</span>.<span class=\"name\">quot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L69-L76","name":"Std.Tactic.RCases.linter.unusedRCasesPattern","line":69,"kind":"opaque","docLink":"./Std/Tactic/RCases.html#Std.Tactic.RCases.linter.unusedRCasesPattern","doc":"Enables the 'unused rcases pattern' linter. This will warn when a pattern is ignored by\n`rcases`, `rintro`, `ext` and similar tactics.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Std.Tactic.RCases.linter.unusedRCasesPattern\"><span class=\"name\">Std</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">RCases</span>.<span class=\"name\">linter</span>.<span class=\"name\">unusedRCasesPattern</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/Options.html#Lean.Option\">Lean.Option</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/RCases.lean#L63-L64","name":"Lean.Meta.FVarSubst.append","line":63,"kind":"def","docLink":"./Std/Tactic/RCases.html#Lean.Meta.FVarSubst.append","doc":"Constructs a substitution consisting of `s` followed by `t`.\nThis satisfies `(s.append t).apply e = t.apply (s.apply e)`\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/RCases.html#Lean.Meta.FVarSubst.append\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">FVarSubst</span>.<span class=\"name\">append</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(s : <a href=\"./Lean/Meta/Tactic/FVarSubst.html#Lean.Meta.FVarSubst\">Lean.Meta.FVarSubst</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <a href=\"./Lean/Meta/Tactic/FVarSubst.html#Lean.Meta.FVarSubst\">Lean.Meta.FVarSubst</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/FVarSubst.html#Lean.Meta.FVarSubst\">Lean.Meta.FVarSubst</a></div></div>"}]}