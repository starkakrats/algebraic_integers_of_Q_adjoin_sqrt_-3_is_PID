{"name":"Mathlib.Tactic.DefEqTransformations","instances":[],"imports":["Init","Mathlib.Tactic.Basic"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/DefEqTransformations.lean#L293-L294","name":"Mathlib.Tactic.convEta_struct","line":293,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convEta_struct","doc":"`eta_struct at loc` transforms structure constructor applications such as `S.mk x.1 ... x.n`\n(pretty printed as, for example, `{a := x.a, b := x.b, ...}`) into `x`.\nThis also exists as a `conv`-mode tactic.\n\nThe transformation is known as eta reduction for structures, and it yields definitionally\nequal expressions.\n\nFor example, given `x : α × β`, then `(x.1, x.2)` becomes `x` after this transformation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convEta_struct\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">convEta_struct</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/DefEqTransformations.lean#L280-L291","name":"Mathlib.Tactic.etaStructStx","line":280,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaStructStx","doc":"`eta_struct at loc` transforms structure constructor applications such as `S.mk x.1 ... x.n`\n(pretty printed as, for example, `{a := x.a, b := x.b, ...}`) into `x`.\nThis also exists as a `conv`-mode tactic.\n\nThe transformation is known as eta reduction for structures, and it yields definitionally\nequal expressions.\n\nFor example, given `x : α × β`, then `(x.1, x.2)` becomes `x` after this transformation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaStructStx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">etaStructStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/DefEqTransformations.lean#L273-L278","name":"Mathlib.Tactic.etaStructAll","line":273,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaStructAll","doc":"Finds all occurrences of expressions of the form `S.mk x.1 ... x.n` where `S.mk`\nis a structure constructor and replaces them by `x`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaStructAll\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">etaStructAll</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/DefEqTransformations.lean#L259-L269","name":"Mathlib.Tactic.etaStruct?.findProj","line":259,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaStruct?.findProj","doc":"Check to see if there's an argument at some index `i`\nsuch that it's the `i`th projection of a some expression.\nReturns the expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaStruct?.findProj\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">etaStruct?</span>.<span class=\"name\">findProj</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(fVal : <a href=\"./Lean/Declaration.html#Lean.ConstructorVal\">Lean.ConstructorVal</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(args : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(m : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Lean/Data/LOption.html#Lean.LOption\">Lean.LOption</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/DefEqTransformations.lean#L240-L269","name":"Mathlib.Tactic.etaStruct?","line":240,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaStruct?","doc":"Checks if the expression is of the form `S.mk x.1 ... x.n` with `n` nonzero\nand `S.mk` a structure constructor and returns `x`.\nEach projection `x.i` can be either a native projection or from a projection function.\n\n`tryWhnfR` controls whether to try applying `whnfR` to arguments when none of them\nare obviously projections.\n\nOnce an obviously correct projection is found, relies on the structure eta rule in `isDefEq`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaStruct?\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">etaStruct?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tryWhnfR : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/DefEqTransformations.lean#L222-L230","name":"Mathlib.Tactic.getProjectedExpr","line":222,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.getProjectedExpr","doc":"Given an expression that's either a native projection or a registered projection\nfunction, gives (1) the name of the structure type, (2) the index of the projection, and\n(3) the object being projected. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.getProjectedExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">getProjectedExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">Nat</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span>)</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/DefEqTransformations.lean#L213-L214","name":"Mathlib.Tactic.convEta_expand","line":213,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convEta_expand","doc":"`eta_expand at loc` eta expands all sub-expressions at the given location.\nIt also beta reduces any applications of eta expanded terms, so it puts it\ninto an eta-expanded \"normal form.\"\nThis also exists as a `conv`-mode tactic.\n\nFor example, if `f` takes two arguments, then `f` becomes `fun x y => f x y`\nand `f x` becomes `fun y => f x y`.\n\nThis can be useful to turn, for example, a raw `HAdd.hAdd` into `fun x y => x + y`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convEta_expand\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">convEta_expand</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/DefEqTransformations.lean#L199-L211","name":"Mathlib.Tactic.etaExpandStx","line":199,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaExpandStx","doc":"`eta_expand at loc` eta expands all sub-expressions at the given location.\nIt also beta reduces any applications of eta expanded terms, so it puts it\ninto an eta-expanded \"normal form.\"\nThis also exists as a `conv`-mode tactic.\n\nFor example, if `f` takes two arguments, then `f` becomes `fun x y => f x y`\nand `f x` becomes `fun y => f x y`.\n\nThis can be useful to turn, for example, a raw `HAdd.hAdd` into `fun x y => x + y`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaExpandStx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">etaExpandStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/DefEqTransformations.lean#L180-L197","name":"Mathlib.Tactic.etaExpandAll","line":180,"kind":"opaque","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaExpandAll","doc":"Eta expand every sub-expression in the given expression.\n\nAs a side-effect, beta reduces any pre-existing instances of eta expanded terms.  "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaExpandAll\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">etaExpandAll</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/DefEqTransformations.lean#L171-L172","name":"Mathlib.Tactic.convEta_reduce","line":171,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convEta_reduce","doc":"`eta_reduce at loc` eta reduces all sub-expressions at the given location.\nThis also exists as a `conv`-mode tactic.\n\nFor example, `fun x y => f x y` becomes `f` after eta reduction.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convEta_reduce\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">convEta_reduce</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/DefEqTransformations.lean#L162-L169","name":"Mathlib.Tactic.etaReduceStx","line":162,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaReduceStx","doc":"`eta_reduce at loc` eta reduces all sub-expressions at the given location.\nThis also exists as a `conv`-mode tactic.\n\nFor example, `fun x y => f x y` becomes `f` after eta reduction.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaReduceStx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">etaReduceStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/DefEqTransformations.lean#L156-L160","name":"Mathlib.Tactic.etaReduceAll","line":156,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaReduceAll","doc":"Eta reduce everything "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.etaReduceAll\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">etaReduceAll</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/DefEqTransformations.lean#L149-L150","name":"Mathlib.Tactic.convUnfold_projs","line":149,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convUnfold_projs","doc":"`unfold_projs at loc` unfolds projections of class instances at the given location.\nThis also exists as a `conv`-mode tactic.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convUnfold_projs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">convUnfold_projs</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/DefEqTransformations.lean#L142-L147","name":"Mathlib.Tactic.unfoldProjsStx","line":142,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.unfoldProjsStx","doc":"`unfold_projs at loc` unfolds projections of class instances at the given location.\nThis also exists as a `conv`-mode tactic.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.unfoldProjsStx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">unfoldProjsStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/DefEqTransformations.lean#L135-L140","name":"Mathlib.Tactic.unfoldProjs","line":135,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.unfoldProjs","doc":"Recursively unfold all the projection applications for class instances. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.unfoldProjs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">unfoldProjs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/DefEqTransformations.lean#L123-L124","name":"Mathlib.Tactic.convUnfold_let___","line":123,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convUnfold_let___","doc":"`unfold_let x y z at loc` unfolds the local definitions `x`, `y`, and `z` at the given\nlocation, which is known as \"zeta reduction.\"\nThis also exists as a `conv`-mode tactic.\n\nIf no local definitions are given, then all local definitions are unfolded.\nThis variant also exists as the `conv`-mode tactic `zeta`.\n\nThis is similar to the `unfold` tactic, which instead is for unfolding global definitions.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convUnfold_let___\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">convUnfold_let___</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/DefEqTransformations.lean#L104-L115","name":"Mathlib.Tactic.unfoldLetStx","line":104,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.unfoldLetStx","doc":"`unfold_let x y z at loc` unfolds the local definitions `x`, `y`, and `z` at the given\nlocation, which is known as \"zeta reduction.\"\nThis also exists as a `conv`-mode tactic.\n\nIf no local definitions are given, then all local definitions are unfolded.\nThis variant also exists as the `conv`-mode tactic `zeta`.\n\nThis is similar to the `unfold` tactic, which instead is for unfolding global definitions.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.unfoldLetStx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">unfoldLetStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/DefEqTransformations.lean#L91-L102","name":"Mathlib.Tactic.unfoldFVars","line":91,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.unfoldFVars","doc":"Unfold all the fvars from `fvars` in `e` that have local definitions (are \"let-bound\"). "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.unfoldFVars\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">unfoldFVars</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(fvars : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.FVarId\">Lean.FVarId</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/DefEqTransformations.lean#L78-L85","name":"Mathlib.Tactic.tacticReduce__","line":78,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.tacticReduce__","doc":"`reduce at loc` completely reduces the given location.\nThis also exists as a `conv`-mode tactic.\n\nThis does the same transformation as the `#reduce` command.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.tacticReduce__\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticReduce__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/DefEqTransformations.lean#L72-L73","name":"Mathlib.Tactic.convBeta_reduce","line":72,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convBeta_reduce","doc":"`beta_reduce at loc` completely beta reduces the given location.\nThis also exists as a `conv`-mode tactic.\n\nThis means that whenever there is an applied lambda expression such as\n`(fun x => f x) y` then the argument is substituted into the lambda expression\nyielding an expression such as `f y`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.convBeta_reduce\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">convBeta_reduce</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/DefEqTransformations.lean#L61-L70","name":"Mathlib.Tactic.betaReduceStx","line":61,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.betaReduceStx","doc":"`beta_reduce at loc` completely beta reduces the given location.\nThis also exists as a `conv`-mode tactic.\n\nThis means that whenever there is an applied lambda expression such as\n`(fun x => f x) y` then the argument is substituted into the lambda expression\nyielding an expression such as `f y`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.betaReduceStx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">betaReduceStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/DefEqTransformations.lean#L48-L56","name":"Mathlib.Tactic.tacticWhnf__","line":48,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.tacticWhnf__","doc":"`whnf at loc` puts the given location into weak-head normal form.\nThis also exists as a `conv`-mode tactic.\n\nWeak-head normal form is when the outer-most expression has been fully reduced, the expression\nmay contain subexpressions which have not been reduced.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.tacticWhnf__\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticWhnf__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/DefEqTransformations.lean#L42-L43","name":"Mathlib.Tactic.runDefEqConvTactic","line":42,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.runDefEqConvTactic","doc":"Like `Mathlib.Tactic.runDefEqTactic` but for `conv` mode. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.runDefEqConvTactic\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">runDefEqConvTactic</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(m : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/DefEqTransformations.lean#L27-L39","name":"Mathlib.Tactic.runDefEqTactic","line":27,"kind":"def","docLink":"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.runDefEqTactic","doc":"For the main goal, use `m` to transform the types of locations specified by `loc?`.\nIf `loc?` is none, then transforms the type of target. `m` is provided with an expression\nwith instantiated metavariables.\n\n`m` *must* transform expressions to defeq expressions.\nIf `checkDefEq = true` (the default) then `runDefEqTactic` will throw an error\nif the resulting expression is not definitionally equal to the original expression. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/DefEqTransformations.html#Mathlib.Tactic.runDefEqTactic\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">runDefEqTactic</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(m : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(loc? : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.Parser.Tactic.location</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(tacticName : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(checkDefEq : <span class=\"fn\"><a href=\"./Init/Prelude.html#optParam\">optParam</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"}]}