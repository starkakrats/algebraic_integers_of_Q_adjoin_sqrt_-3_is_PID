{"name":"Mathlib.CategoryTheory.Abelian.Pseudoelements","instances":[{"typeNames":["CategoryTheory.Abelian.Pseudoelement"],"name":"CategoryTheory.Abelian.Pseudoelement.hasZero","className":"Zero"},{"typeNames":["CategoryTheory.Abelian.Pseudoelement"],"name":"CategoryTheory.Abelian.Pseudoelement.instInhabitedPseudoelement","className":"Inhabited"}],"imports":["Init","Mathlib.Init.Align","Mathlib.CategoryTheory.Abelian.Exact","Mathlib.CategoryTheory.Over","Mathlib.Algebra.Category.ModuleCat.EpiMono"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L480-L495","name":"CategoryTheory.Abelian.Pseudoelement.ModuleCat.eq_range_of_pseudoequal","line":480,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.ModuleCat.eq_range_of_pseudoequal","doc":"In the category `Module R`, if `x` and `y` are pseudoequal, then the range of the associated\nmorphisms is the same. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.ModuleCat.eq_range_of_pseudoequal\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">ModuleCat</span>.<span class=\"name\">eq_range_of_pseudoequal</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{R : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{G : <span class=\"fn\"><a href=\"./Mathlib/Algebra/Category/ModuleCat/Basic.html#ModuleCat\">ModuleCat</a> <span class=\"fn\">R</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{x : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Over.html#CategoryTheory.Over\">CategoryTheory.Over</a> <span class=\"fn\">G</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{y : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Over.html#CategoryTheory.Over\">CategoryTheory.Over</a> <span class=\"fn\">G</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.PseudoEqual\">CategoryTheory.Abelian.PseudoEqual</a> <span class=\"fn\">G</span> <span class=\"fn\">x</span> <span class=\"fn\">y</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/LinearAlgebra/Basic.html#LinearMap.range\">LinearMap.range</a> <span class=\"fn\"><span class=\"fn\">x</span>.hom</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/LinearAlgebra/Basic.html#LinearMap.range\">LinearMap.range</a> <span class=\"fn\"><span class=\"fn\">y</span>.hom</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L464-L473","name":"CategoryTheory.Abelian.Pseudoelement.pseudo_pullback","line":464,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudo_pullback","doc":"If `f : P ⟶ R` and `g : Q ⟶ R` are morphisms and `p : P` and `q : Q` are pseudoelements such\nthat `f p = g q`, then there is some `s : pullback f g` such that `fst s = p` and `snd s = q`.\n\nRemark: Borceux claims that `s` is unique, but this is false. See\n`Counterexamples/Pseudoelement.lean` for details. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudo_pullback\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">pseudo_pullback</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.HasPullbacks\">CategoryTheory.Limits.HasPullbacks</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{R : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">R</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">Q</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">R</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{p : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{q : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">Q</span></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span> <span class=\"fn\">p</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">g</span> <span class=\"fn\">q</span></span></span> →\n  <span class=\"fn\">∃ (s : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.pullback\">CategoryTheory.Limits.pullback</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>),\n    <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">CategoryTheory.Limits.pullback.fst</span> <span class=\"fn\">s</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">p</span></span> <a href=\"./Init/Prelude.html#And\">∧</a>       <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">CategoryTheory.Limits.pullback.snd</span> <span class=\"fn\">s</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">q</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L436-L454","name":"CategoryTheory.Abelian.Pseudoelement.sub_of_eq_image","line":436,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.sub_of_eq_image","doc":"If two pseudoelements `x` and `y` have the same image under some morphism `f`, then we can form\ntheir \"difference\" `z`. This pseudoelement has the properties that `f z = 0` and for all\nmorphisms `g`, if `g y = 0` then `g z = g x`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.sub_of_eq_image\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">sub_of_eq_image</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(y : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span> <span class=\"fn\">y</span></span></span> →\n  <span class=\"fn\">∃ (z : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span>),\n    <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span> <span class=\"fn\">z</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span> <a href=\"./Init/Prelude.html#And\">∧</a>       <span class=\"fn\">∀ (<span class=\"fn\">R</span> : <span class=\"fn\">C</span>) (<span class=\"fn\">g</span> : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">R</span></span>),\n        <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">g</span> <span class=\"fn\">y</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span> →\n          <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">g</span> <span class=\"fn\">z</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">g</span> <span class=\"fn\">x</span></span></span></span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L399-L428","name":"CategoryTheory.Abelian.Pseudoelement.exact_of_pseudo_exact","line":399,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.exact_of_pseudo_exact","doc":"If two morphisms are exact on pseudoelements, they are exact. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.exact_of_pseudo_exact\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">exact_of_pseudo_exact</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{R : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">Q</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">R</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\">∀ (<span class=\"fn\">a</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span>),\n      <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">g</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></span>)</span> <a href=\"./Init/Prelude.html#And\">∧</a>     <span class=\"fn\">∀ (<span class=\"fn\">b</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">Q</span></span>),\n      <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">g</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span> →\n        <span class=\"fn\">∃ (a : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></span></span></span>)</span> →\n  <span class=\"fn\"><a href=\"./Mathlib/Algebra/Homology/Exact.html#CategoryTheory.Exact\">CategoryTheory.Exact</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L392-L393","name":"CategoryTheory.Abelian.Pseudoelement.apply_eq_zero_of_comp_eq_zero","line":392,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.apply_eq_zero_of_comp_eq_zero","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.apply_eq_zero_of_comp_eq_zero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">apply_eq_zero_of_comp_eq_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{R : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">Q</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">R</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">a</span> <span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span> →\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span>\n      <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Quot.mk\">Quot.mk</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.PseudoEqual\">CategoryTheory.Abelian.PseudoEqual</a> <span class=\"fn\">Q</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.mk\">CategoryTheory.Over.mk</a> <span class=\"fn\">a</span></span>)</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>     <span class=\"fn\">0</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L359-L387","name":"CategoryTheory.Abelian.Pseudoelement.pseudo_exact_of_exact","line":359,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudo_exact_of_exact","doc":"Two morphisms in an exact sequence are exact on pseudoelements. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudo_exact_of_exact\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">pseudo_exact_of_exact</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{R : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{g : <span class=\"fn\"><span class=\"fn\">Q</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">R</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\"><a href=\"./Mathlib/Algebra/Homology/Exact.html#CategoryTheory.Exact\">CategoryTheory.Exact</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\">∀ (<span class=\"fn\">a</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span>),\n    <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">g</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></span>)</span> <a href=\"./Init/Prelude.html#And\">∧</a>   <span class=\"fn\">∀ (<span class=\"fn\">b</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">Q</span></span>),\n    <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">g</span> <span class=\"fn\">b</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span> →\n      <span class=\"fn\">∃ (a : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">b</span></span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L342-L353","name":"CategoryTheory.Abelian.Pseudoelement.epi_of_pseudo_surjective","line":342,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.epi_of_pseudo_surjective","doc":"A morphism that is surjective on pseudoelements is an epimorphism. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.epi_of_pseudo_surjective\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">epi_of_pseudo_surjective</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Init/Function.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span></span>)</span></span> → <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi\">CategoryTheory.Epi</a> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L330-L336","name":"CategoryTheory.Abelian.Pseudoelement.pseudo_surjective_of_epi","line":330,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudo_surjective_of_epi","doc":"An epimorphism is surjective on pseudoelements. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudo_surjective_of_epi\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">pseudo_surjective_of_epi</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi\">CategoryTheory.Epi</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Init/Function.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L321-L324","name":"CategoryTheory.Abelian.Pseudoelement.mono_of_zero_of_map_zero","line":321,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.mono_of_zero_of_map_zero","doc":"A morphism that only maps the zero pseudoelement to zero is a monomorphism. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.mono_of_zero_of_map_zero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">mono_of_zero_of_map_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\">∀ (<span class=\"fn\">a</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span> → <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></span></span>)</span> →\n  <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono\">CategoryTheory.Mono</a> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L314-L317","name":"CategoryTheory.Abelian.Pseudoelement.zero_of_map_zero","line":314,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.zero_of_map_zero","doc":"A morphism that is injective on pseudoelements only maps the zero element to zero. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.zero_of_map_zero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">zero_of_map_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Init/Function.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span></span>)</span></span> →\n  <span class=\"fn\">∀ (<span class=\"fn\">a</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span>), <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span> → <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L302-L310","name":"CategoryTheory.Abelian.Pseudoelement.pseudo_injective_of_mono","line":302,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudo_injective_of_mono","doc":"A monomorphism is injective on pseudoelements. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudo_injective_of_mono\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">pseudo_injective_of_mono</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono\">CategoryTheory.Mono</a> <span class=\"fn\">f</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Init/Function.html#Function.Injective\">Function.Injective</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L297-L298","name":"CategoryTheory.Abelian.Pseudoelement.eq_zero_iff","line":297,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.eq_zero_iff","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.eq_zero_iff\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">eq_zero_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\">∀ (<span class=\"fn\">a</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L287-L288","name":"CategoryTheory.Abelian.Pseudoelement.zero_morphism_ext'","line":287,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.zero_morphism_ext'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.zero_morphism_ext'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">zero_morphism_ext'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\">∀ (<span class=\"fn\">a</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></span>)</span> → <span class=\"fn\"><span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L282-L284","name":"CategoryTheory.Abelian.Pseudoelement.zero_morphism_ext","line":282,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.zero_morphism_ext","doc":"An extensionality lemma for being the zero arrow. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.zero_morphism_ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">zero_morphism_ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\">∀ (<span class=\"fn\">a</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span>), <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></span>)</span> → <span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L275-L278","name":"CategoryTheory.Abelian.Pseudoelement.zero_apply","line":275,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.zero_apply","doc":"The zero morphism maps every pseudoelement to 0. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.zero_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">zero_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(Q : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">0</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L268-L270","name":"CategoryTheory.Abelian.Pseudoelement.apply_zero","line":268,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.apply_zero","doc":"Morphisms map the zero pseudoelement to the zero pseudoelement. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.apply_zero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">apply_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span> <span class=\"fn\">0</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L257-L259","name":"CategoryTheory.Abelian.Pseudoelement.pseudoZero_iff","line":257,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoZero_iff","doc":"The pseudoelement induced by an arrow is zero precisely when that arrow is zero. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoZero_iff\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">pseudoZero_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Over.html#CategoryTheory.Over\">CategoryTheory.Over</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Quot.mk\">Quot.mk</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.PseudoEqual\">CategoryTheory.Abelian.PseudoEqual</a> <span class=\"fn\">P</span></span>)</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">a</span>.hom</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L252-L253","name":"CategoryTheory.Abelian.Pseudoelement.zero_eq_zero","line":252,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.zero_eq_zero","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.zero_eq_zero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">zero_eq_zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">⟦<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.mk\">CategoryTheory.Over.mk</a> <span class=\"fn\">0</span></span>⟧</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L248-L248","name":"CategoryTheory.Abelian.Pseudoelement.pseudoZero_def","line":248,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoZero_def","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoZero_def\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">pseudoZero_def</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">⟦<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.mk\">CategoryTheory.Over.mk</a> <span class=\"fn\">0</span></span>⟧</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L245-L246","name":"CategoryTheory.Abelian.Pseudoelement.instInhabitedPseudoelement","line":245,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.instInhabitedPseudoelement","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.instInhabitedPseudoelement\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">instInhabitedPseudoelement</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L241-L242","name":"CategoryTheory.Abelian.Pseudoelement.hasZero","line":241,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.hasZero","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.hasZero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">hasZero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Init/ZeroOne.html#Zero\">Zero</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L233-L234","name":"CategoryTheory.Abelian.Pseudoelement.pseudoZero","line":233,"kind":"def","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoZero","doc":"The zero pseudoelement is the class of a zero morphism. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoZero\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">pseudoZero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L227-L229","name":"CategoryTheory.Abelian.Pseudoelement.zero_eq_zero'","line":227,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.zero_eq_zero'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.zero_eq_zero'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">zero_eq_zero'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{R : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">⟦<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.mk\">CategoryTheory.Over.mk</a> <span class=\"fn\">0</span></span>⟧</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">⟦<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.mk\">CategoryTheory.Over.mk</a> <span class=\"fn\">0</span></span>⟧</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L219-L222","name":"CategoryTheory.Abelian.Pseudoelement.pseudoZero_aux","line":219,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoZero_aux","doc":"The arrows pseudo-equal to a zero morphism are precisely the zero morphisms. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoZero_aux\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">pseudoZero_aux</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(Q : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Over.html#CategoryTheory.Over\">CategoryTheory.Over</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Core.html#HasEquiv.Equiv\">≈</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.mk\">CategoryTheory.Over.mk</a> <span class=\"fn\">0</span></span></span> <a href=\"./Init/Core.html#Iff\">↔</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span>.hom</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L201-L202","name":"CategoryTheory.Abelian.Pseudoelement.comp_comp","line":201,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.comp_comp","doc":"Composition of functions on pseudoelements is composition of morphisms. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.comp_comp\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">comp_comp</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{R : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">Q</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">R</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">g</span></span> <a href=\"./Init/Prelude.html#Function.comp\">∘</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span></span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L193-L197","name":"CategoryTheory.Abelian.Pseudoelement.comp_apply","line":193,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.comp_apply","doc":"Applying a pseudoelement to a composition of morphisms is the same as composing\nwith each morphism. Sadly, this is not a definitional equality, but at least it is\ntrue. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.comp_apply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">comp_apply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{R : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><span class=\"fn\">Q</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">R</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>)</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">g</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L187-L187","name":"CategoryTheory.Abelian.Pseudoelement.pseudoApply_mk'","line":187,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply_mk'","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply_mk'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">pseudoApply_mk'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Over.html#CategoryTheory.Over\">CategoryTheory.Over</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\">CategoryTheory.Abelian.Pseudoelement.pseudoApply</a> <span class=\"fn\">f</span> <span class=\"fn\">⟦<span class=\"fn\">a</span>⟧</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\">⟦<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.mk\">CategoryTheory.Over.mk</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">a</span>.hom</span> <span class=\"fn\">f</span></span>)</span></span>⟧</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L179-L180","name":"CategoryTheory.Abelian.Pseudoelement.homToFun","line":179,"kind":"def","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.homToFun","doc":"A coercion from morphisms to functions on pseudoelements. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.homToFun\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">homToFun</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#CoeFun\">CoeFun</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span> <span class=\"fn\">fun (<span class=\"fn\">x</span> : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span> → <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">Q</span></span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L174-L175","name":"CategoryTheory.Abelian.Pseudoelement.pseudoApply","line":174,"kind":"def","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply","doc":"A morphism `f` induces a function `pseudoApply f` on pseudoelements. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">pseudoApply</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span> → <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">Q</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L168-L170","name":"CategoryTheory.Abelian.Pseudoelement.pseudoApply_aux","line":168,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply_aux","doc":"If two elements are pseudo-equal, then their composition with a morphism is, too. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.pseudoApply_aux\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">pseudoApply_aux</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Over.html#CategoryTheory.Over\">CategoryTheory.Over</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Over.html#CategoryTheory.Over\">CategoryTheory.Over</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Init/Core.html#HasEquiv.Equiv\">≈</a> <span class=\"fn\">b</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.app\">CategoryTheory.Abelian.app</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Core.html#HasEquiv.Equiv\">≈</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.app\">CategoryTheory.Abelian.app</a> <span class=\"fn\">f</span> <span class=\"fn\">b</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L164-L164","name":"CategoryTheory.Abelian.Pseudoelement.over_coe_def","line":164,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.over_coe_def","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.over_coe_def\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">over_coe_def</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\"><span class=\"fn\">Q</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Quot.mk\">Quot.mk</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.PseudoEqual\">CategoryTheory.Abelian.PseudoEqual</a> <span class=\"fn\">P</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.mk\">CategoryTheory.Over.mk</a> <span class=\"fn\">a</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">⟦<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.mk\">CategoryTheory.Over.mk</a> <span class=\"fn\">a</span></span>⟧</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L158-L159","name":"CategoryTheory.Abelian.Pseudoelement.overToSort","line":158,"kind":"def","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.overToSort","doc":"A coercion from an arrow with codomain `P` to its associated pseudoelement. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.overToSort\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">overToSort</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#Coe\">Coe</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Over.html#CategoryTheory.Over\">CategoryTheory.Over</a> <span class=\"fn\">P</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\">CategoryTheory.Abelian.Pseudoelement</a> <span class=\"fn\">P</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L149-L150","name":"CategoryTheory.Abelian.Pseudoelement.objectToSort","line":149,"kind":"def","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.objectToSort","doc":"A coercion from an object of an abelian category to its pseudoelements. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.objectToSort\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">objectToSort</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Coe.html#CoeSort\">CoeSort</a> <span class=\"fn\">C</span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max u v))</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L142-L143","name":"CategoryTheory.Abelian.Pseudoelement","line":142,"kind":"def","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement","doc":"A `Pseudoelement` of `P` is just an equivalence class of arrows ending in `P` by being\npseudo-equal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> (max u v)</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L134-L135","name":"CategoryTheory.Abelian.Pseudoelement.setoid","line":134,"kind":"def","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.setoid","doc":"The arrows with codomain `P` equipped with the equivalence relation of being pseudo-equal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.Pseudoelement.setoid\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">Pseudoelement</span>.<span class=\"name\">setoid</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#Setoid\">Setoid</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Over.html#CategoryTheory.Over\">CategoryTheory.Over</a> <span class=\"fn\">P</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L124-L128","name":"CategoryTheory.Abelian.pseudoEqual_trans","line":124,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.pseudoEqual_trans","doc":"Pseudoequality is transitive: Just take the pullback. The pullback morphisms will\nbe epimorphisms since in an abelian category, pullbacks of epimorphisms are epimorphisms. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.pseudoEqual_trans\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">pseudoEqual_trans</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Basic.html#CategoryTheory.Abelian\">CategoryTheory.Abelian</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Init/Logic.html#Transitive\">Transitive</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.PseudoEqual\">CategoryTheory.Abelian.PseudoEqual</a> <span class=\"fn\">P</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L114-L115","name":"CategoryTheory.Abelian.pseudoEqual_symm","line":114,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.pseudoEqual_symm","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.pseudoEqual_symm\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">pseudoEqual_symm</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Init/Logic.html#Symmetric\">Symmetric</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.PseudoEqual\">CategoryTheory.Abelian.PseudoEqual</a> <span class=\"fn\">P</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L110-L111","name":"CategoryTheory.Abelian.pseudoEqual_refl","line":110,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.pseudoEqual_refl","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.pseudoEqual_refl\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">pseudoEqual_refl</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Init/Logic.html#Reflexive\">Reflexive</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.PseudoEqual\">CategoryTheory.Abelian.PseudoEqual</a> <span class=\"fn\">P</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L106-L107","name":"CategoryTheory.Abelian.PseudoEqual","line":106,"kind":"def","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.PseudoEqual","doc":"Two arrows `f : X ⟶ P` and `g : Y ⟶ P` are called pseudo-equal if there is some object\n`R` and epimorphisms `p : R ⟶ X` and `q : R ⟶ Y` such that `p ≫ f = q ≫ g`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.PseudoEqual\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">PseudoEqual</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Over.html#CategoryTheory.Over\">CategoryTheory.Over</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(g : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Over.html#CategoryTheory.Over\">CategoryTheory.Over</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L101-L101","name":"CategoryTheory.Abelian.app_hom","line":101,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.app_hom","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.app_hom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">app_hom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Over.html#CategoryTheory.Over\">CategoryTheory.Over</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.app\">CategoryTheory.Abelian.app</a> <span class=\"fn\">f</span> <span class=\"fn\">a</span></span>)</span>.hom</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\"><span class=\"fn\">a</span>.hom</span> <span class=\"fn\">f</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Abelian/Pseudoelements.lean#L96-L97","name":"CategoryTheory.Abelian.app","line":96,"kind":"def","docLink":"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.app","doc":"This is just composition of morphisms in `C`. Another way to express this would be\n`(Over.map f).obj a`, but our definition has nicer definitional properties. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Abelian/Pseudoelements.html#CategoryTheory.Abelian.app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Abelian</span>.<span class=\"name\">app</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{Q : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">P</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Q</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(a : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Over.html#CategoryTheory.Over\">CategoryTheory.Over</a> <span class=\"fn\">P</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Over.html#CategoryTheory.Over\">CategoryTheory.Over</a> <span class=\"fn\">Q</span></span></div></div>"}]}