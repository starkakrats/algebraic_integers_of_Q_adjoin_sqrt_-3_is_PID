{"name":"Mathlib.Tactic.Classical","instances":[],"imports":["Init","Lean.Elab.ElabRules"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Classical.lean#L27-L51","name":"Mathlib.Tactic.tacticClassical_","line":27,"kind":"def","docLink":"./Mathlib/Tactic/Classical.html#Mathlib.Tactic.tacticClassical_","doc":"`classical tacs` runs `tacs` in a scope where `Classical.propDecidable` is a low priority\nlocal instance. It differs from `classical!` in that `classical!` uses a local variable,\nwhich has high priority:\n```\nnoncomputable def foo : Bool := by\n  classical!\n  have := ∀ p, decide p -- uses the classical instance\n  exact decide (0 < 1) -- uses the classical instance even though `0 < 1` is decidable\n\ndef bar : Bool := by\n  classical\n  have := ∀ p, decide p -- uses the classical instance\n  exact decide (0 < 1) -- uses the decidable instance\n```\nNote that (unlike lean 3) `classical` is a scoping tactic - it adds the instance only within the\nscope of the tactic.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Classical.html#Mathlib.Tactic.tacticClassical_\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticClassical_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/Classical.lean#L24-L25","name":"Mathlib.Tactic.classical!","line":24,"kind":"def","docLink":"./Mathlib/Tactic/Classical.html#Mathlib.Tactic.classical!","doc":"`classical!` adds a proof of `Classical.propDecidable` as a local variable, which makes it\navailable for instance search and effectively makes all propositions decidable.\n```\nnoncomputable def foo : Bool := by\n  classical!\n  have := ∀ p, decide p -- uses the classical instance\n  exact decide (0 < 1) -- uses the classical instance even though `0 < 1` is decidable\n```\nConsider using `classical` instead if you want to use the decidable instance when available.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Classical.html#Mathlib.Tactic.classical!\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">classical!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"}]}