{"name":"Mathlib.CategoryTheory.Sites.EqualizerSheafCondition","instances":[{"typeNames":["CategoryTheory.Equalizer.FirstObj"],"name":"CategoryTheory.Equalizer.instInhabitedFirstObjBotPresieveToBotInstCompleteLatticePresieve","className":"Inhabited"},{"typeNames":["CategoryTheory.Equalizer.FirstObj"],"name":"CategoryTheory.Equalizer.instInhabitedFirstObjArrowsBotSieveToBotInstCompleteLatticeSieve","className":"Inhabited"},{"typeNames":["CategoryTheory.Equalizer.Sieve.SecondObj"],"name":"CategoryTheory.Equalizer.Sieve.instInhabitedSecondObjBotSieveToBotInstCompleteLatticeSieve","className":"Inhabited"},{"typeNames":["CategoryTheory.Equalizer.Presieve.SecondObj"],"name":"CategoryTheory.Equalizer.Presieve.instInhabitedSecondObjBotPresieveToBotInstCompleteLatticePresieveInstHasPullbacks","className":"Inhabited"}],"imports":["Init","Mathlib.CategoryTheory.Sites.IsSheafFor","Mathlib.CategoryTheory.Limits.Shapes.Types","Mathlib.Tactic.ApplyFun"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L342-L358","name":"CategoryTheory.Equalizer.Presieve.Arrows.sheaf_condition","line":342,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.sheaf_condition","doc":"`P` is a sheaf for `Presieve.ofArrows X π`, iff the fork given by `w` is an equalizer.\nSee <https://stacks.math.columbia.edu/tag/00VM>.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.sheaf_condition\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">Arrows</span>.<span class=\"name\">sheaf_condition</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{B : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(π : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">I</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">X</span> <span class=\"fn\">i</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">B</span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.hasPullbacks\">CategoryTheory.Presieve.hasPullbacks</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.ofArrows\">CategoryTheory.Presieve.ofArrows</a> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.IsSheafFor\">CategoryTheory.Presieve.IsSheafFor</a> <span class=\"fn\">P</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.ofArrows\">CategoryTheory.Presieve.ofArrows</a> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span></span> <a href=\"./Init/Core.html#Iff\">↔</a>   <span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a>\n      <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ofι\">CategoryTheory.Limits.Fork.ofι</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.forkMap\">CategoryTheory.Equalizer.Presieve.Arrows.forkMap</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span>\n        <span class=\"fn\">(_ :\n          <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.forkMap\">CategoryTheory.Equalizer.Presieve.Arrows.forkMap</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span>\n              <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.firstMap\">CategoryTheory.Equalizer.Presieve.Arrows.firstMap</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>             <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.forkMap\">CategoryTheory.Equalizer.Presieve.Arrows.forkMap</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span>\n              <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.secondMap\">CategoryTheory.Equalizer.Presieve.Arrows.secondMap</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span></span></span>)</span></span>)</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L327-L336","name":"CategoryTheory.Equalizer.Presieve.Arrows.compatible_iff","line":327,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.compatible_iff","doc":"The family of elements given by `x : FirstObj P S` is compatible iff `firstMap` and `secondMap`\nmap it to the same point.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.compatible_iff\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">Arrows</span>.<span class=\"name\">compatible_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{B : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(π : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">I</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">X</span> <span class=\"fn\">i</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">B</span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.hasPullbacks\">CategoryTheory.Presieve.hasPullbacks</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.ofArrows\">CategoryTheory.Presieve.ofArrows</a> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.FirstObj\">CategoryTheory.Equalizer.Presieve.Arrows.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.Arrows.Compatible\">CategoryTheory.Presieve.Arrows.Compatible</a> <span class=\"fn\">P</span> <span class=\"fn\">π</span>\n    <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Types.html#CategoryTheory.Limits.Types.productIso\">CategoryTheory.Limits.Types.productIso</a> <span class=\"fn\">fun (<span class=\"fn\">i</span> : <span class=\"fn\">I</span>) =&gt; <span class=\"fn\"><span class=\"fn\">P</span>.obj <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <span class=\"fn\">i</span></span>)</span></span>)</span></span></span></span>)</span>.hom <span class=\"fn\">x</span></span>)</span></span> <a href=\"./Init/Core.html#Iff\">↔</a>   <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.firstMap\">CategoryTheory.Equalizer.Presieve.Arrows.firstMap</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span> <span class=\"fn\">π</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.secondMap\">CategoryTheory.Equalizer.Presieve.Arrows.secondMap</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span> <span class=\"fn\">π</span> <span class=\"fn\">x</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L318-L321","name":"CategoryTheory.Equalizer.Presieve.Arrows.w","line":318,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.w","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.w\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">Arrows</span>.<span class=\"name\">w</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{B : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(π : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">I</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">X</span> <span class=\"fn\">i</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">B</span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.hasPullbacks\">CategoryTheory.Presieve.hasPullbacks</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.ofArrows\">CategoryTheory.Presieve.ofArrows</a> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.forkMap\">CategoryTheory.Equalizer.Presieve.Arrows.forkMap</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.firstMap\">CategoryTheory.Equalizer.Presieve.Arrows.firstMap</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.forkMap\">CategoryTheory.Equalizer.Presieve.Arrows.forkMap</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.secondMap\">CategoryTheory.Equalizer.Presieve.Arrows.secondMap</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L316-L316","name":"CategoryTheory.Equalizer.Presieve.Arrows.secondMap","line":316,"kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.secondMap","doc":"The second of the two parallel morphisms of the fork diagram, induced by the second projection in\neach pullback.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.secondMap\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">Arrows</span>.<span class=\"name\">secondMap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{B : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(π : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">I</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">X</span> <span class=\"fn\">i</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">B</span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.hasPullbacks\">CategoryTheory.Presieve.hasPullbacks</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.ofArrows\">CategoryTheory.Presieve.ofArrows</a> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.FirstObj\">CategoryTheory.Equalizer.Presieve.Arrows.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.SecondObj\">CategoryTheory.Equalizer.Presieve.Arrows.SecondObj</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L310-L310","name":"CategoryTheory.Equalizer.Presieve.Arrows.firstMap","line":310,"kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.firstMap","doc":"The first of the two parallel morphisms of the fork diagram, induced by the first projection in\neach pullback.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.firstMap\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">Arrows</span>.<span class=\"name\">firstMap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{B : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(π : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">I</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">X</span> <span class=\"fn\">i</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">B</span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.hasPullbacks\">CategoryTheory.Presieve.hasPullbacks</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.ofArrows\">CategoryTheory.Presieve.ofArrows</a> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.FirstObj\">CategoryTheory.Equalizer.Presieve.Arrows.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.SecondObj\">CategoryTheory.Equalizer.Presieve.Arrows.SecondObj</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L304-L304","name":"CategoryTheory.Equalizer.Presieve.Arrows.forkMap","line":304,"kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.forkMap","doc":"The left morphism of the fork diagram.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.forkMap\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">Arrows</span>.<span class=\"name\">forkMap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{B : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(π : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">I</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">X</span> <span class=\"fn\">i</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">B</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span>.obj <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\">B</span></span>)</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.FirstObj\">CategoryTheory.Equalizer.Presieve.Arrows.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L295-L299","name":"CategoryTheory.Equalizer.Presieve.Arrows.SecondObj.ext","line":295,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.SecondObj.ext","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.SecondObj.ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">Arrows</span>.<span class=\"name\">SecondObj</span>.<span class=\"name\">ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{B : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(π : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">I</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">X</span> <span class=\"fn\">i</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">B</span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.hasPullbacks\">CategoryTheory.Presieve.hasPullbacks</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.ofArrows\">CategoryTheory.Presieve.ofArrows</a> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(z₁ : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.SecondObj\">CategoryTheory.Equalizer.Presieve.Arrows.SecondObj</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(z₂ : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.SecondObj\">CategoryTheory.Equalizer.Presieve.Arrows.SecondObj</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">ij</span> : <span class=\"fn\"><span class=\"fn\">I</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">I</span></span>),\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.π\">CategoryTheory.Limits.Pi.π</a>\n      <span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">ij</span> : <span class=\"fn\"><span class=\"fn\">I</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">I</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\">P</span>.obj <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.pullback\">CategoryTheory.Limits.pullback</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">π</span> <span class=\"fn\"><span class=\"fn\">ij</span>.1</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">π</span> <span class=\"fn\"><span class=\"fn\">ij</span>.2</span></span>)</span></span>)</span></span>)</span></span></span>)</span> <span class=\"fn\">ij</span> <span class=\"fn\">z₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>     <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.π\">CategoryTheory.Limits.Pi.π</a>\n      <span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">ij</span> : <span class=\"fn\"><span class=\"fn\">I</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">I</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\">P</span>.obj <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.pullback\">CategoryTheory.Limits.pullback</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">π</span> <span class=\"fn\"><span class=\"fn\">ij</span>.1</span></span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">π</span> <span class=\"fn\"><span class=\"fn\">ij</span>.2</span></span>)</span></span>)</span></span>)</span></span></span>)</span> <span class=\"fn\">ij</span> <span class=\"fn\">z₂</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">z₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">z₂</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L291-L292","name":"CategoryTheory.Equalizer.Presieve.Arrows.SecondObj","line":291,"kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.SecondObj","doc":"The rightmost object of the fork diagram of https://stacks.math.columbia.edu/tag/00VM.\nThe difference between this and `Equalizer.Presieve.SecondObj P (ofArrows X π)` arrises if the\nfamily of arrows `π` contains duplicates. The `Presieve.ofArrows` doesn't see those.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.SecondObj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">Arrows</span>.<span class=\"name\">SecondObj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{B : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(π : <span class=\"fn\">(<span class=\"fn\">i</span> : <span class=\"fn\">I</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">X</span> <span class=\"fn\">i</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">B</span></span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.hasPullbacks\">CategoryTheory.Presieve.hasPullbacks</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.ofArrows\">CategoryTheory.Presieve.ofArrows</a> <span class=\"fn\">X</span> <span class=\"fn\">π</span></span>)</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> (max v u)</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L280-L284","name":"CategoryTheory.Equalizer.Presieve.Arrows.FirstObj.ext","line":280,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.FirstObj.ext","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.FirstObj.ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">Arrows</span>.<span class=\"name\">FirstObj</span>.<span class=\"name\">ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(z₁ : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.FirstObj\">CategoryTheory.Equalizer.Presieve.Arrows.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(z₂ : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.FirstObj\">CategoryTheory.Equalizer.Presieve.Arrows.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">i</span> : <span class=\"fn\">I</span>),\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.π\">CategoryTheory.Limits.Pi.π</a> <span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">i</span> : <span class=\"fn\">I</span>) =&gt; <span class=\"fn\"><span class=\"fn\">P</span>.obj <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <span class=\"fn\">i</span></span>)</span></span>)</span></span></span>)</span> <span class=\"fn\">i</span> <span class=\"fn\">z₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>     <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.π\">CategoryTheory.Limits.Pi.π</a> <span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">i</span> : <span class=\"fn\">I</span>) =&gt; <span class=\"fn\"><span class=\"fn\">P</span>.obj <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">X</span> <span class=\"fn\">i</span></span>)</span></span>)</span></span></span>)</span> <span class=\"fn\">i</span> <span class=\"fn\">z₂</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">z₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">z₂</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L277-L277","name":"CategoryTheory.Equalizer.Presieve.Arrows.FirstObj","line":277,"kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.FirstObj","doc":"The middle object of the fork diagram of <https://stacks.math.columbia.edu/tag/00VM>.\nThe difference between this and `Equalizer.FirstObj P (ofArrows X π)` arrises if the family of\narrows `π` contains duplicates. The `Presieve.ofArrows` doesn't see those.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.Arrows.FirstObj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">Arrows</span>.<span class=\"name\">FirstObj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{I : <a href=\"./foundational_types.html\">Type</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(X : <span class=\"fn\"><span class=\"fn\">I</span> → <span class=\"fn\">C</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> (max v u)</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L246-L261","name":"CategoryTheory.Equalizer.Presieve.sheaf_condition","line":246,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.sheaf_condition","doc":"`P` is a sheaf for `R`, iff the fork given by `w` is an equalizer.\nSee <https://stacks.math.columbia.edu/tag/00VM>.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.sheaf_condition\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">sheaf_condition</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(R : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve\">CategoryTheory.Presieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.hasPullbacks\">CategoryTheory.Presieve.hasPullbacks</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.IsSheafFor\">CategoryTheory.Presieve.IsSheafFor</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span> <a href=\"./Init/Core.html#Iff\">↔</a>   <span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a>\n      <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ofι\">CategoryTheory.Limits.Fork.ofι</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.forkMap\">CategoryTheory.Equalizer.forkMap</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span>)</span>\n        <span class=\"fn\">(_ :\n          <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.forkMap\">CategoryTheory.Equalizer.forkMap</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span>)</span>\n              <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.firstMap\">CategoryTheory.Equalizer.Presieve.firstMap</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>             <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.forkMap\">CategoryTheory.Equalizer.forkMap</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span>)</span>\n              <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.secondMap\">CategoryTheory.Equalizer.Presieve.secondMap</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span>)</span></span></span>)</span></span>)</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L230-L240","name":"CategoryTheory.Equalizer.Presieve.compatible_iff","line":230,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.compatible_iff","doc":"The family of elements given by `x : FirstObj P S` is compatible iff `firstMap` and `secondMap`\nmap it to the same point.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.compatible_iff\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">compatible_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(R : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve\">CategoryTheory.Presieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.hasPullbacks\">CategoryTheory.Presieve.hasPullbacks</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj\">CategoryTheory.Equalizer.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.FamilyOfElements.Compatible\">CategoryTheory.Presieve.FamilyOfElements.Compatible</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.firstObjEqFamily\">CategoryTheory.Equalizer.firstObjEqFamily</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span>)</span>.hom <span class=\"fn\">x</span></span>)</span></span> <a href=\"./Init/Core.html#Iff\">↔</a>   <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.firstMap\">CategoryTheory.Equalizer.Presieve.firstMap</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.secondMap\">CategoryTheory.Equalizer.Presieve.secondMap</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span> <span class=\"fn\">x</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L216-L223","name":"CategoryTheory.Equalizer.Presieve.w","line":216,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.w","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.w\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">w</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(R : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve\">CategoryTheory.Presieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.hasPullbacks\">CategoryTheory.Presieve.hasPullbacks</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.forkMap\">CategoryTheory.Equalizer.forkMap</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.firstMap\">CategoryTheory.Equalizer.Presieve.firstMap</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.forkMap\">CategoryTheory.Equalizer.forkMap</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.secondMap\">CategoryTheory.Equalizer.Presieve.secondMap</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L210-L213","name":"CategoryTheory.Equalizer.Presieve.secondMap","line":210,"kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.secondMap","doc":"The map `pr₁*` of <https://stacks.math.columbia.edu/tag/00VL>. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.secondMap\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">secondMap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(R : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve\">CategoryTheory.Presieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.hasPullbacks\">CategoryTheory.Presieve.hasPullbacks</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj\">CategoryTheory.Equalizer.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.SecondObj\">CategoryTheory.Equalizer.Presieve.SecondObj</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L206-L207","name":"CategoryTheory.Equalizer.Presieve.instInhabitedSecondObjBotPresieveToBotInstCompleteLatticePresieveInstHasPullbacks","line":206,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.instInhabitedSecondObjBotPresieveToBotInstCompleteLatticePresieveInstHasPullbacks","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.instInhabitedSecondObjBotPresieveToBotInstCompleteLatticePresieveInstHasPullbacks\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">instInhabitedSecondObjBotPresieveToBotInstCompleteLatticePresieveInstHasPullbacks</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.HasPullbacks\">CategoryTheory.Limits.HasPullbacks</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.SecondObj\">CategoryTheory.Equalizer.Presieve.SecondObj</a> <span class=\"fn\">P</span> <a href=\"./Mathlib/Order/Notation.html#Bot.bot\">⊥</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L200-L203","name":"CategoryTheory.Equalizer.Presieve.firstMap","line":200,"kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.firstMap","doc":"The map `pr₀*` of <https://stacks.math.columbia.edu/tag/00VL>. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.firstMap\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">firstMap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(R : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve\">CategoryTheory.Presieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.hasPullbacks\">CategoryTheory.Presieve.hasPullbacks</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj\">CategoryTheory.Equalizer.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.SecondObj\">CategoryTheory.Equalizer.Presieve.SecondObj</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L193-L196","name":"CategoryTheory.Equalizer.Presieve.SecondObj","line":193,"kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.SecondObj","doc":"The rightmost object of the fork diagram of https://stacks.math.columbia.edu/tag/00VM, which\ncontains the data used to check a family of elements for a presieve is compatible.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Presieve.SecondObj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Presieve</span>.<span class=\"name\">SecondObj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(R : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve\">CategoryTheory.Presieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.hasPullbacks\">CategoryTheory.Presieve.hasPullbacks</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> (max v u)</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L156-L174","name":"CategoryTheory.Equalizer.Sieve.equalizer_sheaf_condition","line":156,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.equalizer_sheaf_condition","doc":"`P` is a sheaf for `S`, iff the fork given by `w` is an equalizer. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.equalizer_sheaf_condition\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Sieve</span>.<span class=\"name\">equalizer_sheaf_condition</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(S : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve\">CategoryTheory.Sieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.IsSheafFor\">CategoryTheory.Presieve.IsSheafFor</a> <span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">S</span>.arrows</span></span> <a href=\"./Init/Core.html#Iff\">↔</a>   <span class=\"fn\"><a href=\"./Init/Prelude.html#Nonempty\">Nonempty</a>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit\">CategoryTheory.Limits.IsLimit</a>\n      <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.Fork.ofι\">CategoryTheory.Limits.Fork.ofι</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.forkMap\">CategoryTheory.Equalizer.forkMap</a> <span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">S</span>.arrows</span></span>)</span>\n        <span class=\"fn\">(_ :\n          <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.forkMap\">CategoryTheory.Equalizer.forkMap</a> <span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">S</span>.arrows</span></span>)</span>\n              <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.firstMap\">CategoryTheory.Equalizer.Sieve.firstMap</a> <span class=\"fn\">P</span> <span class=\"fn\">S</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>             <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.forkMap\">CategoryTheory.Equalizer.forkMap</a> <span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">S</span>.arrows</span></span>)</span>\n              <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.secondMap\">CategoryTheory.Equalizer.Sieve.secondMap</a> <span class=\"fn\">P</span> <span class=\"fn\">S</span></span>)</span></span></span>)</span></span>)</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L142-L152","name":"CategoryTheory.Equalizer.Sieve.compatible_iff","line":142,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.compatible_iff","doc":"The family of elements given by `x : FirstObj P S` is compatible iff `firstMap` and `secondMap`\nmap it to the same point.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.compatible_iff\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Sieve</span>.<span class=\"name\">compatible_iff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(S : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve\">CategoryTheory.Sieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(x : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj\">CategoryTheory.Equalizer.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">S</span>.arrows</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.FamilyOfElements.Compatible\">CategoryTheory.Presieve.FamilyOfElements.Compatible</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.firstObjEqFamily\">CategoryTheory.Equalizer.firstObjEqFamily</a> <span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">S</span>.arrows</span></span>)</span>.hom <span class=\"fn\">x</span></span>)</span></span> <a href=\"./Init/Core.html#Iff\">↔</a>   <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.firstMap\">CategoryTheory.Equalizer.Sieve.firstMap</a> <span class=\"fn\">P</span> <span class=\"fn\">S</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.secondMap\">CategoryTheory.Equalizer.Sieve.secondMap</a> <span class=\"fn\">P</span> <span class=\"fn\">S</span> <span class=\"fn\">x</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L133-L135","name":"CategoryTheory.Equalizer.Sieve.w","line":133,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.w","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.w\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Sieve</span>.<span class=\"name\">w</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(S : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve\">CategoryTheory.Sieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.forkMap\">CategoryTheory.Equalizer.forkMap</a> <span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">S</span>.arrows</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.firstMap\">CategoryTheory.Equalizer.Sieve.firstMap</a> <span class=\"fn\">P</span> <span class=\"fn\">S</span></span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.forkMap\">CategoryTheory.Equalizer.forkMap</a> <span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">S</span>.arrows</span></span>)</span>\n    <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.secondMap\">CategoryTheory.Equalizer.Sieve.secondMap</a> <span class=\"fn\">P</span> <span class=\"fn\">S</span></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L129-L130","name":"CategoryTheory.Equalizer.Sieve.secondMap","line":129,"kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.secondMap","doc":"The map `a` of Equations (3,4) [MM92]. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.secondMap\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Sieve</span>.<span class=\"name\">secondMap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(S : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve\">CategoryTheory.Sieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj\">CategoryTheory.Equalizer.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">S</span>.arrows</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.SecondObj\">CategoryTheory.Equalizer.Sieve.SecondObj</a> <span class=\"fn\">P</span> <span class=\"fn\">S</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L125-L126","name":"CategoryTheory.Equalizer.Sieve.instInhabitedSecondObjBotSieveToBotInstCompleteLatticeSieve","line":125,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.instInhabitedSecondObjBotSieveToBotInstCompleteLatticeSieve","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.instInhabitedSecondObjBotSieveToBotInstCompleteLatticeSieve\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Sieve</span>.<span class=\"name\">instInhabitedSecondObjBotSieveToBotInstCompleteLatticeSieve</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.SecondObj\">CategoryTheory.Equalizer.Sieve.SecondObj</a> <span class=\"fn\">P</span> <a href=\"./Mathlib/Order/Notation.html#Bot.bot\">⊥</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L120-L122","name":"CategoryTheory.Equalizer.Sieve.firstMap","line":120,"kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.firstMap","doc":"The map `p` of Equations (3,4) [MM92]. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.firstMap\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Sieve</span>.<span class=\"name\">firstMap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(S : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve\">CategoryTheory.Sieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj\">CategoryTheory.Equalizer.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">S</span>.arrows</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.SecondObj\">CategoryTheory.Equalizer.Sieve.SecondObj</a> <span class=\"fn\">P</span> <span class=\"fn\">S</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L110-L115","name":"CategoryTheory.Equalizer.Sieve.SecondObj.ext","line":110,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.SecondObj.ext","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.SecondObj.ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Sieve</span>.<span class=\"name\">SecondObj</span>.<span class=\"name\">ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{S : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve\">CategoryTheory.Sieve</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(z₁ : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.SecondObj\">CategoryTheory.Equalizer.Sieve.SecondObj</a> <span class=\"fn\">P</span> <span class=\"fn\">S</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(z₂ : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.SecondObj\">CategoryTheory.Equalizer.Sieve.SecondObj</a> <span class=\"fn\">P</span> <span class=\"fn\">S</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">Y </span>Z : <span class=\"fn\">C</span>) (<span class=\"fn\">g</span> : <span class=\"fn\"><span class=\"fn\">Z</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>) (<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>) (<span class=\"fn\">hf</span> : <span class=\"fn\"><span class=\"fn\">S</span>.arrows <span class=\"fn\">f</span></span>),\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.π\">CategoryTheory.Limits.Pi.π</a>\n      <span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">f</span> : <span class=\"fn\">(Y : <span class=\"fn\">C</span>) × <span class=\"fn\">(Z : <span class=\"fn\">C</span>) × <span class=\"fn\">(_ : <span class=\"fn\"><span class=\"fn\">Z</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>) × <span class=\"fn\">{ <span class=\"fn\">f'</span> : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span> // <span class=\"fn\"><span class=\"fn\">S</span>.arrows <span class=\"fn\">f'</span></span> }</span></span></span></span>) =&gt; <span class=\"fn\"><span class=\"fn\">P</span>.obj <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span>.snd</span>.fst</span></span>)</span></span></span>)</span>\n      <span class=\"fn\">{ <span class=\"fn\">fst</span> := <span class=\"fn\">Y</span>, <span class=\"fn\">snd</span> := <span class=\"fn\">{ <span class=\"fn\">fst</span> := <span class=\"fn\">Z</span>, <span class=\"fn\">snd</span> := <span class=\"fn\">{ <span class=\"fn\">fst</span> := <span class=\"fn\">g</span>, <span class=\"fn\">snd</span> := <span class=\"fn\">{ <span class=\"fn\">val</span> := <span class=\"fn\">f</span>, <span class=\"fn\">property</span> := <span class=\"fn\">hf</span> }</span> }</span> }</span> }</span> <span class=\"fn\">z₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>     <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.π\">CategoryTheory.Limits.Pi.π</a>\n      <span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">f</span> : <span class=\"fn\">(Y : <span class=\"fn\">C</span>) × <span class=\"fn\">(Z : <span class=\"fn\">C</span>) × <span class=\"fn\">(_ : <span class=\"fn\"><span class=\"fn\">Z</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span></span>) × <span class=\"fn\">{ <span class=\"fn\">f'</span> : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span> // <span class=\"fn\"><span class=\"fn\">S</span>.arrows <span class=\"fn\">f'</span></span> }</span></span></span></span>) =&gt; <span class=\"fn\"><span class=\"fn\">P</span>.obj <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">f</span>.snd</span>.fst</span></span>)</span></span></span>)</span>\n      <span class=\"fn\">{ <span class=\"fn\">fst</span> := <span class=\"fn\">Y</span>, <span class=\"fn\">snd</span> := <span class=\"fn\">{ <span class=\"fn\">fst</span> := <span class=\"fn\">Z</span>, <span class=\"fn\">snd</span> := <span class=\"fn\">{ <span class=\"fn\">fst</span> := <span class=\"fn\">g</span>, <span class=\"fn\">snd</span> := <span class=\"fn\">{ <span class=\"fn\">val</span> := <span class=\"fn\">f</span>, <span class=\"fn\">property</span> := <span class=\"fn\">hf</span> }</span> }</span> }</span> }</span> <span class=\"fn\">z₂</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">z₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">z₂</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L102-L103","name":"CategoryTheory.Equalizer.Sieve.SecondObj","line":102,"kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.SecondObj","doc":"The rightmost object of the fork diagram of Equation (3) [MM92], which contains the data used\nto check a family is compatible.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.Sieve.SecondObj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">Sieve</span>.<span class=\"name\">SecondObj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(S : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve\">CategoryTheory.Sieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> (max v u)</div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L87-L88","name":"CategoryTheory.Equalizer.forkMap","line":87,"kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.forkMap","doc":"The left morphism of the fork diagram given in Equation (3) of [MM92], as well as the fork diagram\nof <https://stacks.math.columbia.edu/tag/00VM>.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.forkMap\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">forkMap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(R : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve\">CategoryTheory.Presieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span>.obj <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\">X</span></span>)</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj\">CategoryTheory.Equalizer.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L80-L81","name":"CategoryTheory.Equalizer.instInhabitedFirstObjArrowsBotSieveToBotInstCompleteLatticeSieve","line":80,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.instInhabitedFirstObjArrowsBotSieveToBotInstCompleteLatticeSieve","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.instInhabitedFirstObjArrowsBotSieveToBotInstCompleteLatticeSieve\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">instInhabitedFirstObjArrowsBotSieveToBotInstCompleteLatticeSieve</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj\">CategoryTheory.Equalizer.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\"><a href=\"./Mathlib/Order/Notation.html#Bot.bot\">⊥</a>.arrows</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L76-L77","name":"CategoryTheory.Equalizer.instInhabitedFirstObjBotPresieveToBotInstCompleteLatticePresieve","line":76,"kind":"instance","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.instInhabitedFirstObjBotPresieveToBotInstCompleteLatticePresieve","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.instInhabitedFirstObjBotPresieveToBotInstCompleteLatticePresieve\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">instInhabitedFirstObjBotPresieveToBotInstCompleteLatticePresieve</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj\">CategoryTheory.Equalizer.FirstObj</a> <span class=\"fn\">P</span> <a href=\"./Mathlib/Order/Notation.html#Bot.bot\">⊥</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L71-L73","name":"CategoryTheory.Equalizer.firstObjEqFamily","line":71,"kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.firstObjEqFamily","doc":"Show that `FirstObj` is isomorphic to `FamilyOfElements`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.firstObjEqFamily\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">firstObjEqFamily</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(R : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve\">CategoryTheory.Presieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj\">CategoryTheory.Equalizer.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span> <a href=\"./Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso\">≅</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.FamilyOfElements\">CategoryTheory.Presieve.FamilyOfElements</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L70-L70","name":"CategoryTheory.Equalizer.firstObjEqFamily_inv","line":70,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.firstObjEqFamily_inv","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.firstObjEqFamily_inv\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">firstObjEqFamily_inv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(R : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve\">CategoryTheory.Presieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">∀ (<span class=\"fn\">a</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.FamilyOfElements\">CategoryTheory.Presieve.FamilyOfElements</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span>),\n  <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.firstObjEqFamily\">CategoryTheory.Equalizer.firstObjEqFamily</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span>)</span>.inv <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>     <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.lift\">CategoryTheory.Limits.Pi.lift</a>\n      <span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">f</span> : <span class=\"fn\">(Y : <span class=\"fn\">C</span>) × <span class=\"fn\">{ <span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span> // <span class=\"fn\"><span class=\"fn\">R</span> <span class=\"fn\">f</span></span> }</span></span>) (<span class=\"fn\">x</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.FamilyOfElements\">CategoryTheory.Presieve.FamilyOfElements</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span>) =&gt;\n        <span class=\"fn\"><span class=\"fn\">x</span> <span class=\"fn\">↑<span class=\"fn\"><span class=\"fn\">f</span>.snd</span></span> <span class=\"fn\">(_ : <span class=\"fn\"><span class=\"fn\">R</span> <span class=\"fn\">↑<span class=\"fn\"><span class=\"fn\">f</span>.snd</span></span></span>)</span></span></span>)</span>\n      <span class=\"fn\">a</span></span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L70-L70","name":"CategoryTheory.Equalizer.firstObjEqFamily_hom","line":70,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.firstObjEqFamily_hom","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.firstObjEqFamily_hom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">firstObjEqFamily_hom</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(R : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve\">CategoryTheory.Presieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj\">CategoryTheory.Equalizer.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Y : <span class=\"fn\">C</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(f : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hf : <span class=\"fn\"><span class=\"fn\">R</span> <span class=\"fn\">f</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.firstObjEqFamily\">CategoryTheory.Equalizer.firstObjEqFamily</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span>)</span>.hom <span class=\"fn\">t</span> <span class=\"fn\">f</span> <span class=\"fn\">hf</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.π\">CategoryTheory.Limits.Pi.π</a> <span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">f</span> : <span class=\"fn\">(Y : <span class=\"fn\">C</span>) × <span class=\"fn\">{ <span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span> // <span class=\"fn\"><span class=\"fn\">R</span> <span class=\"fn\">f</span></span> }</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\">P</span>.obj <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\"><span class=\"fn\">f</span>.fst</span></span>)</span></span></span>)</span>\n    <span class=\"fn\">{ <span class=\"fn\">fst</span> := <span class=\"fn\">Y</span>, <span class=\"fn\">snd</span> := <span class=\"fn\">{ <span class=\"fn\">val</span> := <span class=\"fn\">f</span>, <span class=\"fn\">property</span> := <span class=\"fn\">hf</span> }</span> }</span> <span class=\"fn\">t</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L60-L65","name":"CategoryTheory.Equalizer.FirstObj.ext","line":60,"kind":"theorem","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj.ext","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj.ext\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">FirstObj</span>.<span class=\"name\">ext</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{R : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve\">CategoryTheory.Presieve</a> <span class=\"fn\">X</span></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(z₁ : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj\">CategoryTheory.Equalizer.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(z₂ : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj\">CategoryTheory.Equalizer.FirstObj</a> <span class=\"fn\">P</span> <span class=\"fn\">R</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(h : <span class=\"fn\">∀ (<span class=\"fn\">Y</span> : <span class=\"fn\">C</span>) (<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span>) (<span class=\"fn\">hf</span> : <span class=\"fn\"><span class=\"fn\">R</span> <span class=\"fn\">f</span></span>),\n  <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.π\">CategoryTheory.Limits.Pi.π</a> <span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">f</span> : <span class=\"fn\">(Y : <span class=\"fn\">C</span>) × <span class=\"fn\">{ <span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span> // <span class=\"fn\"><span class=\"fn\">R</span> <span class=\"fn\">f</span></span> }</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\">P</span>.obj <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\"><span class=\"fn\">f</span>.fst</span></span>)</span></span></span>)</span>\n      <span class=\"fn\">{ <span class=\"fn\">fst</span> := <span class=\"fn\">Y</span>, <span class=\"fn\">snd</span> := <span class=\"fn\">{ <span class=\"fn\">val</span> := <span class=\"fn\">f</span>, <span class=\"fn\">property</span> := <span class=\"fn\">hf</span> }</span> }</span> <span class=\"fn\">z₁</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>     <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Pi.π\">CategoryTheory.Limits.Pi.π</a> <span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">f</span> : <span class=\"fn\">(Y : <span class=\"fn\">C</span>) × <span class=\"fn\">{ <span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">X</span></span> // <span class=\"fn\"><span class=\"fn\">R</span> <span class=\"fn\">f</span></span> }</span></span>) =&gt; <span class=\"fn\"><span class=\"fn\">P</span>.obj <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\"><span class=\"fn\">f</span>.fst</span></span>)</span></span></span>)</span>\n      <span class=\"fn\">{ <span class=\"fn\">fst</span> := <span class=\"fn\">Y</span>, <span class=\"fn\">snd</span> := <span class=\"fn\">{ <span class=\"fn\">val</span> := <span class=\"fn\">f</span>, <span class=\"fn\">property</span> := <span class=\"fn\">hf</span> }</span> }</span> <span class=\"fn\">z₂</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">z₁</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">z₂</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.lean#L52-L53","name":"CategoryTheory.Equalizer.FirstObj","line":52,"kind":"def","docLink":"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj","doc":"The middle object of the fork diagram given in Equation (3) of [MM92], as well as the fork diagram\nof <https://stacks.math.columbia.edu/tag/00VM>.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Sites/EqualizerSheafCondition.html#CategoryTheory.Equalizer.FirstObj\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Equalizer</span>.<span class=\"name\">FirstObj</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{C : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v, u}</a>    <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor\">CategoryTheory.Functor</a> <span class=\"fn\"><span class=\"fn\">C</span><a href=\"./Mathlib/Data/Opposite.html#Opposite\">ᵒᵖ</a></span> <a href=\"./foundational_types.html\">(<a href=\"./foundational_types.html\">Type</a> (max v u))</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{X : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(R : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve\">CategoryTheory.Presieve</a> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> (max v u)</div></div>"}]}