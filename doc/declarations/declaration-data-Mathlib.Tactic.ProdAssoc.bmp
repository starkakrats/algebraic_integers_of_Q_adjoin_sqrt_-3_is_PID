{"name":"Mathlib.Tactic.ProdAssoc","instances":[{"typeNames":["Lean.Expr.ProdTree"],"name":"Lean.Expr.instReprProdTree","className":"Repr"}],"imports":["Init","Mathlib.Lean.Expr.Basic","Mathlib.Logic.Equiv.Defs"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ProdAssoc.lean#L149-L149","name":"Lean.Expr.«termProd_assoc%»","line":149,"kind":"def","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.«termProd_assoc%»","doc":"`prod_assoc%` elaborates to the \"obvious\" equivalence between iterated products of types,\nregardless of how the products are parenthesized.\nThe `prod_assoc%` term uses the expected type when elaborating.\nFor example, `(prod_assoc% : (α × β) × (γ × δ) ≃ α × (β × γ) × δ)`.\n\nThe elaborator can handle holes in the expected type,\nso long as they eventually get filled by unification.\n```lean\nexample : (α × β) × (γ × δ) ≃ α × (β × γ) × δ :=\n  (prod_assoc% : _ ≃ α × β × γ × δ).trans prod_assoc%\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.«termProd_assoc%»\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">«termProd_assoc%»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ProdAssoc.lean#L126-L134","name":"Lean.Expr.elabProdAssoc","line":126,"kind":"def","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.elabProdAssoc","doc":"Elaborator for `prod_assoc%`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.elabProdAssoc\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">elabProdAssoc</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElab\">Lean.Elab.Term.TermElab</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ProdAssoc.lean#L116-L121","name":"Lean.Expr.prodAssocStx","line":116,"kind":"def","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.prodAssocStx","doc":"IMPLEMENTATION: Syntax used in the implementation of `prod_assoc%`.\nThis elaborator postpones if there are metavariables in the expected type,\nand to propagate the fact that this elaborator produces an `Equiv`,\nthe `prod_assoc%` macro sets things up with a type ascription.\nThis enables using `prod_assoc%` with, for example `Equiv.trans` dot notation. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.prodAssocStx\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">prodAssocStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ProdAssoc.lean#L108-L114","name":"Lean.Expr.mkProdEquiv","line":108,"kind":"def","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.mkProdEquiv","doc":"Construct the equivalence between iterated products of the same type, associated\nin possibly different ways. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.mkProdEquiv\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">mkProdEquiv</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(a : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ProdAssoc.lean#L95-L104","name":"Lean.Expr.mkProdFun","line":95,"kind":"def","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.mkProdFun","doc":"Given two expressions corresponding to iterated products of the same types, associated in\npossibly different ways, this constructs the \"obvious\" function from one to the other. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.mkProdFun\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">mkProdFun</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(a : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(b : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ProdAssoc.lean#L90-L91","name":"Lean.Expr.ProdTree.convertTo","line":90,"kind":"def","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree.convertTo","doc":"Converts a term `e` in an iterated product `P1` into a term of an iterated product `P2`.\nHere `e` is an `Expr` representing the term, and the iterated products are represented\nby terms of `ProdTree`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree.convertTo\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">ProdTree</span>.<span class=\"name\">convertTo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(P1 : <a href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree\">Lean.Expr.ProdTree</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(P2 : <a href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree\">Lean.Expr.ProdTree</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ProdAssoc.lean#L72-L85","name":"Lean.Expr.ProdTree.pack","line":72,"kind":"def","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree.pack","doc":"This function should act as the \"reverse\" of `ProdTree.unpack`, constructing\na term of the iterated product out of a list of terms of the types appearing in the product. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree.pack\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">ProdTree</span>.<span class=\"name\">pack</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(ts : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree\">Lean.Expr.ProdTree</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ProdAssoc.lean#L63-L68","name":"Lean.Expr.ProdTree.unpack","line":63,"kind":"def","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree.unpack","doc":"Given `P : ProdTree` representing an iterated product and `e : Expr` which\nshould correspond to a term of the iterated product, this will return\na list, whose items correspond to the leaves of `P` (i.e. the types appearing in the product),\nwhere each item is the appropriate composition of `Prod.fst` and `Prod.snd` applied to `e`\nresulting in an element of the type corresponding to the leaf.\n\nFor example, if `P` corresponds to `(X × Y) × Z` and `t : (X × Y) × Z`, then this\nshould return `[t.fst.fst, t.fst.snd, t.snd]`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree.unpack\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">ProdTree</span>.<span class=\"name\">unpack</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(t : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree\">Lean.Expr.ProdTree</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ProdAssoc.lean#L46-L52","name":"Lean.Expr.mkProdTree","line":46,"kind":"opaque","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.mkProdTree","doc":"Make a `ProdTree` out of an `Expr`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.mkProdTree\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">mkProdTree</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(e : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree\">Lean.Expr.ProdTree</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ProdAssoc.lean#L41-L43","name":"Lean.Expr.ProdTree.components","line":41,"kind":"def","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree.components","doc":"The components of an interated product, presented as a `ProdTree`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree.components\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">ProdTree</span>.<span class=\"name\">components</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree\">Lean.Expr.ProdTree</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ProdAssoc.lean#L36-L38","name":"Lean.Expr.ProdTree.size","line":36,"kind":"def","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree.size","doc":"The number of types appearing in an iterated product encoded as a `ProdTree`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree.size\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">ProdTree</span>.<span class=\"name\">size</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree\">Lean.Expr.ProdTree</a> → <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ProdAssoc.lean#L31-L33","name":"Lean.Expr.ProdTree.getType","line":31,"kind":"def","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree.getType","doc":"The iterated product corresponding to a `ProdTree`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree.getType\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">ProdTree</span>.<span class=\"name\">getType</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree\">Lean.Expr.ProdTree</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ProdAssoc.lean#L28-L28","name":"Lean.Expr.instReprProdTree","line":28,"kind":"instance","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.instReprProdTree","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.instReprProdTree\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">instReprProdTree</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <a href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree\">Lean.Expr.ProdTree</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ProdAssoc.lean#L27-L27","name":"Lean.Expr.ProdTree.prod","line":27,"kind":"ctor","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree.prod","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree.prod\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">ProdTree</span>.<span class=\"name\">prod</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(fst : <a href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree\">Lean.Expr.ProdTree</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(snd : <a href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree\">Lean.Expr.ProdTree</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(lfst : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(lsnd : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree\">Lean.Expr.ProdTree</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ProdAssoc.lean#L26-L26","name":"Lean.Expr.ProdTree.type","line":26,"kind":"ctor","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree.type","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree.type\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">ProdTree</span>.<span class=\"name\">type</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(tp : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(l : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree\">Lean.Expr.ProdTree</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/ProdAssoc.lean#L25-L28","name":"Lean.Expr.ProdTree","line":25,"kind":"inductive","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree","doc":"A helper type to keep track of universe levels and types in iterated produts. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">ProdTree</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"}]}