{"name":"Mathlib.Tactic.TFAE","instances":[],"imports":["Init","Qq","Mathlib.Init.Data.Nat.Notation","Mathlib.Util.AtomM","Mathlib.Data.List.TFAE"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/TFAE.lean#L193-L198","name":"Mathlib.Tactic.TFAE.mkImplType","line":193,"kind":"def","docLink":"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.mkImplType","doc":"Construct an expression for the type `Pj → Pi`, `Pi → Pj`, or `Pi ↔ Pj` given expressions\n`Pi Pj : Q(Prop)` and `impArrow` syntax `arr`, depending on whether `arr` is `←`, `→`, or `↔`\nrespectively. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.mkImplType\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TFAE</span>.<span class=\"name\">mkImplType</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(Pi : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(arr : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Mathlib.Tactic.TFAE.impArrow</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(Pj : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/TFAE.lean#L184-L188","name":"Mathlib.Tactic.TFAE.elabIndex","line":184,"kind":"def","docLink":"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.elabIndex","doc":"Turn syntax for a given index into a natural number, as long as it lies between `1` and\n`maxIndex`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.elabIndex\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TFAE</span>.<span class=\"name\">elabIndex</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`num</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(maxIndex : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/TFAE.lean#L169-L180","name":"Mathlib.Tactic.TFAE.tfaeHaveCore","line":169,"kind":"def","docLink":"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.tfaeHaveCore","doc":"The core of `tfae_have`, which behaves like `haveLetCore` in `Mathlib.Tactic.Have`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.tfaeHaveCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TFAE</span>.<span class=\"name\">tfaeHaveCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(goal : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(name : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`ident</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`num</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`num</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(arrow : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Mathlib.Tactic.TFAE.impArrow</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(t : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/TFAE.lean#L159-L165","name":"Mathlib.Tactic.TFAE.mkTFAEHypName","line":159,"kind":"def","docLink":"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.mkTFAEHypName","doc":"Construct a name for a hypothesis introduced by `tfae_have`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.mkTFAEHypName\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TFAE</span>.<span class=\"name\">mkTFAEHypName</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(i : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`num</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`num</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(arr : <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Mathlib.Tactic.TFAE.impArrow</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/TFAE.lean#L146-L154","name":"Mathlib.Tactic.TFAE.proveTFAE","line":146,"kind":"def","docLink":"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.proveTFAE","doc":"Attempt to prove a statement of the form `TFAE [P₁, P₂, ...]`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.proveTFAE\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TFAE</span>.<span class=\"name\">proveTFAE</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(hyps : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(atoms : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(is : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./foundational_types.html\">Prop</a></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/List/TFAE.html#List.TFAE\">List.TFAE</a> <span class=\"fn\">«$l»</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/TFAE.lean#L137-L143","name":"Mathlib.Tactic.TFAE.proveGetLastDImpl","line":137,"kind":"opaque","docLink":"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.proveGetLastDImpl","doc":"Attempt to prove `getLastD l P' → P` given an explicit list `l`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.proveGetLastDImpl\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TFAE</span>.<span class=\"name\">proveGetLastDImpl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(hyps : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(atoms : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(i : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(i' : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(is : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(P' : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./foundational_types.html\">Prop</a></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Data/List/BasicAux.html#List.getLastD\">List.getLastD</a> <span class=\"fn\">«$l»</span> <span class=\"fn\">«$P'»</span></span> → <span class=\"fn\">«$P»</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/TFAE.lean#L126-L134","name":"Mathlib.Tactic.TFAE.proveChain","line":126,"kind":"opaque","docLink":"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.proveChain","doc":"Generate a proof of `Chain (· → ·) P l`. We assume `P : Prop` and `l : List Prop`, and that `l`\nis an explicit list. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.proveChain\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TFAE</span>.<span class=\"name\">proveChain</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(hyps : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(atoms : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(i : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(is : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./foundational_types.html\">Prop</a></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Std/Data/List/Basic.html#List.Chain\">List.Chain</a> <span class=\"fn\">(<span class=\"fn\">fun (<span class=\"fn\">x</span> x_1 : <a href=\"./foundational_types.html\">Prop</a>) =&gt; <span class=\"fn\"><span class=\"fn\">x</span> → <span class=\"fn\">x_1</span></span></span>)</span> <span class=\"fn\">«$P»</span> <span class=\"fn\">«$l»</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/TFAE.lean#L117-L122","name":"Mathlib.Tactic.TFAE.proveImpl","line":117,"kind":"def","docLink":"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.proveImpl","doc":"Prove an implication via depth-first traversal. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.proveImpl\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TFAE</span>.<span class=\"name\">proveImpl</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(hyps : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(atoms : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(i : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(P' : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$P»</span> → <span class=\"fn\">«$P'»</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/TFAE.lean#L104-L114","name":"Mathlib.Tactic.TFAE.dfs","line":104,"kind":"opaque","docLink":"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.dfs","doc":"Uses depth-first search to find a path from `P` to `P'`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.dfs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TFAE</span>.<span class=\"name\">dfs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(hyps : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(atoms : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(i : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(j : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(P : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(P' : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(hP : <span class=\"fn\">Q(<span class=\"fn\">«$P»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Control/State.html#StateT\">StateT</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Lean/Data/HashSet.html#Lean.HashSet\">Lean.HashSet</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span> <a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">Q(<span class=\"fn\">«$P'»</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/TFAE.lean#L93-L97","name":"Mathlib.Tactic.TFAE.getTFAEList.getExplicitList","line":93,"kind":"opaque","docLink":"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.getTFAEList.getExplicitList","doc":"Convert an expression representing an explicit list into a list of expressions. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.getTFAEList.getExplicitList\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TFAE</span>.<span class=\"name\">getTFAEList</span>.<span class=\"name\">getExplicitList</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(l : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./foundational_types.html\">Prop</a></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/TFAE.lean#L85-L97","name":"Mathlib.Tactic.TFAE.getTFAEList","line":85,"kind":"def","docLink":"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.getTFAEList","doc":"Extract a list of `Prop` expressions from an expression of the form `TFAE [P₁, P₂, ...]` as\nlong as `[P₁, P₂, ...]` is an explicit list. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.getTFAEList\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TFAE</span>.<span class=\"name\">getTFAEList</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(t : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./foundational_types.html\">Prop</a></span>)</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span></span></span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/TFAE.lean#L61-L79","name":"Mathlib.Tactic.TFAE.tfaeFinish","line":61,"kind":"def","docLink":"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.tfaeFinish","doc":"`tfae_finish` is used to close goals of the form `TFAE [P₁, P₂, ...]` once a sufficient collection\nof hypotheses of the form `Pᵢ → Pⱼ` or `Pᵢ ↔ Pⱼ` have been introduced to the local context.\n\n`tfae_have` can be used to conveniently introduce these hypotheses; see `tfae_have`.\n\nExample:\n```lean\nexample : TFAE [P, Q, R] := by\n  tfae_have 1 → 2\n  · /- proof of P → Q -/\n  tfae_have 2 → 1\n  · /- proof of Q → P -/\n  tfae_have 2 ↔ 3\n  · /- proof of Q ↔ R -/\n  tfae_finish\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.tfaeFinish\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TFAE</span>.<span class=\"name\">tfaeFinish</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/TFAE.lean#L25-L59","name":"Mathlib.Tactic.TFAE.tfaeHave","line":25,"kind":"def","docLink":"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.tfaeHave","doc":"`tfae_have` introduces hypotheses for proving goals of the form `TFAE [P₁, P₂, ...]`. Specifically,\n`tfae_have i arrow j` introduces a hypothesis of type `Pᵢ arrow Pⱼ` to the local context,\nwhere `arrow` can be `→`, `←`, or `↔`. Note that `i` and `j` are natural number indices (beginning\nat 1) used to specify the propositions `P₁, P₂, ...` that appear in the `TFAE` goal list. A proof\nis required afterward, typically via a tactic block.\n\n```lean\nexample (h : P → R) : TFAE [P, Q, R] := by\n  tfae_have 1 → 3\n  · exact h\n  ...\n```\nThe resulting context now includes `tfae_1_to_3 : P → R`.\n\nThe introduced hypothesis can be given a custom name, in analogy to `have` syntax:\n```lean\ntfae_have h : 2 ↔ 3\n```\n\nOnce sufficient hypotheses have been introduced by `tfae_have`, `tfae_finish` can be used to close\nthe goal.\n\n```lean\nexample : TFAE [P, Q, R] := by\n  tfae_have 1 → 2\n  · /- proof of P → Q -/\n  tfae_have 2 → 1\n  · /- proof of Q → P -/\n  tfae_have 2 ↔ 3\n  · /- proof of Q ↔ R -/\n  tfae_finish\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.tfaeHave\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TFAE</span>.<span class=\"name\">tfaeHave</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Tactic/TFAE.lean#L22-L23","name":"Mathlib.Tactic.TFAE.impArrow","line":22,"kind":"def","docLink":"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.impArrow","doc":"An arrow of the form `←`, `→`, or `↔`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/TFAE.html#Mathlib.Tactic.TFAE.impArrow\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">TFAE</span>.<span class=\"name\">impArrow</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>"}]}