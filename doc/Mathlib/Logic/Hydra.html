<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="stylesheet" href="../.././src/pygments.css"></link><link rel="shortcut icon" href="../.././favicon.ico"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Logic.Hydra</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.Logic.Hydra";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Logic</span>.<span class="name">Hydra</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;
            <button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Logic/Hydra.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/Order/GameAdd.html">Mathlib.Order.GameAdd</a></li><li><a href="../.././Mathlib/Data/Finsupp/Lex.html">Mathlib.Data.Finsupp.Lex</a></li><li><a href="../.././Mathlib/Data/Finsupp/Multiset.html">Mathlib.Data.Finsupp.Multiset</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Logic.Hydra" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Relation.CutExpand"><span class="name">Relation</span>.<span class="name">CutExpand</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.cutExpand_le_invImage_lex"><span class="name">Relation</span>.<span class="name">cutExpand_le_invImage_lex</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.cutExpand_singleton"><span class="name">Relation</span>.<span class="name">cutExpand_singleton</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.cutExpand_singleton_singleton"><span class="name">Relation</span>.<span class="name">cutExpand_singleton_singleton</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.cutExpand_add_left"><span class="name">Relation</span>.<span class="name">cutExpand_add_left</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.cutExpand_iff"><span class="name">Relation</span>.<span class="name">cutExpand_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.not_cutExpand_zero"><span class="name">Relation</span>.<span class="name">not_cutExpand_zero</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.cutExpand_fibration"><span class="name">Relation</span>.<span class="name">cutExpand_fibration</span></a></div><div class="nav_link"><a class="break_within" href="#Relation.acc_of_singleton"><span class="name">Relation</span>.<span class="name">acc_of_singleton</span></a></div><div class="nav_link"><a class="break_within" href="#Acc.cutExpand"><span class="name">Acc</span>.<span class="name">cutExpand</span></a></div><div class="nav_link"><a class="break_within" href="#WellFounded.cutExpand"><span class="name">WellFounded</span>.<span class="name">cutExpand</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Termination-of-a-hydra-game">Termination of a hydra game <a class="hover-link" href="#Termination-of-a-hydra-game">#</a></h1><p>This file deals with the following version of the hydra game: each head of the hydra is
labelled by an element in a type <code>α</code>, and when you cut off one head with label <code>a</code>, it
grows back an arbitrary but finite number of heads, all labelled by elements smaller than
<code>a</code> with respect to a well-founded relation <code>r</code> on <code>α</code>. We show that no matter how (in
what order) you choose cut off the heads, the game always terminates, i.e. all heads will
eventually be cut off (but of course it can last arbitrarily long, i.e. takes an
arbitrary finite number of steps).</p><p>This result is stated as the well-foundedness of the <code><a href="../.././Mathlib/Logic/Hydra.html#Relation.CutExpand">CutExpand</a></code> relation defined in
this file: we model the heads of the hydra as a multiset of elements of <code>α</code>, and the
valid "moves" of the game are modelled by the relation <code><a href="../.././Mathlib/Logic/Hydra.html#Relation.CutExpand">CutExpand</a> r</code> on <code><a href="../.././Mathlib/Data/Multiset/Basic.html#Multiset">Multiset</a> α</code>:
<code><a href="../.././Mathlib/Logic/Hydra.html#Relation.CutExpand">CutExpand</a> r s' s</code> is true iff <code>s'</code> is obtained by removing one head <code>a ∈ s</code> and
adding back an arbitrary multiset <code>t</code> of heads such that all <code>a' ∈ t</code> satisfy <code>r a' a</code>.</p><p>We follow the proof by Peter LeFanu Lumsdaine at https://mathoverflow.net/a/229084/3332.</p><p>TODO: formalize the relations corresponding to more powerful (e.g. Kirby–Paris and Buchholz)
hydras, and prove their well-foundedness.</p></div><div class="decl" id="Relation.CutExpand"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Logic/Hydra.lean#L56-L57">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Hydra.html#Relation.CutExpand"><span class="name">Relation</span>.<span class="name">CutExpand</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(s' : <span class="fn"><a href="../.././Mathlib/Data/Multiset/Basic.html#Multiset">Multiset</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Data/Multiset/Basic.html#Multiset">Multiset</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Prop</a></div></div><p>The relation that specifies valid moves in our hydra game. <code><a href="../.././Mathlib/Logic/Hydra.html#Relation.CutExpand">CutExpand</a> r s' s</code>
means that <code>s'</code> is obtained by removing one head <code>a ∈ s</code> and adding back an arbitrary
multiset <code>t</code> of heads such that all <code>a' ∈ t</code> satisfy <code>r a' a</code>.</p><p>This is most directly translated into <code>s' = s.erase a + t</code>, but <code><a href="../.././Mathlib/Data/Multiset/Basic.html#Multiset.erase">Multiset.erase</a></code> requires
<code><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> α</code>, so we use the equivalent condition <code>s' + {a} = s + t</code> instead, which
is also easier to verify for explicit multisets <code>s'</code>, <code>s</code> and <code>t</code>.</p><p>We also don't include the condition <code>a ∈ s</code> because <code>s' + {a} = s + t</code> already
guarantees <code>a ∈ s + t</code>, and if <code>r</code> is irreflexive then <code>a ∉ t</code>, which is the
case when <code>r</code> is well-founded, the case we are primarily interested in.</p><p>The lemma <code><a href="../.././Mathlib/Logic/Hydra.html#Relation.cutExpand_iff">Relation.cutExpand_iff</a></code> below converts between this convenient definition
and the direct translation when <code>r</code> is irreflexive.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Hydra.html#Relation.CutExpand">Relation.CutExpand</a> <span class="fn">r</span> <span class="fn">s'</span> <span class="fn">s</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">∃ (t : <span class="fn"><a href="../.././Mathlib/Data/Multiset/Basic.html#Multiset">Multiset</a> <span class="fn">α</span></span>) (a : <span class="fn">α</span>), <span class="fn"><span class="fn">(<span class="fn">∀ <span class="fn">a'</span> ∈ <span class="fn">t</span>, <span class="fn"><span class="fn">r</span> <span class="fn">a'</span> <span class="fn">a</span></span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn">s'</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">{<span class="fn">a</span>}</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">s</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">t</span></span></span></span></span></span></li></ul></details><details id="instances-for-list-Relation.CutExpand" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Relation.cutExpand_le_invImage_lex"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Logic/Hydra.lean#L62-L74">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Hydra.html#Relation.cutExpand_le_invImage_lex"><span class="name">Relation</span>.<span class="name">cutExpand_le_invImage_lex</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Init/Algebra/Classes.html#IsIrrefl">IsIrrefl</a> <span class="fn">α</span> <span class="fn">r</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Hydra.html#Relation.CutExpand">Relation.CutExpand</a> <span class="fn">r</span></span> <a href="../.././Init/Prelude.html#LE.le">≤</a>   <span class="fn"><a href="../.././Init/Core.html#InvImage">InvImage</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Data/Finsupp/Lex.html#Finsupp.Lex">Finsupp.Lex</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">r</span><a href="../.././Mathlib/Order/Notation.html#HasCompl.compl">ᶜ</a></span> <a href="../.././Mathlib/Order/Notation.html#Inf.inf">⊓</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#Ne">≠</a> <span class="fn">x_1</span></span></span></span>)</span> <span class="fn">fun (<span class="fn">x</span> x_1 : <a href="../.././Init/Prelude.html#Nat">ℕ</a>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn">x_1</span></span></span></span>)</span> <span class="fn">⇑<span class="fn">Multiset.toFinsupp</span></span></span></span></div></div></div></div><div class="decl" id="Relation.cutExpand_singleton"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Logic/Hydra.lean#L77-L78">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Hydra.html#Relation.cutExpand_singleton"><span class="name">Relation</span>.<span class="name">cutExpand_singleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Data/Multiset/Basic.html#Multiset">Multiset</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn">∀ <span class="fn">x'</span> ∈ <span class="fn">s</span>, <span class="fn"><span class="fn">r</span> <span class="fn">x'</span> <span class="fn">x</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Hydra.html#Relation.CutExpand">Relation.CutExpand</a> <span class="fn">r</span> <span class="fn">s</span> <span class="fn">{<span class="fn">x</span>}</span></span></div></div></div></div><div class="decl" id="Relation.cutExpand_singleton_singleton"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Logic/Hydra.lean#L81-L82">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Hydra.html#Relation.cutExpand_singleton_singleton"><span class="name">Relation</span>.<span class="name">cutExpand_singleton_singleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x' : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">r</span> <span class="fn">x'</span> <span class="fn">x</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Hydra.html#Relation.CutExpand">Relation.CutExpand</a> <span class="fn">r</span> <span class="fn">{<span class="fn">x'</span>}</span> <span class="fn">{<span class="fn">x</span>}</span></span></div></div></div></div><div class="decl" id="Relation.cutExpand_add_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Logic/Hydra.lean#L85-L86">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Hydra.html#Relation.cutExpand_add_left"><span class="name">Relation</span>.<span class="name">cutExpand_add_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{t : <span class="fn"><a href="../.././Mathlib/Data/Multiset/Basic.html#Multiset">Multiset</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <span class="fn"><a href="../.././Mathlib/Data/Multiset/Basic.html#Multiset">Multiset</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Data/Multiset/Basic.html#Multiset">Multiset</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Hydra.html#Relation.CutExpand">Relation.CutExpand</a> <span class="fn">r</span> <span class="fn">(<span class="fn"><span class="fn">s</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">t</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">s</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">u</span></span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../.././Mathlib/Logic/Hydra.html#Relation.CutExpand">Relation.CutExpand</a> <span class="fn">r</span> <span class="fn">t</span> <span class="fn">u</span></span></span></div></div></div></div><div class="decl" id="Relation.cutExpand_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Logic/Hydra.lean#L89-L98">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Hydra.html#Relation.cutExpand_iff"><span class="name">Relation</span>.<span class="name">cutExpand_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Init/Algebra/Classes.html#IsIrrefl">IsIrrefl</a> <span class="fn">α</span> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s' : <span class="fn"><a href="../.././Mathlib/Data/Multiset/Basic.html#Multiset">Multiset</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Data/Multiset/Basic.html#Multiset">Multiset</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/Logic/Hydra.html#Relation.CutExpand">Relation.CutExpand</a> <span class="fn">r</span> <span class="fn">s'</span> <span class="fn">s</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (t : <span class="fn"><a href="../.././Mathlib/Data/Multiset/Basic.html#Multiset">Multiset</a> <span class="fn">α</span></span>) (a : <span class="fn">α</span>), <span class="fn"><span class="fn">(<span class="fn">∀ <span class="fn">a'</span> ∈ <span class="fn">t</span>, <span class="fn"><span class="fn">r</span> <span class="fn">a'</span> <span class="fn">a</span></span></span>)</span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">s'</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Multiset/Basic.html#Multiset.erase">Multiset.erase</a> <span class="fn">s</span> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">t</span></span></span></span></span></span></span></div></div></div></div><div class="decl" id="Relation.not_cutExpand_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Logic/Hydra.lean#L101-L104">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Hydra.html#Relation.not_cutExpand_zero"><span class="name">Relation</span>.<span class="name">not_cutExpand_zero</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Init/Algebra/Classes.html#IsIrrefl">IsIrrefl</a> <span class="fn">α</span> <span class="fn">r</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Mathlib/Data/Multiset/Basic.html#Multiset">Multiset</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Not">¬</a><span class="fn"><a href="../.././Mathlib/Logic/Hydra.html#Relation.CutExpand">Relation.CutExpand</a> <span class="fn">r</span> <span class="fn">s</span> <span class="fn">0</span></span></span></div></div></div></div><div class="decl" id="Relation.cutExpand_fibration"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Logic/Hydra.lean#L109-L121">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Hydra.html#Relation.cutExpand_fibration"><span class="name">Relation</span>.<span class="name">cutExpand_fibration</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Logic/Relation.html#Relation.Fibration">Relation.Fibration</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Order/GameAdd.html#Prod.GameAdd">Prod.GameAdd</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Logic/Hydra.html#Relation.CutExpand">Relation.CutExpand</a> <span class="fn">r</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Logic/Hydra.html#Relation.CutExpand">Relation.CutExpand</a> <span class="fn">r</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Logic/Hydra.html#Relation.CutExpand">Relation.CutExpand</a> <span class="fn">r</span></span>)</span>
  <span class="fn">fun (<span class="fn">s</span> : <span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Multiset/Basic.html#Multiset">Multiset</a> <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../.././Mathlib/Data/Multiset/Basic.html#Multiset">Multiset</a> <span class="fn">α</span></span></span>) =&gt; <span class="fn"><span class="fn"><span class="fn">s</span>.1</span> <a href="../.././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">s</span>.2</span></span></span></span></div></div><p>For any relation <code>r</code> on <code>α</code>, multiset addition <code><a href="../.././Mathlib/Data/Multiset/Basic.html#Multiset">Multiset</a> α × <a href="../.././Mathlib/Data/Multiset/Basic.html#Multiset">Multiset</a> α → <a href="../.././Mathlib/Data/Multiset/Basic.html#Multiset">Multiset</a> α</code> is a
fibration between the game sum of <code><a href="../.././Mathlib/Logic/Hydra.html#Relation.CutExpand">CutExpand</a> r</code> with itself and <code><a href="../.././Mathlib/Logic/Hydra.html#Relation.CutExpand">CutExpand</a> r</code> itself.</p></div></div><div class="decl" id="Relation.acc_of_singleton"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Logic/Hydra.lean#L126-L133">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Hydra.html#Relation.acc_of_singleton"><span class="name">Relation</span>.<span class="name">acc_of_singleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Init/Algebra/Classes.html#IsIrrefl">IsIrrefl</a> <span class="fn">α</span> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../.././Mathlib/Data/Multiset/Basic.html#Multiset">Multiset</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hs : <span class="fn">∀ <span class="fn">a</span> ∈ <span class="fn">s</span>, <span class="fn"><a href="../.././Init/WF.html#Acc">Acc</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Logic/Hydra.html#Relation.CutExpand">Relation.CutExpand</a> <span class="fn">r</span></span>)</span> <span class="fn">{<span class="fn">a</span>}</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/WF.html#Acc">Acc</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Logic/Hydra.html#Relation.CutExpand">Relation.CutExpand</a> <span class="fn">r</span></span>)</span> <span class="fn">s</span></span></div></div><p>A multiset is accessible under <code><a href="../.././Mathlib/Logic/Hydra.html#Relation.CutExpand">CutExpand</a></code> if all its singleton subsets are,
assuming <code>r</code> is irreflexive.</p></div></div><div class="decl" id="Acc.cutExpand"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Logic/Hydra.lean#L138-L146">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Hydra.html#Acc.cutExpand"><span class="name">Acc</span>.<span class="name">cutExpand</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Init/Algebra/Classes.html#IsIrrefl">IsIrrefl</a> <span class="fn">α</span> <span class="fn">r</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hacc : <span class="fn"><a href="../.././Init/WF.html#Acc">Acc</a> <span class="fn">r</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/WF.html#Acc">Acc</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Logic/Hydra.html#Relation.CutExpand">Relation.CutExpand</a> <span class="fn">r</span></span>)</span> <span class="fn">{<span class="fn">a</span>}</span></span></div></div><p>A singleton <code>{a}</code> is accessible under <code><a href="../.././Mathlib/Logic/Hydra.html#Relation.CutExpand">CutExpand</a> r</code> if <code>a</code> is accessible under <code>r</code>,
assuming <code>r</code> is irreflexive.</p></div></div><div class="decl" id="WellFounded.cutExpand"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Logic/Hydra.lean#L150-L151">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/Logic/Hydra.html#WellFounded.cutExpand"><span class="name">WellFounded</span>.<span class="name">cutExpand</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href="../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr : <span class="fn"><a href="../.././Init/WF.html#WellFounded">WellFounded</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/WF.html#WellFounded">WellFounded</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Logic/Hydra.html#Relation.CutExpand">Relation.CutExpand</a> <span class="fn">r</span></span>)</span></span></div></div><p><code><a href="../.././Mathlib/Logic/Hydra.html#Relation.CutExpand">CutExpand</a> r</code> is well-founded when <code>r</code> is.</p></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>