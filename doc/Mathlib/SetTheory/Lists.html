<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="stylesheet" href="../.././src/pygments.css"></link><link rel="shortcut icon" href="../.././favicon.ico"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.SetTheory.Lists</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.SetTheory.Lists";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">SetTheory</span>.<span class="name">Lists</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;
            <button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/Data/Sigma/Basic.html">Mathlib.Data.Sigma.Basic</a></li><li><a href="../.././Mathlib/Data/Nat/Order/Basic.html">Mathlib.Data.Nat.Order.Basic</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.SetTheory.Lists" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lists'"><span class="name">Lists'</span></a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqLists'"><span class="name">instDecidableEqLists'</span></a></div><div class="nav_link"><a class="break_within" href="#Lists"><span class="name">Lists</span></a></div><div class="nav_link"><a class="break_within" href="#Lists'.instForAllBoolInhabitedLists'"><span class="name">Lists'</span>.<span class="name">instForAllBoolInhabitedLists'</span></a></div><div class="nav_link"><a class="break_within" href="#Lists'.cons"><span class="name">Lists'</span>.<span class="name">cons</span></a></div><div class="nav_link"><a class="break_within" href="#Lists'.toList"><span class="name">Lists'</span>.<span class="name">toList</span></a></div><div class="nav_link"><a class="break_within" href="#Lists'.toList_cons"><span class="name">Lists'</span>.<span class="name">toList_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Lists'.ofList"><span class="name">Lists'</span>.<span class="name">ofList</span></a></div><div class="nav_link"><a class="break_within" href="#Lists'.to_ofList"><span class="name">Lists'</span>.<span class="name">to_ofList</span></a></div><div class="nav_link"><a class="break_within" href="#Lists'.of_toList"><span class="name">Lists'</span>.<span class="name">of_toList</span></a></div><div class="nav_link"><a class="break_within" href="#Lists.Equiv"><span class="name">Lists</span>.<span class="name">Equiv</span></a></div><div class="nav_link"><a class="break_within" href="#Lists'.Subset"><span class="name">Lists'</span>.<span class="name">Subset</span></a></div><div class="nav_link"><a class="break_within" href="#Lists'.instHasSubsetLists'True"><span class="name">Lists'</span>.<span class="name">instHasSubsetLists'True</span></a></div><div class="nav_link"><a class="break_within" href="#Lists'.instMembershipListsLists'"><span class="name">Lists'</span>.<span class="name">instMembershipListsLists'</span></a></div><div class="nav_link"><a class="break_within" href="#Lists'.mem_def"><span class="name">Lists'</span>.<span class="name">mem_def</span></a></div><div class="nav_link"><a class="break_within" href="#Lists'.mem_cons"><span class="name">Lists'</span>.<span class="name">mem_cons</span></a></div><div class="nav_link"><a class="break_within" href="#Lists'.cons_subset"><span class="name">Lists'</span>.<span class="name">cons_subset</span></a></div><div class="nav_link"><a class="break_within" href="#Lists'.ofList_subset"><span class="name">Lists'</span>.<span class="name">ofList_subset</span></a></div><div class="nav_link"><a class="break_within" href="#Lists'.Subset.refl"><span class="name">Lists'</span>.<span class="name">Subset</span>.<span class="name">refl</span></a></div><div class="nav_link"><a class="break_within" href="#Lists'.subset_nil"><span class="name">Lists'</span>.<span class="name">subset_nil</span></a></div><div class="nav_link"><a class="break_within" href="#Lists'.mem_of_subset'"><span class="name">Lists'</span>.<span class="name">mem_of_subset'</span></a></div><div class="nav_link"><a class="break_within" href="#Lists'.subset_def"><span class="name">Lists'</span>.<span class="name">subset_def</span></a></div><div class="nav_link"><a class="break_within" href="#Lists.atom"><span class="name">Lists</span>.<span class="name">atom</span></a></div><div class="nav_link"><a class="break_within" href="#Lists.of'"><span class="name">Lists</span>.<span class="name">of'</span></a></div><div class="nav_link"><a class="break_within" href="#Lists.toList"><span class="name">Lists</span>.<span class="name">toList</span></a></div><div class="nav_link"><a class="break_within" href="#Lists.IsList"><span class="name">Lists</span>.<span class="name">IsList</span></a></div><div class="nav_link"><a class="break_within" href="#Lists.ofList"><span class="name">Lists</span>.<span class="name">ofList</span></a></div><div class="nav_link"><a class="break_within" href="#Lists.isList_toList"><span class="name">Lists</span>.<span class="name">isList_toList</span></a></div><div class="nav_link"><a class="break_within" href="#Lists.to_ofList"><span class="name">Lists</span>.<span class="name">to_ofList</span></a></div><div class="nav_link"><a class="break_within" href="#Lists.of_toList"><span class="name">Lists</span>.<span class="name">of_toList</span></a></div><div class="nav_link"><a class="break_within" href="#Lists.instInhabitedLists"><span class="name">Lists</span>.<span class="name">instInhabitedLists</span></a></div><div class="nav_link"><a class="break_within" href="#Lists.instDecidableEqLists"><span class="name">Lists</span>.<span class="name">instDecidableEqLists</span></a></div><div class="nav_link"><a class="break_within" href="#Lists.instSizeOfLists"><span class="name">Lists</span>.<span class="name">instSizeOfLists</span></a></div><div class="nav_link"><a class="break_within" href="#Lists.inductionMut"><span class="name">Lists</span>.<span class="name">inductionMut</span></a></div><div class="nav_link"><a class="break_within" href="#Lists.mem"><span class="name">Lists</span>.<span class="name">mem</span></a></div><div class="nav_link"><a class="break_within" href="#Lists.instMembershipLists"><span class="name">Lists</span>.<span class="name">instMembershipLists</span></a></div><div class="nav_link"><a class="break_within" href="#Lists.isList_of_mem"><span class="name">Lists</span>.<span class="name">isList_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#Lists.Equiv.antisymm_iff"><span class="name">Lists</span>.<span class="name">Equiv</span>.<span class="name">antisymm_iff</span></a></div><div class="nav_link"><a class="break_within" href="#Lists.equiv_atom"><span class="name">Lists</span>.<span class="name">equiv_atom</span></a></div><div class="nav_link"><a class="break_within" href="#Lists.Equiv.symm"><span class="name">Lists</span>.<span class="name">Equiv</span>.<span class="name">symm</span></a></div><div class="nav_link"><a class="break_within" href="#Lists.Equiv.trans"><span class="name">Lists</span>.<span class="name">Equiv</span>.<span class="name">trans</span></a></div><div class="nav_link"><a class="break_within" href="#Lists.instSetoidLists"><span class="name">Lists</span>.<span class="name">instSetoidLists</span></a></div><div class="nav_link"><a class="break_within" href="#Lists.Equiv.decidableMeas"><span class="name">Lists</span>.<span class="name">Equiv</span>.<span class="name">decidableMeas</span></a></div><div class="nav_link"><a class="break_within" href="#Lists.sizeof_pos"><span class="name">Lists</span>.<span class="name">sizeof_pos</span></a></div><div class="nav_link"><a class="break_within" href="#Lists.lt_sizeof_cons'"><span class="name">Lists</span>.<span class="name">lt_sizeof_cons'</span></a></div><div class="nav_link"><a class="break_within" href="#Lists.Equiv.decidable"><span class="name">Lists</span>.<span class="name">Equiv</span>.<span class="name">decidable</span></a></div><div class="nav_link"><a class="break_within" href="#Lists.Subset.decidable"><span class="name">Lists</span>.<span class="name">Subset</span>.<span class="name">decidable</span></a></div><div class="nav_link"><a class="break_within" href="#Lists.mem.decidable"><span class="name">Lists</span>.<span class="name">mem</span>.<span class="name">decidable</span></a></div><div class="nav_link"><a class="break_within" href="#Lists'.mem_equiv_left"><span class="name">Lists'</span>.<span class="name">mem_equiv_left</span></a></div><div class="nav_link"><a class="break_within" href="#Lists'.mem_of_subset"><span class="name">Lists'</span>.<span class="name">mem_of_subset</span></a></div><div class="nav_link"><a class="break_within" href="#Lists'.Subset.trans"><span class="name">Lists'</span>.<span class="name">Subset</span>.<span class="name">trans</span></a></div><div class="nav_link"><a class="break_within" href="#Finsets"><span class="name">Finsets</span></a></div><div class="nav_link"><a class="break_within" href="#Finsets.instEmptyCollectionFinsets"><span class="name">Finsets</span>.<span class="name">instEmptyCollectionFinsets</span></a></div><div class="nav_link"><a class="break_within" href="#Finsets.instInhabitedFinsets"><span class="name">Finsets</span>.<span class="name">instInhabitedFinsets</span></a></div><div class="nav_link"><a class="break_within" href="#Finsets.instDecidableEqFinsets"><span class="name">Finsets</span>.<span class="name">instDecidableEqFinsets</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="A-computable-model-of-ZFA-without-infinity">A computable model of ZFA without infinity <a class="hover-link" href="#A-computable-model-of-ZFA-without-infinity">#</a></h1><p>In this file we define finite hereditary lists. This is useful for calculations in naive set theory.</p><p>We distinguish two kinds of ZFA lists:</p><ul>
<li>Atoms. Directly correspond to an element of the original type.</li>
<li>Proper ZFA lists. Can be thought of (but aren't implemented) as a list of ZFA lists (not
necessarily proper).</li>
</ul><p>For example, <code><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> ℕ</code> contains stuff like <code>23</code>, <code>[]</code>, <code>[37]</code>, <code>[1, [[2], 3], 4]</code>.</p><h2 class="markdown-heading" id="Implementation-note">Implementation note <a class="hover-link" href="#Implementation-note">#</a></h2><p>As we want to be able to append both atoms and proper ZFA lists to proper ZFA lists, it's handy that
atoms and proper ZFA lists belong to the same type, even though atoms of <code>α</code> could be modelled as
<code>α</code> directly. But we don't want to be able to append anything to atoms.</p><p>This calls for a two-steps definition of ZFA lists:</p><ul>
<li>First, define ZFA prelists as atoms and proper ZFA prelists. Those proper ZFA prelists are defined
by inductive appending of (not necessarily proper) ZFA lists.</li>
<li>Second, define ZFA lists by rubbing out the distinction between atoms and proper lists.</li>
</ul><h2 class="markdown-heading" id="Main-declarations">Main declarations <a class="hover-link" href="#Main-declarations">#</a></h2><ul>
<li><code><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> α false</code>: Atoms as ZFA prelists. Basically a copy of <code>α</code>.</li>
<li><code><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> α true</code>: Proper ZFA prelists. Defined inductively from the empty ZFA prelist
(<code><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.nil">Lists'.nil</a></code>) and from appending a ZFA prelist to a proper ZFA prelist (<code><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.cons">Lists'.cons</a> a l</code>).</li>
<li><code><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> α</code>: ZFA lists. Sum of the atoms and proper ZFA prelists.</li>
<li><code><a href="../.././Mathlib/SetTheory/Lists.html#Finsets">Finsets</a> α</code>: ZFA sets. Defined as <code><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a></code> quotiented by <code><a href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv">Lists.Equiv</a></code>, the extensional
equivalence.</li>
</ul></div><div class="decl" id="Lists'"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L52-L56">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists'"><span class="name">Lists'</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../.././foundational_types.html">Type</a> u)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Bool">Bool</a> → <a href="../.././foundational_types.html">Type</a> u</span></div></div><p>Prelists, helper type to define <code><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a></code>. <code><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> α false</code> are the "atoms", a copy of <code>α</code>.
<code><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> α true</code> are the "proper" ZFA prelists, inductively defined from the empty ZFA prelist and
from appending a ZFA prelist to a proper ZFA prelist. It is made so that you can't append anything
to an atom while having only one appending function for appending both atoms and proper ZFC prelists
to a proper ZFA prelist.</p><ul class="constructors"><li class="constructor" id="Lists'.atom">atom: <span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u} → <span class="fn"><span class="fn">α</span> → <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.false">false</a></span></span></span></li><li class="constructor" id="Lists'.nil">nil: <span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u} → <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span></span></li><li class="constructor" id="Lists'.cons'">cons': <span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u} → <span class="fn">{<span class="fn">b</span> : <a href="../.././Init/Prelude.html#Bool">Bool</a>} → <span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span> → <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span></span></span></span></span></li></ul><details id="instances-for-list-Lists'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instDecidableEqLists'"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L56-L56">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#instDecidableEqLists'"><span class="name">instDecidableEqLists'</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">{<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_2} → <span class="fn">{<span class="fn">a</span> : <a href="../.././Init/Prelude.html#Bool">Bool</a>} → <span class="fn">[<span class="fn">inst</span> : <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>] → <span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <span class="fn">a</span></span>)</span></span></span></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instDecidableEqLists'</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">decEqLists'✝</span></span></li></ul></details></div></div><div class="decl" id="Lists"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L63-L64">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists"><span class="name">Lists</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> u_2</div></div><p>Hereditarily finite list, aka ZFA list. A ZFA list is either an "atom" (<code>b = false</code>),
corresponding to an element of <code>α</code>, or a "proper" ZFA list, inductively defined from the empty ZFA
list and from appending a ZFA list to a proper ZFA list.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn">(b : <a href="../.././Init/Prelude.html#Bool">Bool</a>) × <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <span class="fn">b</span></span></span>)</span></span></li></ul></details><details id="instances-for-list-Lists" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lists'.instForAllBoolInhabitedLists'"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L69-L71">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists'.instForAllBoolInhabitedLists'"><span class="name">Lists'</span>.<span class="name">instForAllBoolInhabitedLists'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(b : <a href="../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <span class="fn">b</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.instForAllBoolInhabitedLists'">Lists'.instForAllBoolInhabitedLists'</a> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">x</span> with
  | <a href="../.././Init/Prelude.html#Bool.false">true</a> =&gt; <span class="fn">{ <span class="fn">default</span> := <span class="fn">Lists'.nil</span> }</span>
  | <a href="../.././Init/Prelude.html#Bool.false">false</a> =&gt; <a href="../.././Init/Prelude.html#Bool.false">{ <span class="fn">default</span> := <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.atom">Lists'.atom</a> <span class="fn">default</span></span> }</a></span></span></li></ul></details></div></div><div class="decl" id="Lists'.cons"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L74-L75">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists'.cons"><span class="name">Lists'</span>.<span class="name">cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span> → <span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span> → <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span></span></span></div></div><p>Appending a ZFA list to a proper ZFA prelist.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.cons">Lists'.cons</a> <span class="fn">x✝</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">x✝</span>, <span class="fn">x</span> with
  | <span class="fn">{ <span class="fn">fst</span> := <span class="fn">fst</span>, <span class="fn">snd</span> := <span class="fn">a</span> }</span>, <span class="fn">l</span> =&gt; <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.cons'">Lists'.cons'</a> <span class="fn">a</span> <span class="fn">l</span></span></span></span></li></ul></details><details id="instances-for-list-Lists'.cons" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lists'.toList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L80-L83">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists'.toList"><span class="name">Lists'</span>.<span class="name">toList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././Init/Prelude.html#Bool">Bool</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <span class="fn">b</span></span> → <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>)</span></span></span></div></div><p>Converts a ZFA prelist to a <code><a href="../.././Init/Prelude.html#List">List</a></code> of ZFA lists. Atoms are sent to <code>[]</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.toList">Lists'.toList</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.atom">Lists'.atom</a> <span class="fn">a</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">[]</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.toList">Lists'.toList</a> <span class="fn">Lists'.nil</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">[]</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.toList">Lists'.toList</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.cons'">Lists'.cons'</a> <span class="fn">a</span> <span class="fn">l</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">{ <span class="fn">fst</span> := <span class="fn">b</span>, <span class="fn">snd</span> := <span class="fn">a</span> }</span> <a href="../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.toList">Lists'.toList</a> <span class="fn">l</span></span></span></span></li></ul></details><details id="instances-for-list-Lists'.toList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lists'.toList_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L88-L88">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists'.toList_cons"><span class="name">Lists'</span>.<span class="name">toList_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(l : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.toList">Lists'.toList</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.cons">Lists'.cons</a> <span class="fn">a</span> <span class="fn">l</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.toList">Lists'.toList</a> <span class="fn">l</span></span></span></span></div></div></div></div><div class="decl" id="Lists'.ofList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L93-L95">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists'.ofList"><span class="name">Lists'</span>.<span class="name">ofList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>)</span></span> → <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span></span></div></div><p>Converts a <code><a href="../.././Init/Prelude.html#List">List</a></code> of ZFA lists to a proper ZFA prelist.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.ofList">Lists'.ofList</a> <span class="fn">[]</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">Lists'.nil</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.ofList">Lists'.ofList</a> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.cons">Lists'.cons</a> <span class="fn">a</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.ofList">Lists'.ofList</a> <span class="fn">l</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-Lists'.ofList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lists'.to_ofList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L99-L99">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists'.to_ofList"><span class="name">Lists'</span>.<span class="name">to_ofList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(l : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.toList">Lists'.toList</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.ofList">Lists'.ofList</a> <span class="fn">l</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Lists'.of_toList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L103-L120">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists'.of_toList"><span class="name">Lists'</span>.<span class="name">of_toList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(l : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.ofList">Lists'.ofList</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.toList">Lists'.toList</a> <span class="fn">l</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Lists.Equiv"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L126-L129">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv"><span class="name">Lists</span>.<span class="name">Equiv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span> → <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span> → <a href="../.././foundational_types.html">Prop</a></span></div></div><p>Equivalence of ZFA lists. Defined inductively.</p><ul class="constructors"><li class="constructor" id="Lists.Equiv.refl">refl: <span class="fn">∀ {<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1} (<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>), <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv">Lists.Equiv</a> <span class="fn">l</span> <span class="fn">l</span></span></span></li><li class="constructor" id="Lists.Equiv.antisymm">antisymm: <span class="fn">∀ {<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1} {<span class="fn">l₁ </span>l₂ : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>},
  <span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.Subset">Lists'.Subset</a> <span class="fn">l₁</span> <span class="fn">l₂</span></span> → <span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.Subset">Lists'.Subset</a> <span class="fn">l₂</span> <span class="fn">l₁</span></span> → <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv">Lists.Equiv</a> <span class="fn">{ <span class="fn">fst</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>, <span class="fn">snd</span> := <span class="fn">l₁</span> }</span> <span class="fn">{ <span class="fn">fst</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>, <span class="fn">snd</span> := <span class="fn">l₂</span> }</span></span></span></span></span></li></ul><details id="instances-for-list-Lists.Equiv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lists'.Subset"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L130-L134">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists'.Subset"><span class="name">Lists'</span>.<span class="name">Subset</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span> → <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span> → <a href="../.././foundational_types.html">Prop</a></span></div></div><p>Subset relation for ZFA lists. Defined inductively.</p><ul class="constructors"><li class="constructor" id="Lists'.Subset.nil">nil: <span class="fn">∀ {<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1} {<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>}, <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.Subset">Lists'.Subset</a> <span class="fn">Lists'.nil</span> <span class="fn">l</span></span></span></li><li class="constructor" id="Lists'.Subset.cons">cons: <span class="fn">∀ {<span class="fn">α</span> : <a href="../.././foundational_types.html">Type</a> u_1} {<span class="fn">a </span>a' : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>} {<span class="fn">l </span>l' : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>},
  <span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv">Lists.Equiv</a> <span class="fn">a</span> <span class="fn">a'</span></span> → <span class="fn"><span class="fn"><span class="fn">a'</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.toList">Lists'.toList</a> <span class="fn">l'</span></span></span> → <span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.Subset">Lists'.Subset</a> <span class="fn">l</span> <span class="fn">l'</span></span> → <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.Subset">Lists'.Subset</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.cons">Lists'.cons</a> <span class="fn">a</span> <span class="fn">l</span></span>)</span> <span class="fn">l'</span></span></span></span></span></span></li></ul><details id="instances-for-list-Lists'.Subset" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lists'.instHasSubsetLists'True"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L149-L150">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists'.instHasSubsetLists'True"><span class="name">Lists'</span>.<span class="name">instHasSubsetLists'True</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Std/Classes/SetNotation.html#HasSubset">HasSubset</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Lists'.instHasSubsetLists'True</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">Subset</span> := <span class="fn">Lists'.Subset</span> }</span></span></li></ul></details></div></div><div class="decl" id="Lists'.instMembershipListsLists'"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L154-L155">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists'.instMembershipListsLists'"><span class="name">Lists'</span>.<span class="name">instMembershipListsLists'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././Init/Prelude.html#Bool">Bool</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <span class="fn">b</span></span>)</span></span></div></div><p>ZFA prelist membership. A ZFA list is in a ZFA prelist if some element of this ZFA prelist is
equivalent as a ZFA list to this ZFA list.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Lists'.instMembershipListsLists'</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">mem</span> := <span class="fn">fun (<span class="fn">a</span> : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>) (<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <span class="fn">b</span></span>) =&gt; <span class="fn">∃ (<span class="fn">a'</span> : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">a'</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.toList">Lists'.toList</a> <span class="fn">l</span></span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv">Lists.Equiv</a> <span class="fn">a</span> <span class="fn">a'</span></span></span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Lists'.mem_def"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L157-L158">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists'.mem_def"><span class="name">Lists'</span>.<span class="name">mem_def</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././Init/Prelude.html#Bool">Bool</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <span class="fn">b</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∃ (<span class="fn">a'</span> : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">a'</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.toList">Lists'.toList</a> <span class="fn">l</span></span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv">Lists.Equiv</a> <span class="fn">a</span> <span class="fn">a'</span></span></span></span></span></div></div></div></div><div class="decl" id="Lists'.mem_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L162-L163">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists'.mem_cons"><span class="name">Lists'</span>.<span class="name">mem_cons</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.cons">Lists'.cons</a> <span class="fn">y</span> <span class="fn">l</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv">Lists.Equiv</a> <span class="fn">a</span> <span class="fn">y</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></span></span></span></div></div></div></div><div class="decl" id="Lists'.cons_subset"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L166-L172">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists'.cons_subset"><span class="name">Lists'</span>.<span class="name">cons_subset</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l₁ : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l₂ : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.cons">Lists'.cons</a> <span class="fn">a</span> <span class="fn">l₁</span></span> <a href="../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn">l₂</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l₂</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">l₁</span> <a href="../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn">l₂</span></span></span></span></div></div></div></div><div class="decl" id="Lists'.ofList_subset"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L175-L179">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists'.ofList_subset"><span class="name">Lists'</span>.<span class="name">ofList_subset</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l₁ : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l₂ : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">l₁</span> <a href="../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn">l₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.ofList">Lists'.ofList</a> <span class="fn">l₁</span></span> <a href="../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.ofList">Lists'.ofList</a> <span class="fn">l₂</span></span></span></div></div></div></div><div class="decl" id="Lists'.Subset.refl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L183-L184">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists'.Subset.refl"><span class="name">Lists'</span>.<span class="name">Subset</span>.<span class="name">refl</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l</span> <a href="../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Lists'.subset_nil"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L187-L191">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists'.subset_nil"><span class="name">Lists'</span>.<span class="name">subset_nil</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l</span> <a href="../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn">Lists'.nil</span></span> → <span class="fn"><span class="fn">l</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">Lists'.nil</span></span></span></div></div></div></div><div class="decl" id="Lists'.mem_of_subset'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L194-L201">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists'.mem_of_subset'"><span class="name">Lists'</span>.<span class="name">mem_of_subset'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l₁ : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l₂ : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l₁</span> <a href="../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn">l₂</span></span> → <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.toList">Lists'.toList</a> <span class="fn">l₁</span></span></span> → <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l₂</span></span></span></span></div></div></div></div><div class="decl" id="Lists'.subset_def"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L204-L210">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists'.subset_def"><span class="name">Lists'</span>.<span class="name">subset_def</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l₁ : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l₂ : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">l₁</span> <a href="../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn">l₂</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">a</span> : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>), <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.toList">Lists'.toList</a> <span class="fn">l₁</span></span></span> → <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l₂</span></span></span></span></span></div></div></div></div><div class="decl" id="Lists.atom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L219-L220">source</a></div><div class="attributes">@[match_pattern]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists.atom"><span class="name">Lists</span>.<span class="name">atom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span></div></div><p>Sends <code>a : α</code> to the corresponding atom in <code><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> α</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.atom">Lists.atom</a> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">fst</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a>, <span class="fn">snd</span> := <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.atom">Lists'.atom</a> <span class="fn">a</span></span> }</span></span></li></ul></details><details id="instances-for-list-Lists.atom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lists.of'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L225-L226">source</a></div><div class="attributes">@[match_pattern]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists.of'"><span class="name">Lists</span>.<span class="name">of'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(l : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span></div></div><p>Converts a proper ZFA prelist to a ZFA list.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.of'">Lists.of'</a> <span class="fn">l</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">fst</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>, <span class="fn">snd</span> := <span class="fn">l</span> }</span></span></li></ul></details><details id="instances-for-list-Lists.of'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lists.toList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L231-L232">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists.toList"><span class="name">Lists</span>.<span class="name">toList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span> → <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>)</span></span></span></div></div><p>Converts a ZFA list to a <code><a href="../.././Init/Prelude.html#List">List</a></code> of ZFA lists. Atoms are sent to <code>[]</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.toList">Lists.toList</a> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">x</span> with
  | <span class="fn">{ <span class="fn">fst</span> := <span class="fn">fst</span>, <span class="fn">snd</span> := <span class="fn">l</span> }</span> =&gt; <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.toList">Lists'.toList</a> <span class="fn">l</span></span></span></span></li></ul></details><details id="instances-for-list-Lists.toList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lists.IsList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L236-L237">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists.IsList"><span class="name">Lists</span>.<span class="name">IsList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(l : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Prop</a></div></div><p>Predicate stating that a ZFA list is proper.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.IsList">Lists.IsList</a> <span class="fn">l</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">l</span>.fst</span> <a href="../.././Init/Prelude.html#Eq">=</a> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>)</span></span></li></ul></details><details id="instances-for-list-Lists.IsList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lists.ofList"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L241-L242">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists.ofList"><span class="name">Lists</span>.<span class="name">ofList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(l : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span></div></div><p>Converts a <code><a href="../.././Init/Prelude.html#List">List</a></code> of ZFA lists to a ZFA list.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.ofList">Lists.ofList</a> <span class="fn">l</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.of'">Lists.of'</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.ofList">Lists'.ofList</a> <span class="fn">l</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-Lists.ofList" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lists.isList_toList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L245-L246">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists.isList_toList"><span class="name">Lists</span>.<span class="name">isList_toList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(l : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.IsList">Lists.IsList</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.ofList">Lists.ofList</a> <span class="fn">l</span></span>)</span></span></div></div></div></div><div class="decl" id="Lists.to_ofList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L249-L249">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists.to_ofList"><span class="name">Lists</span>.<span class="name">to_ofList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(l : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.toList">Lists.toList</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.ofList">Lists.ofList</a> <span class="fn">l</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span></span></div></div></div></div><div class="decl" id="Lists.of_toList"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L252-L253">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists.of_toList"><span class="name">Lists</span>.<span class="name">of_toList</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.IsList">Lists.IsList</a> <span class="fn">l</span></span> → <span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.ofList">Lists.ofList</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.toList">Lists.toList</a> <span class="fn">l</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Lists.instInhabitedLists"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L256-L257">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists.instInhabitedLists"><span class="name">Lists</span>.<span class="name">instInhabitedLists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Lists.instInhabitedLists</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.of'">Lists.of'</a> <span class="fn">Lists'.nil</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Lists.instDecidableEqLists"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L259-L259">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists.instDecidableEqLists"><span class="name">Lists</span>.<span class="name">instDecidableEqLists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Lists.instDecidableEqLists</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#id">id</a> <span class="fn">inferInstance</span></span></span></li></ul></details></div></div><div class="decl" id="Lists.instSizeOfLists"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L261-L261">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists.instSizeOfLists"><span class="name">Lists</span>.<span class="name">instSizeOfLists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/SizeOf.html#SizeOf">SizeOf</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/SizeOf.html#SizeOf">SizeOf</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Lists.instSizeOfLists</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#id">id</a> <span class="fn">inferInstance</span></span></span></li></ul></details></div></div><div class="decl" id="Lists.inductionMut"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L264-L280">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists.inductionMut"><span class="name">Lists</span>.<span class="name">inductionMut</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(C : <span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span> → <a href="../.././foundational_types.html">Sort</a> u_2</span>)</span></span>
<span class="decl_args">
<span class="fn">(D : <span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span> → <a href="../.././foundational_types.html">Sort</a> u_3</span>)</span></span>
<span class="decl_args">
<span class="fn">(C0 : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">C</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.atom">Lists.atom</a> <span class="fn">a</span></span>)</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(C1 : <span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>) → <span class="fn"><span class="fn"><span class="fn">D</span> <span class="fn">l</span></span> → <span class="fn"><span class="fn">C</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.of'">Lists.of'</a> <span class="fn">l</span></span>)</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(D0 : <span class="fn"><span class="fn">D</span> <span class="fn">Lists'.nil</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(D1 : <span class="fn">(<span class="fn">a</span> : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>) → <span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>) → <span class="fn"><span class="fn"><span class="fn">C</span> <span class="fn">a</span></span> → <span class="fn"><span class="fn"><span class="fn">D</span> <span class="fn">l</span></span> → <span class="fn"><span class="fn">D</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.cons">Lists'.cons</a> <span class="fn">a</span> <span class="fn">l</span></span>)</span></span></span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#PProd">PProd</a> <span class="fn">(<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>) → <span class="fn"><span class="fn">C</span> <span class="fn">l</span></span></span>)</span> <span class="fn">(<span class="fn">(<span class="fn">l</span> : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>) → <span class="fn"><span class="fn">D</span> <span class="fn">l</span></span></span>)</span></span></div></div><p>A recursion principle for pairs of ZFA lists and proper ZFA prelists.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lists.inductionMut" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lists.mem"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L285-L287">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists.mem"><span class="name">Lists</span>.<span class="name">mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span> → <a href="../.././foundational_types.html">Prop</a></span></div></div><p>Membership of ZFA list. A ZFA list belongs to a proper ZFA list if it belongs to the latter as a
proper ZFA prelist. An atom has no members.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.mem">Lists.mem</a> <span class="fn">a</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">x</span> with
  | <span class="fn">{ <span class="fn">fst</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a>, <span class="fn">snd</span> := <span class="fn">snd</span> }</span> =&gt; <a href="../.././Init/Prelude.html#False">False</a>
  | <span class="fn">{ <span class="fn">fst</span> := <span class="fn">fst</span>, <span class="fn">snd</span> := <span class="fn">l</span> }</span> =&gt; <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></span></span></span></li></ul></details><details id="instances-for-list-Lists.mem" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lists.instMembershipLists"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L290-L291">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists.instMembershipLists"><span class="name">Lists</span>.<span class="name">instMembershipLists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Membership">Membership</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Lists.instMembershipLists</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">mem</span> := <span class="fn">Lists.mem</span> }</span></span></li></ul></details></div></div><div class="decl" id="Lists.isList_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L293-L295">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists.isList_of_mem"><span class="name">Lists</span>.<span class="name">isList_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></span> → <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.IsList">Lists.IsList</a> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Lists.Equiv.antisymm_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L298-L302">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv.antisymm_iff"><span class="name">Lists</span>.<span class="name">Equiv</span>.<span class="name">antisymm_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l₁ : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l₂ : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv">Lists.Equiv</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.of'">Lists.of'</a> <span class="fn">l₁</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.of'">Lists.of'</a> <span class="fn">l₂</span></span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">l₁</span> <a href="../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn">l₂</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">l₂</span> <a href="../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn">l₁</span></span></span></span></div></div></div></div><div class="decl" id="Lists.equiv_atom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L307-L308">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists.equiv_atom"><span class="name">Lists</span>.<span class="name">equiv_atom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv">Lists.Equiv</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.atom">Lists.atom</a> <span class="fn">a</span></span>)</span> <span class="fn">l</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.atom">Lists.atom</a> <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Lists.Equiv.symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L312-L313">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv.symm"><span class="name">Lists</span>.<span class="name">Equiv</span>.<span class="name">symm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l₁ : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l₂ : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv">Lists.Equiv</a> <span class="fn">l₁</span> <span class="fn">l₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv">Lists.Equiv</a> <span class="fn">l₂</span> <span class="fn">l₁</span></span></div></div></div></div><div class="decl" id="Lists.Equiv.trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L316-L352">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv.trans"><span class="name">Lists</span>.<span class="name">Equiv</span>.<span class="name">trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l₁ : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l₂ : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l₃ : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv">Lists.Equiv</a> <span class="fn">l₁</span> <span class="fn">l₂</span></span> → <span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv">Lists.Equiv</a> <span class="fn">l₂</span> <span class="fn">l₃</span></span> → <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv">Lists.Equiv</a> <span class="fn">l₁</span> <span class="fn">l₃</span></span></span></span></div></div></div></div><div class="decl" id="Lists.instSetoidLists"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L355-L356">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists.instSetoidLists"><span class="name">Lists</span>.<span class="name">instSetoidLists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#Setoid">Setoid</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Lists.instSetoidLists</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">r</span> := <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>) =&gt; <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv">Lists.Equiv</a> <span class="fn">x</span> <span class="fn">x_1</span></span></span>,
    <span class="fn">iseqv</span> := <span class="fn">(_ : <span class="fn"><a href="../.././Init/Core.html#Equivalence">Equivalence</a> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>) =&gt; <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv">Lists.Equiv</a> <span class="fn">x</span> <span class="fn">x_1</span></span></span></span>)</span> }</span></span></li></ul></details></div></div><div class="decl" id="Lists.Equiv.decidableMeas"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L362-L368">source</a></div><div class="attributes">@[deprecated]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv.decidableMeas"><span class="name">Lists</span>.<span class="name">Equiv</span>.<span class="name">decidableMeas</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>) ×' <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span></span> <a href="../.././Init/Core.html#PSum">⊕'</a> <span class="fn"><span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>) ×' <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span></span> <a href="../.././Init/Core.html#PSum">⊕'</a> <span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>) ×' <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span></span></span></span> → <a href="../.././Init/Prelude.html#Nat">ℕ</a></span></div></div><p>Auxiliary function to prove termination of decidability checking</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lists.Equiv.decidableMeas" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lists.sizeof_pos"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L371-L373">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists.sizeof_pos"><span class="name">Lists</span>.<span class="name">sizeof_pos</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././Init/Prelude.html#Bool">Bool</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(l : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">0</span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><a href="../.././Init/SizeOf.html#SizeOf.sizeOf">sizeOf</a> <span class="fn">l</span></span></span></div></div></div></div><div class="decl" id="Lists.lt_sizeof_cons'"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L376-L379">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists.lt_sizeof_cons'"><span class="name">Lists</span>.<span class="name">lt_sizeof_cons'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href="../.././Init/Prelude.html#Bool">Bool</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(l : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/SizeOf.html#SizeOf.sizeOf">sizeOf</a> <span class="fn">{ <span class="fn">fst</span> := <span class="fn">b</span>, <span class="fn">snd</span> := <span class="fn">a</span> }</span></span> <a href="../.././Init/Prelude.html#LT.lt">&lt;</a> <span class="fn"><a href="../.././Init/SizeOf.html#SizeOf.sizeOf">sizeOf</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.cons'">Lists'.cons'</a> <span class="fn">a</span> <span class="fn">l</span></span>)</span></span></span></div></div></div></div><div class="decl" id="Lists.Equiv.decidable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L385-L405">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv.decidable"><span class="name">Lists</span>.<span class="name">Equiv</span>.<span class="name">decidable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(l₁ : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(l₂ : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv">Lists.Equiv</a> <span class="fn">l₁</span> <span class="fn">l₂</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv.decidable">Lists.Equiv.decidable</a> <span class="fn">{ <span class="fn">fst</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a>, <span class="fn">snd</span> := <span class="fn">l₁</span> }</span> <span class="fn">{ <span class="fn">fst</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a>, <span class="fn">snd</span> := <span class="fn">l₂</span> }</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Std/Logic.html#decidable_of_iff'">decidable_of_iff'</a> <span class="fn">(<span class="fn"><span class="fn">l₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">l₂</span></span>)</span> <span class="fn">(_ : <span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv">Lists.Equiv</a> <span class="fn">{ <span class="fn">fst</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a>, <span class="fn">snd</span> := <span class="fn">l₁</span> }</span> <span class="fn">{ <span class="fn">fst</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a>, <span class="fn">snd</span> := <span class="fn">l₂</span> }</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">l₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">l₂</span></span></span>)</span></span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv.decidable">Lists.Equiv.decidable</a> <span class="fn">{ <span class="fn">fst</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a>, <span class="fn">snd</span> := <span class="fn">l₁</span> }</span> <span class="fn">{ <span class="fn">fst</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>, <span class="fn">snd</span> := <span class="fn">l₂</span> }</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">(_ : <span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv">Lists.Equiv</a> <span class="fn">{ <span class="fn">fst</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a>, <span class="fn">snd</span> := <span class="fn">l₁</span> }</span> <span class="fn">{ <span class="fn">fst</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>, <span class="fn">snd</span> := <span class="fn">l₂</span> }</span></span> → <a href="../.././Init/Prelude.html#False">False</a></span>)</span></span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv.decidable">Lists.Equiv.decidable</a> <span class="fn">{ <span class="fn">fst</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>, <span class="fn">snd</span> := <span class="fn">l₁</span> }</span> <span class="fn">{ <span class="fn">fst</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a>, <span class="fn">snd</span> := <span class="fn">l₂</span> }</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">(_ : <span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv">Lists.Equiv</a> <span class="fn">{ <span class="fn">fst</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>, <span class="fn">snd</span> := <span class="fn">l₁</span> }</span> <span class="fn">{ <span class="fn">fst</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a>, <span class="fn">snd</span> := <span class="fn">l₂</span> }</span></span> → <a href="../.././Init/Prelude.html#False">False</a></span>)</span></span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv.decidable">Lists.Equiv.decidable</a> <span class="fn">{ <span class="fn">fst</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>, <span class="fn">snd</span> := <span class="fn">l₁</span> }</span> <span class="fn">{ <span class="fn">fst</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>, <span class="fn">snd</span> := <span class="fn">l₂</span> }</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Std/Logic.html#decidable_of_iff'">decidable_of_iff'</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">l₁</span> <a href="../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn">l₂</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">l₂</span> <a href="../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn">l₁</span></span></span>)</span> <span class="fn">(_ : <span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv">Lists.Equiv</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.of'">Lists.of'</a> <span class="fn">l₁</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.of'">Lists.of'</a> <span class="fn">l₂</span></span>)</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">l₁</span> <a href="../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn">l₂</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">l₂</span> <a href="../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn">l₁</span></span></span></span>)</span></span></span></li></ul></details></div></div><div class="decl" id="Lists.Subset.decidable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L406-L417">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists.Subset.decidable"><span class="name">Lists</span>.<span class="name">Subset</span>.<span class="name">decidable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(l₁ : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(l₂ : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn"><span class="fn">l₁</span> <a href="../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn">l₂</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.Subset.decidable">Lists.Subset.decidable</a> <span class="fn">Lists'.nil</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.Subset">Lists'.Subset</a> <span class="fn">Lists'.nil</span> <span class="fn">x</span></span>)</span></span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.Subset.decidable">Lists.Subset.decidable</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.cons'">Lists'.cons'</a> <span class="fn">a</span> <span class="fn">l₁</span></span>)</span> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Std/Logic.html#decidable_of_iff'">decidable_of_iff'</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">{ <span class="fn">fst</span> := <span class="fn">b</span>, <span class="fn">snd</span> := <span class="fn">a</span> }</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">l₁</span> <a href="../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn">x</span></span></span>)</span>
    <span class="fn">(_ : <span class="fn"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.cons">Lists'.cons</a> <span class="fn">{ <span class="fn">fst</span> := <span class="fn">b</span>, <span class="fn">snd</span> := <span class="fn">a</span> }</span> <span class="fn">l₁</span></span> <a href="../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn">x</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><span class="fn">{ <span class="fn">fst</span> := <span class="fn">b</span>, <span class="fn">snd</span> := <span class="fn">a</span> }</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">x</span></span> <a href="../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">l₁</span> <a href="../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn">x</span></span></span></span>)</span></span></span></li></ul></details></div></div><div class="decl" id="Lists.mem.decidable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L418-L431">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists.mem.decidable"><span class="name">Lists</span>.<span class="name">mem</span>.<span class="name">decidable</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(l : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">(<span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.mem.decidable">Lists.mem.decidable</a> <span class="fn">x</span> <span class="fn">Lists'.nil</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">(_ : <span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">Lists'.nil</span></span> → <a href="../.././Init/Prelude.html#False">False</a></span>)</span></span></span></li><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.mem.decidable">Lists.mem.decidable</a> <span class="fn">x</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.cons'">Lists'.cons'</a> <span class="fn">b_1</span> <span class="fn">l₂</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Std/Logic.html#decidable_of_iff'">decidable_of_iff'</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv">Lists.Equiv</a> <span class="fn">x</span> <span class="fn">{ <span class="fn">fst</span> := <span class="fn">b</span>, <span class="fn">snd</span> := <span class="fn">b_1</span> }</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l₂</span></span></span>)</span>
    <span class="fn">(_ : <span class="fn"><span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'.cons'">Lists'.cons'</a> <span class="fn">b_1</span> <span class="fn">l₂</span></span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv">Lists.Equiv</a> <span class="fn">x</span> <span class="fn">{ <span class="fn">fst</span> := <span class="fn">b</span>, <span class="fn">snd</span> := <span class="fn">b_1</span> }</span></span> <a href="../.././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">x</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l₂</span></span></span></span>)</span></span></span></li></ul></details></div></div><div class="decl" id="Lists'.mem_equiv_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L450-L452">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists'.mem_equiv_left"><span class="name">Lists'</span>.<span class="name">mem_equiv_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a' : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.Equiv">Lists.Equiv</a> <span class="fn">a</span> <span class="fn">a'</span></span> → <span class="fn">(<span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></span> <a href="../.././Init/Core.html#Iff">↔</a> <span class="fn"><span class="fn">a'</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l</span></span></span>)</span></span></div></div></div></div><div class="decl" id="Lists'.mem_of_subset"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L455-L456">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists'.mem_of_subset"><span class="name">Lists'</span>.<span class="name">mem_of_subset</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l₁ : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l₂ : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn"><span class="fn">l₁</span> <a href="../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn">l₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l₁</span></span> → <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">l₂</span></span></span></div></div></div></div><div class="decl" id="Lists'.Subset.trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L459-L460">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Lists'.Subset.trans"><span class="name">Lists'</span>.<span class="name">Subset</span>.<span class="name">trans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l₁ : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l₂ : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l₃ : <span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists'">Lists'</a> <span class="fn">α</span> <a href="../.././Init/Prelude.html#Bool.true">true</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">l₁</span> <a href="../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn">l₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">l₂</span> <a href="../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn">l₃</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">l₁</span> <a href="../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn">l₃</span></span></div></div></div></div><div class="decl" id="Finsets"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L466-L467">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Finsets"><span class="name">Finsets</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> u_2</div></div><p><code><a href="../.././Mathlib/SetTheory/Lists.html#Finsets">Finsets</a></code> are defined via equivalence classes of <code><a href="../.././Mathlib/SetTheory/Lists.html#Lists">Lists</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Finsets">Finsets</a> <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Core.html#Quotient">Quotient</a> <span class="fn">Lists.instSetoidLists</span></span></span></li></ul></details><details id="instances-for-list-Finsets" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Finsets.instEmptyCollectionFinsets"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L472-L473">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Finsets.instEmptyCollectionFinsets"><span class="name">Finsets</span>.<span class="name">instEmptyCollectionFinsets</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Core.html#EmptyCollection">EmptyCollection</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Finsets">Finsets</a> <span class="fn">α</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Finsets.instEmptyCollectionFinsets</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">emptyCollection</span> := <span class="fn">⟦<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Lists.of'">Lists.of'</a> <span class="fn">Lists'.nil</span></span>⟧</span> }</span></span></li></ul></details></div></div><div class="decl" id="Finsets.instInhabitedFinsets"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L475-L476">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Finsets.instInhabitedFinsets"><span class="name">Finsets</span>.<span class="name">instInhabitedFinsets</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Finsets">Finsets</a> <span class="fn">α</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Finsets.instInhabitedFinsets</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <a href="../.././Init/Core.html#EmptyCollection.emptyCollection">∅</a> }</span></span></li></ul></details></div></div><div class="decl" id="Finsets.instDecidableEqFinsets"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/SetTheory/Lists.lean#L478-L481">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/SetTheory/Lists.html#Finsets.instDecidableEqFinsets"><span class="name">Finsets</span>.<span class="name">instDecidableEqFinsets</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/SetTheory/Lists.html#Finsets">Finsets</a> <span class="fn">α</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Finsets.instDecidableEqFinsets</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Prelude.html#id">id</a> <span class="fn">Quotient.decidableEq</span></span></span></li></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>