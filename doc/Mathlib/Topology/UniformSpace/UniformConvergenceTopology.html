<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="stylesheet" href="../../.././src/pygments.css"></link><link rel="shortcut icon" href="../../.././favicon.ico"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Topology.UniformSpace.UniformConvergenceTopology</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.Topology.UniformSpace.UniformConvergenceTopology";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Topology</span>.<span class="name">UniformSpace</span>.<span class="name">UniformConvergenceTopology</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;
            <button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html">Mathlib.Topology.UniformSpace.Equiv</a></li><li><a href="../../.././Mathlib/Topology/UniformSpace/Pi.html">Mathlib.Topology.UniformSpace.Pi</a></li><li><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergence.html">Mathlib.Topology.UniformSpace.UniformConvergence</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Topology.UniformSpace.UniformConvergenceTopology" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#UniformFun"><span class="name">UniformFun</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun"><span class="name">UniformOnFun</span></a></div><div class="nav_link"><a class="break_within" href="#UniformConvergence.«term_→ᵤ_»"><span class="name">UniformConvergence</span>.<span class="name">«term_→ᵤ_»</span></a></div><div class="nav_link"><a class="break_within" href="#UniformConvergence.«term_→ᵤ[_]_»"><span class="name">UniformConvergence</span>.<span class="name">«term_→ᵤ[_]_»</span></a></div><div class="nav_link"><a class="break_within" href="#instNonemptyUniformFun"><span class="name">instNonemptyUniformFun</span></a></div><div class="nav_link"><a class="break_within" href="#instNonemptyUniformOnFun"><span class="name">instNonemptyUniformOnFun</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.ofFun"><span class="name">UniformFun</span>.<span class="name">ofFun</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.ofFun"><span class="name">UniformOnFun</span>.<span class="name">ofFun</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.toFun"><span class="name">UniformFun</span>.<span class="name">toFun</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.toFun"><span class="name">UniformOnFun</span>.<span class="name">toFun</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.toFun_ofFun"><span class="name">UniformFun</span>.<span class="name">toFun_ofFun</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.ofFun_toFun"><span class="name">UniformFun</span>.<span class="name">ofFun_toFun</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.toFun_ofFun"><span class="name">UniformOnFun</span>.<span class="name">toFun_ofFun</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.ofFun_toFun"><span class="name">UniformOnFun</span>.<span class="name">ofFun_toFun</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.gen"><span class="name">UniformFun</span>.<span class="name">gen</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.isBasis_gen"><span class="name">UniformFun</span>.<span class="name">isBasis_gen</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.basis"><span class="name">UniformFun</span>.<span class="name">basis</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.filter"><span class="name">UniformFun</span>.<span class="name">filter</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.phi"><span class="name">UniformFun</span>.<span class="name">phi</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.gc"><span class="name">UniformFun</span>.<span class="name">gc</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.uniformCore"><span class="name">UniformFun</span>.<span class="name">uniformCore</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.uniformSpace"><span class="name">UniformFun</span>.<span class="name">uniformSpace</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.topologicalSpace"><span class="name">UniformFun</span>.<span class="name">topologicalSpace</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.hasBasis_uniformity"><span class="name">UniformFun</span>.<span class="name">hasBasis_uniformity</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.hasBasis_uniformity_of_basis"><span class="name">UniformFun</span>.<span class="name">hasBasis_uniformity_of_basis</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.hasBasis_nhds_of_basis"><span class="name">UniformFun</span>.<span class="name">hasBasis_nhds_of_basis</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.hasBasis_nhds"><span class="name">UniformFun</span>.<span class="name">hasBasis_nhds</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.uniformContinuous_eval"><span class="name">UniformFun</span>.<span class="name">uniformContinuous_eval</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.mem_gen"><span class="name">UniformFun</span>.<span class="name">mem_gen</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.mono"><span class="name">UniformFun</span>.<span class="name">mono</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.iInf_eq"><span class="name">UniformFun</span>.<span class="name">iInf_eq</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.inf_eq"><span class="name">UniformFun</span>.<span class="name">inf_eq</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.postcomp_uniformInducing"><span class="name">UniformFun</span>.<span class="name">postcomp_uniformInducing</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.comap_eq"><span class="name">UniformFun</span>.<span class="name">comap_eq</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.postcomp_uniformContinuous"><span class="name">UniformFun</span>.<span class="name">postcomp_uniformContinuous</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.congrRight"><span class="name">UniformFun</span>.<span class="name">congrRight</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.precomp_uniformContinuous"><span class="name">UniformFun</span>.<span class="name">precomp_uniformContinuous</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.congrLeft"><span class="name">UniformFun</span>.<span class="name">congrLeft</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.uniformContinuous_toFun"><span class="name">UniformFun</span>.<span class="name">uniformContinuous_toFun</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.instT2SpaceUniformFunTopologicalSpace"><span class="name">UniformFun</span>.<span class="name">instT2SpaceUniformFunTopologicalSpace</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.tendsto_iff_tendstoUniformly"><span class="name">UniformFun</span>.<span class="name">tendsto_iff_tendstoUniformly</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.uniformEquivProdArrow"><span class="name">UniformFun</span>.<span class="name">uniformEquivProdArrow</span></a></div><div class="nav_link"><a class="break_within" href="#UniformFun.uniformEquivPiComm"><span class="name">UniformFun</span>.<span class="name">uniformEquivPiComm</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.gen"><span class="name">UniformOnFun</span>.<span class="name">gen</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.gen_eq_preimage_restrict"><span class="name">UniformOnFun</span>.<span class="name">gen_eq_preimage_restrict</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.gen_mono"><span class="name">UniformOnFun</span>.<span class="name">gen_mono</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.isBasis_gen"><span class="name">UniformOnFun</span>.<span class="name">isBasis_gen</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.uniformSpace"><span class="name">UniformOnFun</span>.<span class="name">uniformSpace</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.topologicalSpace"><span class="name">UniformOnFun</span>.<span class="name">topologicalSpace</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.topologicalSpace_eq"><span class="name">UniformOnFun</span>.<span class="name">topologicalSpace_eq</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.hasBasis_uniformity_of_basis_aux₁"><span class="name">UniformOnFun</span>.<span class="name">hasBasis_uniformity_of_basis_aux₁</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.hasBasis_uniformity_of_basis_aux₂"><span class="name">UniformOnFun</span>.<span class="name">hasBasis_uniformity_of_basis_aux₂</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.hasBasis_uniformity_of_basis"><span class="name">UniformOnFun</span>.<span class="name">hasBasis_uniformity_of_basis</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.hasBasis_uniformity"><span class="name">UniformOnFun</span>.<span class="name">hasBasis_uniformity</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.hasBasis_nhds_of_basis"><span class="name">UniformOnFun</span>.<span class="name">hasBasis_nhds_of_basis</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.hasBasis_nhds"><span class="name">UniformOnFun</span>.<span class="name">hasBasis_nhds</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.uniformContinuous_restrict"><span class="name">UniformOnFun</span>.<span class="name">uniformContinuous_restrict</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.mono"><span class="name">UniformOnFun</span>.<span class="name">mono</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.uniformContinuous_eval_of_mem"><span class="name">UniformOnFun</span>.<span class="name">uniformContinuous_eval_of_mem</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.iInf_eq"><span class="name">UniformOnFun</span>.<span class="name">iInf_eq</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.inf_eq"><span class="name">UniformOnFun</span>.<span class="name">inf_eq</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.comap_eq"><span class="name">UniformOnFun</span>.<span class="name">comap_eq</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.postcomp_uniformContinuous"><span class="name">UniformOnFun</span>.<span class="name">postcomp_uniformContinuous</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.postcomp_uniformInducing"><span class="name">UniformOnFun</span>.<span class="name">postcomp_uniformInducing</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.congrRight"><span class="name">UniformOnFun</span>.<span class="name">congrRight</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.precomp_uniformContinuous"><span class="name">UniformOnFun</span>.<span class="name">precomp_uniformContinuous</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.congrLeft"><span class="name">UniformOnFun</span>.<span class="name">congrLeft</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.t2Space_of_covering"><span class="name">UniformOnFun</span>.<span class="name">t2Space_of_covering</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.uniformContinuous_toFun"><span class="name">UniformOnFun</span>.<span class="name">uniformContinuous_toFun</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.tendsto_iff_tendstoUniformlyOn"><span class="name">UniformOnFun</span>.<span class="name">tendsto_iff_tendstoUniformlyOn</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.uniformEquivProdArrow"><span class="name">UniformOnFun</span>.<span class="name">uniformEquivProdArrow</span></a></div><div class="nav_link"><a class="break_within" href="#UniformOnFun.uniformEquivPiComm"><span class="name">UniformOnFun</span>.<span class="name">uniformEquivPiComm</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Topology-and-uniform-structure-of-uniform-convergence">Topology and uniform structure of uniform convergence <a class="hover-link" href="#Topology-and-uniform-structure-of-uniform-convergence">#</a></h1><p>This files endows <code>α → β</code> with the topologies / uniform structures of</p><ul>
<li>uniform convergence on <code>α</code></li>
<li>uniform convergence on a specified family <code>𝔖</code> of sets of <code>α</code>, also called <code>𝔖</code>-convergence</li>
</ul><p>Since <code>α → β</code> is already endowed with the topologies and uniform structures of pointwise
convergence, we introduce type aliases <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> α β</code> (denoted <code>α →ᵤ β</code>) and
<code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> α β 𝔖</code> (denoted <code>α →ᵤ[𝔖] β</code>) and we actually endow <em>these</em> with the structures
of uniform and <code>𝔖</code>-convergence respectively.</p><p>Usual examples of the second construction include :</p><ul>
<li>the topology of compact convergence, when <code>𝔖</code> is the set of compacts of <code>α</code></li>
<li>the strong topology on the dual of a topological vector space (TVS) <code>E</code>, when <code>𝔖</code> is the set of
Von Neumann bounded subsets of <code>E</code></li>
<li>the weak-* topology on the dual of a TVS <code>E</code>, when <code>𝔖</code> is the set of singletons of <code>E</code>.</li>
</ul><p>This file contains a lot of technical facts, so it is heavily commented, proofs included!</p><h2 class="markdown-heading" id="Main-definitions">Main definitions <a class="hover-link" href="#Main-definitions">#</a></h2><ul>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gen">UniformFun.gen</a></code>: basis sets for the uniformity of uniform convergence. These are sets
of the form <code>S(V) := {(f, g) | ∀ x : α, (f x, g x) ∈ V}</code> for some <code>V : <a href="../../.././Mathlib/Init/Set.html#Set">Set</a> (β × β)</code></li>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace">UniformFun.uniformSpace</a></code>: uniform structure of uniform convergence. This is the
<code><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a></code> on <code>α →ᵤ β</code> whose uniformity is generated by the sets <code>S(V)</code> for <code>V ∈ 𝓤 β</code>.
We will denote this uniform space as <code>𝒰(α, β, uβ)</code>, both in the comments and as a local notation
in the Lean code, where <code>uβ</code> is the uniform space structure on <code>β</code>.
This is declared as an instance on <code>α →ᵤ β</code>.</li>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace">UniformOnFun.uniformSpace</a></code>: uniform structure of <code>𝔖</code>-convergence, where
<code>𝔖 : <a href="../../.././Mathlib/Init/Set.html#Set">Set</a> (Set α)</code>. This is the infimum, for <code>S ∈ 𝔖</code>, of the pullback of <code>𝒰 S β</code> by the map of
restriction to <code>S</code>. We will denote it <code>𝒱(α, β, 𝔖, uβ)</code>, where <code>uβ</code> is the uniform space structure
on <code>β</code>.
This is declared as an instance on <code>α →ᵤ[𝔖] β</code>.</li>
</ul><h2 class="markdown-heading" id="Main-statements">Main statements <a class="hover-link" href="#Main-statements">#</a></h2><h3 class="markdown-heading" id="Basic-properties">Basic properties <a class="hover-link" href="#Basic-properties">#</a></h3><ul>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformContinuous_eval">UniformFun.uniformContinuous_eval</a></code>: evaluation is uniformly continuous on <code>α →ᵤ β</code>.</li>
<li><code>UniformFun.t2Space</code>: the topology of uniform convergence on <code>α →ᵤ β</code> is T₂ if
<code>β</code> is T₂.</li>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.tendsto_iff_tendstoUniformly">UniformFun.tendsto_iff_tendstoUniformly</a></code>: <code>𝒰(α, β, uβ)</code> is
indeed the uniform structure of uniform convergence</li>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformContinuous_eval_of_mem">UniformOnFun.uniformContinuous_eval_of_mem</a></code>: evaluation at a point contained in a
set of <code>𝔖</code> is uniformly continuous on <code>α →ᵤ[𝔖] β</code></li>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.t2Space_of_covering">UniformOnFun.t2Space_of_covering</a></code>: the topology of <code>𝔖</code>-convergence on <code>α →ᵤ[𝔖] β</code> is T₂ if
<code>β</code> is T₂ and <code>𝔖</code> covers <code>α</code></li>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.tendsto_iff_tendstoUniformlyOn">UniformOnFun.tendsto_iff_tendstoUniformlyOn</a></code>:
<code>𝒱(α, β, 𝔖 uβ)</code> is indeed the uniform structure of <code>𝔖</code>-convergence</li>
</ul><h3 class="markdown-heading" id="Functoriality-and-compatibility-with-product-of-uniform-spaces">Functoriality and compatibility with product of uniform spaces <a class="hover-link" href="#Functoriality-and-compatibility-with-product-of-uniform-spaces">#</a></h3><p>In order to avoid the need for filter bases as much as possible when using these definitions,
we develop an extensive API for manipulating these structures abstractly. As usual in the topology
section of mathlib, we first state results about the complete lattices of <code><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a></code>s on
fixed types, and then we use these to deduce categorical-like results about maps between two
uniform spaces.</p><p>We only describe these in the harder case of <code>𝔖</code>-convergence, as the names of the corresponding
results for uniform convergence can easily be guessed.</p><h4 class="markdown-heading" id="Order-statements">Order statements <a class="hover-link" href="#Order-statements">#</a></h4><ul>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.mono">UniformOnFun.mono</a></code>: let <code>u₁</code>, <code>u₂</code> be two uniform structures on <code>γ</code> and
<code>𝔖₁ 𝔖₂ : <a href="../../.././Mathlib/Init/Set.html#Set">Set</a> (Set α)</code>. If <code>u₁ ≤ u₂</code> and <code>𝔖₂ ⊆ 𝔖₁</code> then <code>𝒱(α, γ, 𝔖₁, u₁) ≤ 𝒱(α, γ, 𝔖₂, u₂)</code>.</li>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.iInf_eq">UniformOnFun.iInf_eq</a></code>: if <code>u</code> is a family of uniform structures on <code>γ</code>, then
<code>𝒱(α, γ, 𝔖, (⨅ i, u i)) = ⨅ i, 𝒱(α, γ, 𝔖, u i)</code>.</li>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.comap_eq">UniformOnFun.comap_eq</a></code>: if <code>u</code> is a uniform structures on <code>β</code> and <code>f : γ → β</code>, then
<code>𝒱(α, γ, 𝔖, comap f u) = comap (fun g ↦ f ∘ g) 𝒱(α, γ, 𝔖, u₁)</code>.</li>
</ul><p>An interesting note about these statements is that they are proved without ever unfolding the basis
definition of the uniform structure of uniform convergence! Instead, we build a
(not very interesting) Galois connection <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gc">UniformFun.gc</a></code> and then rely on the Galois
connection API to do most of the work.</p><h4 class="markdown-heading" id="Morphism-statements-unbundled">Morphism statements (unbundled) <a class="hover-link" href="#Morphism-statements-unbundled">#</a></h4><ul>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.postcomp_uniformContinuous">UniformOnFun.postcomp_uniformContinuous</a></code>: if <code>f : γ → β</code> is uniformly
continuous, then <code>(fun g ↦ f ∘ g) : (α →ᵤ[𝔖] γ) → (α →ᵤ[𝔖] β)</code> is uniformly continuous.</li>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.postcomp_uniformInducing">UniformOnFun.postcomp_uniformInducing</a></code>: if <code>f : γ → β</code> is a uniform
inducing, then <code>(fun g ↦ f ∘ g) : (α →ᵤ[𝔖] γ) → (α →ᵤ[𝔖] β)</code> is a uniform inducing.</li>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.precomp_uniformContinuous">UniformOnFun.precomp_uniformContinuous</a></code>: let <code>f : γ → α</code>, <code>𝔖 : <a href="../../.././Mathlib/Init/Set.html#Set">Set</a> (Set α)</code>,
<code>𝔗 : <a href="../../.././Mathlib/Init/Set.html#Set">Set</a> (Set γ)</code>, and assume that <code>∀ T ∈ 𝔗, f '' T ∈ 𝔖</code>. Then, the function
<code>(fun g ↦ g ∘ f) : (α →ᵤ[𝔖] β) → (γ →ᵤ[𝔗] β)</code> is uniformly continuous.</li>
</ul><h4 class="markdown-heading" id="Isomorphism-statements-bundled">Isomorphism statements (bundled) <a class="hover-link" href="#Isomorphism-statements-bundled">#</a></h4><ul>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.congrRight">UniformOnFun.congrRight</a></code>: turn a uniform isomorphism <code>γ ≃ᵤ β</code> into a uniform isomorphism
<code>(α →ᵤ[𝔖] γ) ≃ᵤ (α →ᵤ[𝔖] β)</code> by post-composing.</li>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.congrLeft">UniformOnFun.congrLeft</a></code>: turn a bijection <code>e : γ ≃ α</code> such that we have both
<code>∀ T ∈ 𝔗, e '' T ∈ 𝔖</code> and <code>∀ S ∈ 𝔖, e ⁻¹' S ∈ 𝔗</code> into a uniform isomorphism
<code>(γ →ᵤ[𝔗] β) ≃ᵤ (α →ᵤ[𝔖] β)</code> by pre-composing.</li>
<li><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformEquivPiComm">UniformOnFun.uniformEquivPiComm</a></code>: the natural bijection between <code>α → Π i, δ i</code>
and <code>Π i, α → δ i</code>, upgraded to a uniform isomorphism between <code>α →ᵤ[𝔖] (Π i, δ i)</code> and
<code>Π i, α →ᵤ[𝔖] δ i</code>.</li>
</ul><h4 class="markdown-heading" id="Important-use-cases">Important use cases <a class="hover-link" href="#Important-use-cases">#</a></h4><ul>
<li>If <code>G</code> is a uniform group, then <code>α →ᵤ[𝔖] G</code> is a uniform group: since <code>(/) : G × G → G</code> is
uniformly continuous, <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.postcomp_uniformContinuous">UniformOnFun.postcomp_uniformContinuous</a></code> tells us that
<code>((/) ∘ —) : (α →ᵤ[𝔖] G × G) → (α →ᵤ[𝔖] G)</code> is uniformly continuous. By precomposing with
<code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformEquivProdArrow">UniformOnFun.uniformEquivProdArrow</a></code>, this gives that
<code>(/) : (α →ᵤ[𝔖] G) × (α →ᵤ[𝔖] G) → (α →ᵤ[𝔖] G)</code> is also uniformly continuous</li>
<li>The transpose of a continuous linear map is continuous for the strong topologies: since
continuous linear maps are uniformly continuous and map bounded sets to bounded sets,
this is just a special case of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.precomp_uniformContinuous">UniformOnFun.precomp_uniformContinuous</a></code>.</li>
</ul><h2 class="markdown-heading" id="TODO">TODO <a class="hover-link" href="#TODO">#</a></h2><ul>
<li>Show that the uniform structure of <code>𝔖</code>-convergence is exactly the structure of <code>𝔖'</code>-convergence,
where <code>𝔖'</code> is the <em><strong>noncovering</strong></em> bornology (i.e <em><strong>not</strong></em> what <code><a href="../../.././Mathlib/Topology/Bornology/Basic.html#Bornology">Bornology</a></code> currently refers
to in mathlib) generated by <code>𝔖</code>.</li>
</ul><h2 class="markdown-heading" id="References">References <a class="hover-link" href="#References">#</a></h2><ul>
<li>[N. Bourbaki, <em>General Topology, Chapter X</em>][bourbaki1966]</li>
</ul><h2 class="markdown-heading" id="Tags">Tags <a class="hover-link" href="#Tags">#</a></h2><p>uniform convergence</p></div><div class="decl" id="UniformFun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L146-L147">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun"><span class="name">UniformFun</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a> (max u_1 u_2)</div></div><p>The type of functions from <code>α</code> to <code>β</code> equipped with the uniform structure and topology of
uniform convergence. We denote it <code>α →ᵤ β</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span></li></ul></details><details id="instances-for-list-UniformFun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformOnFun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L153-L154">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun"><span class="name">UniformOnFun</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span> → <a href="../../.././foundational_types.html">Type</a> (max u_1 u_2)</span></div></div><p>The type of functions from <code>α</code> to <code>β</code> equipped with the uniform structure and topology of
uniform convergence on some family <code>𝔖</code> of subsets of <code>α</code>. We denote it <code>α →ᵤ[𝔖] β</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span></li></ul></details><details id="instances-for-list-UniformOnFun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformConvergence.«term_→ᵤ_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L157-L157">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformConvergence.«term_→ᵤ_»"><span class="name">UniformConvergence</span>.<span class="name">«term_→ᵤ_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-UniformConvergence.«term_→ᵤ_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformConvergence.«term_→ᵤ[_]_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L159-L159">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformConvergence.«term_→ᵤ[_]_»"><span class="name">UniformConvergence</span>.<span class="name">«term_→ᵤ[_]_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-UniformConvergence.«term_→ᵤ[_]_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="instNonemptyUniformFun"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L170-L170">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#instNonemptyUniformFun"><span class="name">instNonemptyUniformFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(_ : <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="instNonemptyUniformOnFun"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L172-L172">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#instNonemptyUniformOnFun"><span class="name">instNonemptyUniformOnFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span>)</span></span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(_ : <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="UniformFun.ofFun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L175-L176">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.ofFun"><span class="name">UniformFun</span>.<span class="name">ofFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span> <a href="../../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span></span></div></div><p>Reinterpret <code>f : α → β</code> as an element of <code>α →ᵤ β</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-UniformFun.ofFun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformOnFun.ofFun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L180-L181">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.ofFun"><span class="name">UniformOnFun</span>.<span class="name">ofFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span> <a href="../../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span></span></div></div><p>Reinterpret <code>f : α → β</code> as an element of <code>α →ᵤ[𝔖] β</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-UniformOnFun.ofFun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformFun.toFun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L185-L186">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.toFun"><span class="name">UniformFun</span>.<span class="name">toFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span> <a href="../../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> <span class="fn">(<span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span></div></div><p>Reinterpret <code>f : α →ᵤ β</code> as an element of <code>α → β</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">UniformFun.toFun</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">UniformFun.ofFun</span>.symm</span></span></li></ul></details><details id="instances-for-list-UniformFun.toFun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformOnFun.toFun"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L190-L191">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun"><span class="name">UniformOnFun</span>.<span class="name">toFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span> <a href="../../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> <span class="fn">(<span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span></div></div><p>Reinterpret <code>f : α →ᵤ[𝔖] β</code> as an element of <code>α → β</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">UniformOnFun.toFun</a> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.ofFun">UniformOnFun.ofFun</a> <span class="fn">𝔖</span></span>)</span>.symm</span></span></li></ul></details><details id="instances-for-list-UniformOnFun.toFun" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformFun.toFun_ofFun"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L194-L194">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.toFun_ofFun"><span class="name">UniformFun</span>.<span class="name">toFun_ofFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">UniformFun.toFun</span> <span class="fn">(<span class="fn"><span class="fn">UniformFun.ofFun</span> <span class="fn">f</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="UniformFun.ofFun_toFun"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L195-L195">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.ofFun_toFun"><span class="name">UniformFun</span>.<span class="name">ofFun_toFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">UniformFun.ofFun</span> <span class="fn">(<span class="fn"><span class="fn">UniformFun.toFun</span> <span class="fn">f</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="UniformOnFun.toFun_ofFun"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L196-L196">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun_ofFun"><span class="name">UniformOnFun</span>.<span class="name">toFun_ofFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">UniformOnFun.toFun</a> <span class="fn">𝔖</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.ofFun">UniformOnFun.ofFun</a> <span class="fn">𝔖</span></span>)</span> <span class="fn">f</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="UniformOnFun.ofFun_toFun"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L197-L197">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.ofFun_toFun"><span class="name">UniformOnFun</span>.<span class="name">ofFun_toFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.ofFun">UniformOnFun.ofFun</a> <span class="fn">𝔖</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">UniformOnFun.toFun</a> <span class="fn">𝔖</span></span>)</span> <span class="fn">f</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="UniformFun.gen"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L213-L214">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gen"><span class="name">UniformFun</span>.<span class="name">gen</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="decl_args">
<span class="fn">(V : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span></span>)</span></span></div></div><p>Basis sets for the uniformity of uniform convergence: <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gen">gen</a> α β V</code> is the set of pairs <code>(f, g)</code>
of functions <code>α →ᵤ β</code> such that <code>∀ x, (f x, g x) ∈ V</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gen">UniformFun.gen</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">V</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{<span class="fn">uv</span> : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span></span> | <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">(<span class="fn"><span class="fn">UniformFun.toFun</span> <span class="fn"><span class="fn">uv</span>.1</span> <span class="fn">x</span></span>, <span class="fn"><span class="fn">UniformFun.toFun</span> <span class="fn"><span class="fn">uv</span>.2</span> <span class="fn">x</span></span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">V</span></span></span>}</span></span></li></ul></details><details id="instances-for-list-UniformFun.gen" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformFun.isBasis_gen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L221-L224">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.isBasis_gen"><span class="name">UniformFun</span>.<span class="name">isBasis_gen</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="decl_args">
<span class="fn">(𝓑 : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Basic.html#Filter">Filter</a> <span class="fn">(<span class="fn"><span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Bases.html#Filter.IsBasis">Filter.IsBasis</a> <span class="fn">(<span class="fn">fun (<span class="fn">V</span> : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span>) =&gt; <span class="fn"><span class="fn">V</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">𝓑</span></span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gen">UniformFun.gen</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span></div></div><p>If <code>𝓕</code> is a filter on <code>β × β</code>, then the set of all <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gen">UniformFun.gen</a> α β V</code> for
<code>V ∈ 𝓕</code> is a filter basis on <code>(α →ᵤ β) × (α →ᵤ β)</code>. This will only be applied to <code>𝓕 = 𝓤 β</code> when
<code>β</code> is equipped with a <code><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a></code> structure, but it is useful to define it for any filter in
order to be able to state that it has a lower adjoint (see <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gc">UniformFun.gc</a></code>).</p></div></div><div class="decl" id="UniformFun.basis"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L232-L233">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.basis"><span class="name">UniformFun</span>.<span class="name">basis</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="decl_args">
<span class="fn">(𝓕 : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Basic.html#Filter">Filter</a> <span class="fn">(<span class="fn"><span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Bases.html#FilterBasis">FilterBasis</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span></span>)</span></span></div></div><p>For <code>𝓕 : <a href="../../.././Mathlib/Order/Filter/Basic.html#Filter">Filter</a> (β × β)</code>, this is the set of all <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gen">UniformFun.gen</a> α β V</code> for
<code>V ∈ 𝓕</code> as a bundled <code><a href="../../.././Mathlib/Order/Filter/Bases.html#FilterBasis">FilterBasis</a></code> over <code>(α →ᵤ β) × (α →ᵤ β)</code>. This will only be applied to
<code>𝓕 = 𝓤 β</code> when <code>β</code> is equipped with a <code><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a></code> structure, but it is useful to define it for
any filter in order to be able to state that it has a lower adjoint
(see <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gc">UniformFun.gc</a></code>).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.basis">UniformFun.basis</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝓕</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/Order/Filter/Bases.html#Filter.IsBasis.filterBasis">Filter.IsBasis.filterBasis</a> <span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Bases.html#Filter.IsBasis">Filter.IsBasis</a> <span class="fn">(<span class="fn">fun (<span class="fn">V</span> : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span>) =&gt; <span class="fn"><span class="fn">V</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">𝓕</span></span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gen">UniformFun.gen</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-UniformFun.basis" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformFun.filter"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L239-L240">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.filter"><span class="name">UniformFun</span>.<span class="name">filter</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="decl_args">
<span class="fn">(𝓕 : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Basic.html#Filter">Filter</a> <span class="fn">(<span class="fn"><span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Basic.html#Filter">Filter</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span></span>)</span></span></div></div><p>For <code>𝓕 : <a href="../../.././Mathlib/Order/Filter/Basic.html#Filter">Filter</a> (β × β)</code>, this is the filter generated by the filter basis
<code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.basis">UniformFun.basis</a> α β 𝓕</code>. For <code>𝓕 = 𝓤 β</code>, this will be the uniformity of uniform
convergence on <code>α</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.filter">UniformFun.filter</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝓕</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Order/Filter/Bases.html#FilterBasis.filter">FilterBasis.filter</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.basis">UniformFun.basis</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝓕</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-UniformFun.filter" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformFun.phi"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L247-L248">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.phi"><span class="name">UniformFun</span>.<span class="name">phi</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u_5)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href="../../.././foundational_types.html">Type</a> u_6)</span></span>
<span class="decl_args">
<span class="fn">(uvx : <span class="fn"><span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span></span>)</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.phi">UniformFun.phi</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">uvx</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">uvx</span>.1</span>.1 <span class="fn"><span class="fn">uvx</span>.2</span></span>, <span class="fn"><span class="fn"><span class="fn">uvx</span>.1</span>.2 <span class="fn"><span class="fn">uvx</span>.2</span></span>)</span></span></li></ul></details><details id="instances-for-list-UniformFun.phi" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformFun.gc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L264-L279">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gc"><span class="name">UniformFun</span>.<span class="name">gc</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/GaloisConnection.html#GaloisConnection">GaloisConnection</a> <span class="fn">(<span class="fn">fun (<span class="fn">𝓐</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Basic.html#Filter">Filter</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span></span>)</span></span>) =&gt; <span class="fn"><a href="../../.././Mathlib/Order/Filter/Basic.html#Filter.map">Filter.map</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.phi">UniformFun.phi</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">𝓐</span> <a href="../../.././Mathlib/Data/SProd.html#SProd.sprod">×ˢ</a> <a href="../../.././Mathlib/Order/Notation.html#Top.top">⊤</a></span>)</span></span></span>)</span>
  <span class="fn">fun (<span class="fn">𝓕</span> : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Basic.html#Filter">Filter</a> <span class="fn">(<span class="fn"><span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span>) =&gt; <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.filter">UniformFun.filter</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝓕</span></span></span></span></div></div><p>The function <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.filter">UniformFun.filter</a> α β : <a href="../../.././Mathlib/Order/Filter/Basic.html#Filter">Filter</a> (β × β) → <a href="../../.././Mathlib/Order/Filter/Basic.html#Filter">Filter</a> ((α →ᵤ β) × (α →ᵤ β))</code>
has a lower adjoint <code>l</code> (in the sense of <code><a href="../../.././Mathlib/Order/GaloisConnection.html#GaloisConnection">GaloisConnection</a></code>). The exact definition of <code>l</code> is not
interesting; we will only use that it exists (in <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.mono">UniformFun.mono</a></code> and
<code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.iInf_eq">UniformFun.iInf_eq</a></code>) and that
<code>l (Filter.map (Prod.map f f) 𝓕) = <a href="../../.././Mathlib/Order/Filter/Basic.html#Filter.map">Filter.map</a> (Prod.map ((∘) f) ((∘) f)) (l 𝓕)</code> for each
<code>𝓕 : <a href="../../.././Mathlib/Order/Filter/Basic.html#Filter">Filter</a> (γ × γ)</code> and <code>f : γ → α</code> (in <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.comap_eq">UniformFun.comap_eq</a></code>).</p></div></div><div class="decl" id="UniformFun.uniformCore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L285-L295">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformCore"><span class="name">UniformFun</span>.<span class="name">uniformCore</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace.Core">UniformSpace.Core</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span></div></div><p>Core of the uniform structure of uniform convergence.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-UniformFun.uniformCore" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformFun.uniformSpace"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L300-L301">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace"><span class="name">UniformFun</span>.<span class="name">uniformSpace</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span></div></div><p>Uniform structure of uniform convergence, declared as an instance on <code>α →ᵤ β</code>.
We will denote it <code>𝒰(α, β, uβ)</code> in the rest of this file.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace">UniformFun.uniformSpace</a> <span class="fn">α</span> <span class="fn">β</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace.ofCore">UniformSpace.ofCore</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformCore">UniformFun.uniformCore</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span></span></li></ul></details></div></div><div class="decl" id="UniformFun.topologicalSpace"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L304-L305">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.topologicalSpace"><span class="name">UniformFun</span>.<span class="name">topologicalSpace</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span></div></div><p>Topology of uniform convergence, declared as an instance on <code>α →ᵤ β</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.topologicalSpace">UniformFun.topologicalSpace</a> <span class="fn">α</span> <span class="fn">β</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">inferInstance</span></span></li></ul></details></div></div><div class="decl" id="UniformFun.hasBasis_uniformity"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L312-L314">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.hasBasis_uniformity"><span class="name">UniformFun</span>.<span class="name">hasBasis_uniformity</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Bases.html#Filter.HasBasis">Filter.HasBasis</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>)</span> <span class="fn">(<span class="fn">fun (<span class="fn">x</span> : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span></span></span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gen">UniformFun.gen</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span></div></div><p>By definition, the uniformity of <code>α →ᵤ β</code> admits the family <code>{(f, g) | ∀ x, (f x, g x) ∈ V}</code>
for <code>V ∈ 𝓤 β</code> as a filter basis.</p></div></div><div class="decl" id="UniformFun.hasBasis_uniformity_of_basis"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L320-L326">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.hasBasis_uniformity_of_basis"><span class="name">UniformFun</span>.<span class="name">hasBasis_uniformity_of_basis</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../.././foundational_types.html">Sort</a> u_5}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Bases.html#Filter.HasBasis">Filter.HasBasis</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span></span>)</span> <span class="fn">p</span> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Bases.html#Filter.HasBasis">Filter.HasBasis</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>)</span> <span class="fn">p</span> <span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gen">UniformFun.gen</a> <span class="fn">α</span> <span class="fn">β</span></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">s</span></span>)</span></span></div></div><p>The uniformity of <code>α →ᵤ β</code> admits the family <code>{(f, g) | ∀ x, (f x, g x) ∈ V}</code> for <code>V ∈ 𝓑</code> as
a filter basis, for any basis <code>𝓑</code> of <code>𝓤 β</code> (in the case <code>𝓑 = (𝓤 β).as_basis</code> this is true by
definition).</p></div></div><div class="decl" id="UniformFun.hasBasis_nhds_of_basis"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L331-L334">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.hasBasis_nhds_of_basis"><span class="name">UniformFun</span>.<span class="name">hasBasis_nhds_of_basis</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Bases.html#Filter.HasBasis">Filter.HasBasis</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span></span>)</span> <span class="fn">p</span> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Bases.html#Filter.HasBasis">Filter.HasBasis</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/Basic.html#nhds">nhds</a> <span class="fn">f</span></span>)</span> <span class="fn">p</span> <span class="fn">fun (<span class="fn">i</span> : <span class="fn">ι</span>) =&gt; <span class="fn">{<span class="fn">g</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span> | <span class="fn"><span class="fn">(<span class="fn">f</span>, <span class="fn">g</span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gen">UniformFun.gen</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">(<span class="fn"><span class="fn">s</span> <span class="fn">i</span></span>)</span></span></span>}</span></span></span></div></div><p>For <code>f : α →ᵤ β</code>, <code>𝓝 f</code> admits the family <code>{g | ∀ x, (f x, g x) ∈ V}</code> for <code>V ∈ 𝓑</code> as a filter
basis, for any basis <code>𝓑</code> of <code>𝓤 β</code>.</p></div></div><div class="decl" id="UniformFun.hasBasis_nhds"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L339-L341">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.hasBasis_nhds"><span class="name">UniformFun</span>.<span class="name">hasBasis_nhds</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Bases.html#Filter.HasBasis">Filter.HasBasis</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/Basic.html#nhds">nhds</a> <span class="fn">f</span></span>)</span> <span class="fn">(<span class="fn">fun (<span class="fn">V</span> : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span>) =&gt; <span class="fn"><span class="fn">V</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span></span></span></span>)</span> <span class="fn">fun (<span class="fn">V</span> : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span>) =&gt;
  <span class="fn">{<span class="fn">g</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span> | <span class="fn"><span class="fn">(<span class="fn">f</span>, <span class="fn">g</span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gen">UniformFun.gen</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">V</span></span></span>}</span></span></span></div></div><p>For <code>f : α →ᵤ β</code>, <code>𝓝 f</code> admits the family <code>{g | ∀ x, (f x, g x) ∈ V}</code> for <code>V ∈ 𝓤 β</code> as a
filter basis.</p></div></div><div class="decl" id="UniformFun.uniformContinuous_eval"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L347-L352">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformContinuous_eval"><span class="name">UniformFun</span>.<span class="name">uniformContinuous_eval</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(β : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.eval">Function.eval</a> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<span class="fn">UniformFun.toFun</span></span></span>)</span></span></div></div><p>Evaluation at a fixed point is uniformly continuous on <code>α →ᵤ β</code>.</p></div></div><div class="decl" id="UniformFun.mem_gen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L358-L360">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.mem_gen"><span class="name">UniformFun</span>.<span class="name">mem_gen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{V : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn">f</span>, <span class="fn">g</span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gen">UniformFun.gen</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">V</span></span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ (<span class="fn">x</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">(<span class="fn"><span class="fn">UniformFun.toFun</span> <span class="fn">f</span> <span class="fn">x</span></span>, <span class="fn"><span class="fn">UniformFun.toFun</span> <span class="fn">g</span> <span class="fn">x</span></span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">V</span></span></span></span></div></div></div></div><div class="decl" id="UniformFun.mono"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L364-L365">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.mono"><span class="name">UniformFun</span>.<span class="name">mono</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Monotone/Basic.html#Monotone">Monotone</a> <span class="fn">(<span class="fn">@<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace">UniformFun.uniformSpace</a> <span class="fn">α</span> <span class="fn">γ</span></span>)</span></span></div></div><p>If <code>u₁</code> and <code>u₂</code> are two uniform structures on <code>γ</code> and <code>u₁ ≤ u₂</code>, then
<code>𝒰(α, γ, u₁) ≤ 𝒰(α, γ, u₂)</code>.</p></div></div><div class="decl" id="UniformFun.iInf_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L370-L376">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.iInf_eq"><span class="name">UniformFun</span>.<span class="name">iInf_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace">UniformFun.uniformSpace</a> <span class="fn">α</span> <span class="fn">γ</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⨅ (i : <span class="fn">ι</span>), <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace">UniformFun.uniformSpace</a> <span class="fn">α</span> <span class="fn">γ</span></span></span></span></div></div><p>If <code>u</code> is a family of uniform structures on <code>γ</code>, then
<code>𝒰(α, γ, (⨅ i, u i)) = ⨅ i, 𝒰(α, γ, u i)</code>.</p></div></div><div class="decl" id="UniformFun.inf_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L381-L387">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.inf_eq"><span class="name">UniformFun</span>.<span class="name">inf_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u₁ : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u₂ : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace">UniformFun.uniformSpace</a> <span class="fn">α</span> <span class="fn">γ</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace">UniformFun.uniformSpace</a> <span class="fn">α</span> <span class="fn">γ</span></span> <a href="../../.././Mathlib/Order/Notation.html#Inf.inf">⊓</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace">UniformFun.uniformSpace</a> <span class="fn">α</span> <span class="fn">γ</span></span></span></span></div></div><p>If <code>u₁</code> and <code>u₂</code> are two uniform structures on <code>γ</code>, then
<code>𝒰(α, γ, u₁ ⊓ u₂) = 𝒰(α, γ, u₁) ⊓ 𝒰(α, γ, u₂)</code>.</p></div></div><div class="decl" id="UniformFun.postcomp_uniformInducing"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L395-L398">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.postcomp_uniformInducing"><span class="name">UniformFun</span>.<span class="name">postcomp_uniformInducing</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">γ</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformInducing">UniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformInducing">UniformInducing</a> <span class="fn">(<span class="fn"><span class="fn">⇑<span class="fn">UniformFun.ofFun</span></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn"><span class="fn">(<span class="fn">fun (<span class="fn">x</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">x</span></span></span>)</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<span class="fn">UniformFun.toFun</span></span></span></span>)</span></span></div></div><p>Post-composition by a uniform inducing function is
a uniform inducing function for the uniform structures of uniform convergence.</p><p>More precisely, if <code>f : γ → β</code> is uniform inducing,
then <code>(f ∘ ·) : (α →ᵤ γ) → (α →ᵤ β)</code> is uniform inducing.</p></div></div><div class="decl" id="UniformFun.comap_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L404-L407">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.comap_eq"><span class="name">UniformFun</span>.<span class="name">comap_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">γ</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace">UniformFun.uniformSpace</a> <span class="fn">α</span> <span class="fn">γ</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace.comap">UniformSpace.comap</a> <span class="fn">(<span class="fn">fun (<span class="fn">x</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">x</span></span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace">UniformFun.uniformSpace</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span></span></div></div><p>If <code>u</code> is a uniform structures on <code>β</code> and <code>f : γ → β</code>, then
<code>𝒰(α, γ, comap f u) = comap (fun g ↦ f ∘ g) 𝒰(α, γ, u₁)</code>.</p></div></div><div class="decl" id="UniformFun.postcomp_uniformContinuous"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L414-L419">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.postcomp_uniformContinuous"><span class="name">UniformFun</span>.<span class="name">postcomp_uniformContinuous</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">γ</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">(<span class="fn"><span class="fn">⇑<span class="fn">UniformFun.ofFun</span></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn"><span class="fn">(<span class="fn">fun (<span class="fn">x</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">x</span></span></span>)</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<span class="fn">UniformFun.toFun</span></span></span></span>)</span></span></div></div><p>Post-composition by a uniformly continuous function is uniformly continuous on <code>α →ᵤ β</code>.</p><p>More precisely, if <code>f : γ → β</code> is uniformly continuous, then <code>(fun g ↦ f ∘ g) : (α →ᵤ γ) → (α →ᵤ β)</code>
is uniformly continuous.</p></div></div><div class="decl" id="UniformFun.congrRight"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L429-L432">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.congrRight"><span class="name">UniformFun</span>.<span class="name">congrRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">γ</span> <a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#UniformEquiv">≃ᵤ</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">γ</span></span> <a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#UniformEquiv">≃ᵤ</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span></span></div></div><p>Turn a uniform isomorphism <code>γ ≃ᵤ β</code> into a uniform isomorphism <code>(α →ᵤ γ) ≃ᵤ (α →ᵤ β)</code> by
post-composing.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-UniformFun.congrRight" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformFun.precomp_uniformContinuous"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L440-L448">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.precomp_uniformContinuous"><span class="name">UniformFun</span>.<span class="name">precomp_uniformContinuous</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">γ</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">fun (<span class="fn">g</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span>) =&gt; <span class="fn"><span class="fn">UniformFun.ofFun</span> <span class="fn">(<span class="fn"><span class="fn"><span class="fn">UniformFun.toFun</span> <span class="fn">g</span></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">f</span></span>)</span></span></span></span></div></div><p>Pre-composition by any function is uniformly continuous for the uniform structures of
uniform convergence.</p><p>More precisely, for any <code>f : γ → α</code>, the function <code>(· ∘ f) : (α →ᵤ β) → (γ →ᵤ β)</code> is uniformly
continuous.</p></div></div><div class="decl" id="UniformFun.congrLeft"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L453-L456">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.congrLeft"><span class="name">UniformFun</span>.<span class="name">congrLeft</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">γ</span> <a href="../../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">γ</span> <span class="fn">β</span></span> <a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#UniformEquiv">≃ᵤ</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span></span></div></div><p>Turn a bijection <code>γ ≃ α</code> into a uniform isomorphism
<code>(γ →ᵤ β) ≃ᵤ (α →ᵤ β)</code> by pre-composing.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-UniformFun.congrLeft" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformFun.uniformContinuous_toFun"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L463-L467">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformContinuous_toFun"><span class="name">UniformFun</span>.<span class="name">uniformContinuous_toFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">⇑<span class="fn">UniformFun.toFun</span></span></span></div></div><p>The natural map <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.toFun">UniformFun.toFun</a></code> from <code>α →ᵤ β</code> to <code>α → β</code> is uniformly continuous.</p><p>In other words, the uniform structure of uniform convergence is finer than that of pointwise
convergence, aka the product uniform structure.</p></div></div><div class="decl" id="UniformFun.instT2SpaceUniformFunTopologicalSpace"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L471-L472">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.instT2SpaceUniformFunTopologicalSpace"><span class="name">UniformFun</span>.<span class="name">instT2SpaceUniformFunTopologicalSpace</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Separation.html#T2Space">T2Space</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Separation.html#T2Space">T2Space</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span></div></div><p>The topology of uniform convergence is T₂.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/Topology/Separation.html#T2Space">T2Space</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/Topology/Separation.html#T2Space">T2Space</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span>)</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="UniformFun.tendsto_iff_tendstoUniformly"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L476-L479">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.tendsto_iff_tendstoUniformly"><span class="name">UniformFun</span>.<span class="name">tendsto_iff_tendstoUniformly</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Basic.html#Filter">Filter</a> <span class="fn">ι</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Basic.html#Filter.Tendsto">Filter.Tendsto</a> <span class="fn">F</span> <span class="fn">p</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/Basic.html#nhds">nhds</a> <span class="fn">f</span></span>)</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergence.html#TendstoUniformly">TendstoUniformly</a> <span class="fn">(<span class="fn"><span class="fn">⇑<span class="fn">UniformFun.toFun</span></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">F</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">UniformFun.toFun</span> <span class="fn">f</span></span>)</span> <span class="fn">p</span></span></span></div></div><p>The topology of uniform convergence indeed gives the same notion of convergence as
<code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergence.html#TendstoUniformly">TendstoUniformly</a></code>.</p></div></div><div class="decl" id="UniformFun.uniformEquivProdArrow"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L484-L502">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformEquivProdArrow"><span class="name">UniformFun</span>.<span class="name">uniformEquivProdArrow</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">(<span class="fn"><span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">γ</span></span>)</span></span> <a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#UniformEquiv">≃ᵤ</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">β</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">γ</span></span></span></span></div></div><p>The natural bijection between <code>α → β × γ</code> and <code>(α → β) × (α → γ)</code>, upgraded to a uniform
isomorphism between <code>α →ᵤ β × γ</code> and <code>(α →ᵤ β) × (α →ᵤ γ)</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">UniformFun.uniformEquivProdArrow</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#Equiv.toUniformEquivOfUniformInducing">Equiv.toUniformEquivOfUniformInducing</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Logic/Equiv/Basic.html#Equiv.arrowProdEquivProdArrow">Equiv.arrowProdEquivProdArrow</a> <span class="fn">β</span> <span class="fn">γ</span> <span class="fn">α</span></span>)</span>
    <span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformInducing">UniformInducing</a> <span class="fn">⇑<span class="fn">(<span class="fn"><a href="../../.././Mathlib/Logic/Equiv/Basic.html#Equiv.arrowProdEquivProdArrow">Equiv.arrowProdEquivProdArrow</a> <span class="fn">β</span> <span class="fn">γ</span> <span class="fn">α</span></span>)</span></span></span>)</span></span></span></li></ul></details><details id="instances-for-list-UniformFun.uniformEquivProdArrow" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformFun.uniformEquivPiComm"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L510-L528">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformEquivPiComm"><span class="name">UniformFun</span>.<span class="name">uniformEquivPiComm</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="decl_args">
<span class="fn">(δ : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Type</a> u_5</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">(<span class="fn"><span class="fn">δ</span> <span class="fn">i</span></span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">(<span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><span class="fn">δ</span> <span class="fn">i</span></span></span>)</span></span> <a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#UniformEquiv">≃ᵤ</a> <span class="fn">(<span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun">UniformFun</a> <span class="fn">α</span> <span class="fn">(<span class="fn"><span class="fn">δ</span> <span class="fn">i</span></span>)</span></span></span>)</span></span></div></div><p>The natural bijection between <code>α → Π i, δ i</code> and <code>Π i, α → δ i</code>, upgraded to a uniform
isomorphism between <code>α →ᵤ (Π i, δ i)</code> and <code>Π i, α →ᵤ δ i</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformEquivPiComm">UniformFun.uniformEquivPiComm</a> <span class="fn">α</span> <span class="fn">δ</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#Equiv.toUniformEquivOfUniformInducing">Equiv.toUniformEquivOfUniformInducing</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Logic/Equiv/Basic.html#Equiv.piComm">Equiv.piComm</a> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">i</span> : <span class="fn">ι</span>) =&gt; <span class="fn"><span class="fn">δ</span> <span class="fn">i</span></span></span></span>)</span>
    <span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformInducing">UniformInducing</a> <span class="fn">⇑<span class="fn">(<span class="fn"><a href="../../.././Mathlib/Logic/Equiv/Basic.html#Equiv.piComm">Equiv.piComm</a> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">i</span> : <span class="fn">ι</span>) =&gt; <span class="fn"><span class="fn">δ</span> <span class="fn">i</span></span></span></span>)</span></span></span>)</span></span></span></li></ul></details><details id="instances-for-list-UniformFun.uniformEquivPiComm" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformOnFun.gen"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L547-L548">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen"><span class="name">UniformOnFun</span>.<span class="name">gen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(S : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(V : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span></span>)</span></span></div></div><p>Basis sets for the uniformity of <code>𝔖</code>-convergence: for <code>S : <a href="../../.././Mathlib/Init/Set.html#Set">Set</a> α</code> and <code>V : <a href="../../.././Mathlib/Init/Set.html#Set">Set</a> (β × β)</code>,
<code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gen">gen</a> 𝔖 S V</code> is the set of pairs <code>(f, g)</code> of functions <code>α →ᵤ[𝔖] β</code> such that
<code>∀ x ∈ S, (f x, g x) ∈ V</code>. Note that the family <code>𝔖 : <a href="../../.././Mathlib/Init/Set.html#Set">Set</a> (Set α)</code> is only used to specify which
type alias of <code>α → β</code> to use here.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> <span class="fn">𝔖</span> <span class="fn">S</span> <span class="fn">V</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{<span class="fn">uv</span> : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span></span> |
    <span class="fn">∀ <span class="fn">x</span> ∈ <span class="fn">S</span>, <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">UniformOnFun.toFun</a> <span class="fn">𝔖</span></span>)</span> <span class="fn"><span class="fn">uv</span>.1</span> <span class="fn">x</span></span>, <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">UniformOnFun.toFun</a> <span class="fn">𝔖</span></span>)</span> <span class="fn"><span class="fn">uv</span>.2</span> <span class="fn">x</span></span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">V</span></span></span>}</span></span></li></ul></details><details id="instances-for-list-UniformOnFun.gen" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformOnFun.gen_eq_preimage_restrict"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L556-L561">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen_eq_preimage_restrict"><span class="name">UniformOnFun</span>.<span class="name">gen_eq_preimage_restrict</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(S : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(V : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> <span class="fn">𝔖</span> <span class="fn">S</span> <span class="fn">V</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn"><a href="../../.././Init/Core.html#Prod.map">Prod.map</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Function.html#Set.restrict">Set.restrict</a> <span class="fn">S</span></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<span class="fn">UniformFun.toFun</span></span></span>)</span> <span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Function.html#Set.restrict">Set.restrict</a> <span class="fn">S</span></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<span class="fn">UniformFun.toFun</span></span></span>)</span></span> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.preimage">⁻¹'</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gen">UniformFun.gen</a> <span class="fn">(<span class="fn">↑<span class="fn">S</span></span>)</span> <span class="fn">β</span> <span class="fn">V</span></span></span></span></div></div><p>For <code>S : <a href="../../.././Mathlib/Init/Set.html#Set">Set</a> α</code> and <code>V : <a href="../../.././Mathlib/Init/Set.html#Set">Set</a> (β × β)</code>, we have
<code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> 𝔖 S V = (S.restrict × S.restrict) ⁻¹' (UniformFun.<a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.gen">gen</a> S β V)</code>.
This is the crucial fact for proving that the family <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> S V</code> for <code>S ∈ 𝔖</code> and
<code>V ∈ 𝓤 β</code> is indeed a basis for the uniformity <code>α →ᵤ[𝔖] β</code> endowed with <code>𝒱(α, β, 𝔖, uβ)</code>
the uniform structure of <code>𝔖</code>-convergence, as defined in <code>UniformOnFun.uniform_space</code>.</p></div></div><div class="decl" id="UniformOnFun.gen_mono"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L565-L566">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen_mono"><span class="name">UniformOnFun</span>.<span class="name">gen_mono</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S' : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{V : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{V' : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hS : <span class="fn"><span class="fn">S'</span> <a href="../../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn">S</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hV : <span class="fn"><span class="fn">V</span> <a href="../../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn">V'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> <span class="fn">𝔖</span> <span class="fn">S</span> <span class="fn">V</span></span> <a href="../../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> <span class="fn">𝔖</span> <span class="fn">S'</span> <span class="fn">V'</span></span></span></div></div><p><code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a></code> is antitone in the first argument and monotone in the second.</p></div></div><div class="decl" id="UniformOnFun.isBasis_gen"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L574-L583">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.isBasis_gen"><span class="name">UniformOnFun</span>.<span class="name">isBasis_gen</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="decl_args">
<span class="fn">(𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set.Nonempty">Set.Nonempty</a> <span class="fn">𝔖</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h' : <span class="fn"><a href="../../.././Mathlib/Order/Directed.html#DirectedOn">DirectedOn</a> <span class="fn">(<span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn">x_1</span></span></span>)</span> <span class="fn">𝔖</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(𝓑 : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Bases.html#FilterBasis">FilterBasis</a> <span class="fn">(<span class="fn"><span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Bases.html#Filter.IsBasis">Filter.IsBasis</a> <span class="fn">(<span class="fn">fun (<span class="fn">SV</span> : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span></span>) =&gt; <span class="fn"><span class="fn"><span class="fn"><span class="fn">SV</span>.1</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn">SV</span>.2</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">𝓑</span></span></span></span>)</span> <span class="fn">fun (<span class="fn">SV</span> : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span></span>) =&gt;
  <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> <span class="fn">𝔖</span> <span class="fn"><span class="fn">SV</span>.1</span> <span class="fn"><span class="fn">SV</span>.2</span></span></span></span></div></div><p>If <code>𝔖 : <a href="../../.././Mathlib/Init/Set.html#Set">Set</a> (Set α)</code> is nonempty and directed and <code>𝓑</code> is a filter basis on <code>β × β</code>, then the
family <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> 𝔖 S V</code> for <code>S ∈ 𝔖</code> and <code>V ∈ 𝓑</code> is a filter basis on
<code>(α →ᵤ[𝔖] β) × (α →ᵤ[𝔖] β)</code>.
We will show in <code>has_basis_uniformity_of_basis</code> that, if <code>𝓑</code> is a basis for <code>𝓤 β</code>, then the
corresponding filter is the uniformity of <code>α →ᵤ[𝔖] β</code>.</p></div></div><div class="decl" id="UniformOnFun.uniformSpace"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L592-L593">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace"><span class="name">UniformOnFun</span>.<span class="name">uniformSpace</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span>)</span></span></div></div><p>Uniform structure of <code>𝔖</code>-convergence, i.e uniform convergence on the elements of <code>𝔖</code>,
declared as an instance on <code>α →ᵤ[𝔖] β</code>. It is defined as the infimum, for <code>S ∈ 𝔖</code>, of the pullback
by <code>S.restrict</code>, the map of restriction to <code>S</code>, of the uniform structure <code>𝒰(s, β, uβ)</code> on
<code>↥S →ᵤ β</code>. We will denote it <code>𝒱(α, β, 𝔖, uβ)</code>, where <code>uβ</code> is the uniform structure on <code>β</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace">UniformOnFun.uniformSpace</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⨅ s ∈ <span class="fn">𝔖</span>, <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace.comap">UniformSpace.comap</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Set/Function.html#Set.restrict">Set.restrict</a> <span class="fn">s</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace">UniformFun.uniformSpace</a> <span class="fn">(<span class="fn">↑<span class="fn">s</span></span>)</span> <span class="fn">β</span></span>)</span></span></span></span></li></ul></details></div></div><div class="decl" id="UniformOnFun.topologicalSpace"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L599-L600">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.topologicalSpace"><span class="name">UniformOnFun</span>.<span class="name">topologicalSpace</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Basic.html#TopologicalSpace">TopologicalSpace</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span>)</span></span></div></div><p>Topology of <code>𝔖</code>-convergence, i.e uniform convergence on the elements of <code>𝔖</code>, declared as an
instance on <code>α →ᵤ[𝔖] β</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.topologicalSpace">UniformOnFun.topologicalSpace</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">UniformSpace.toTopologicalSpace</span></span></li></ul></details></div></div><div class="decl" id="UniformOnFun.topologicalSpace_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L605-L610">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.topologicalSpace_eq"><span class="name">UniformOnFun</span>.<span class="name">topologicalSpace_eq</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.topologicalSpace">UniformOnFun.topologicalSpace</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">⨅ s ∈ <span class="fn">𝔖</span>,
    <span class="fn"><a href="../../.././Mathlib/Topology/Order.html#TopologicalSpace.induced">TopologicalSpace.induced</a> <span class="fn">(<span class="fn"><span class="fn">⇑<span class="fn">UniformFun.ofFun</span></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Function.html#Set.restrict">Set.restrict</a> <span class="fn">s</span></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">UniformOnFun.toFun</a> <span class="fn">𝔖</span></span>)</span></span></span></span>)</span>
      <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.topologicalSpace">UniformFun.topologicalSpace</a> <span class="fn">(<span class="fn">↑<span class="fn">s</span></span>)</span> <span class="fn">β</span></span>)</span></span></span></span></div></div><p>The topology of <code>𝔖</code>-convergence is the infimum, for <code>S ∈ 𝔖</code>, of topology induced by the map
of <code>S.restrict : (α →ᵤ[𝔖] β) → (↥S →ᵤ β)</code> of restriction to <code>S</code>, where <code>↥S →ᵤ β</code> is endowed with
the topology of uniform convergence.</p></div></div><div class="decl" id="UniformOnFun.hasBasis_uniformity_of_basis_aux₁"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L613-L618">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.hasBasis_uniformity_of_basis_aux₁"><span class="name">UniformOnFun</span>.<span class="name">hasBasis_uniformity_of_basis_aux₁</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hb : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Bases.html#Filter.HasBasis">Filter.HasBasis</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span></span>)</span> <span class="fn">p</span> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(S : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Bases.html#Filter.HasBasis">Filter.HasBasis</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span>)</span></span>)</span> <span class="fn">p</span> <span class="fn">fun (<span class="fn">i</span> : <span class="fn">ι</span>) =&gt; <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> <span class="fn">𝔖</span> <span class="fn">S</span> <span class="fn">(<span class="fn"><span class="fn">s</span> <span class="fn">i</span></span>)</span></span></span></span></div></div></div></div><div class="decl" id="UniformOnFun.hasBasis_uniformity_of_basis_aux₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L621-L630">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.hasBasis_uniformity_of_basis_aux₂"><span class="name">UniformOnFun</span>.<span class="name">hasBasis_uniformity_of_basis_aux₂</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../../.././Mathlib/Order/Directed.html#DirectedOn">DirectedOn</a> <span class="fn">(<span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn">x_1</span></span></span>)</span> <span class="fn">𝔖</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hb : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Bases.html#Filter.HasBasis">Filter.HasBasis</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span></span>)</span> <span class="fn">p</span> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Directed.html#DirectedOn">DirectedOn</a> <span class="fn">(<span class="fn"><span class="fn">(<span class="fn">fun (<span class="fn">s</span> : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>) =&gt; <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace.comap">UniformSpace.comap</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Set/Function.html#Set.restrict">Set.restrict</a> <span class="fn">s</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformFun.uniformSpace">UniformFun.uniformSpace</a> <span class="fn">(<span class="fn">↑<span class="fn">s</span></span>)</span> <span class="fn">β</span></span>)</span></span></span>)</span> <a href="../../.././Mathlib/Order/Basic.html#Order.Preimage">⁻¹'o</a> <span class="fn">GE.ge</span></span>)</span> <span class="fn">𝔖</span></span></div></div></div></div><div class="decl" id="UniformOnFun.hasBasis_uniformity_of_basis"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L636-L644">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.hasBasis_uniformity_of_basis"><span class="name">UniformOnFun</span>.<span class="name">hasBasis_uniformity_of_basis</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set.Nonempty">Set.Nonempty</a> <span class="fn">𝔖</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h' : <span class="fn"><a href="../../.././Mathlib/Order/Directed.html#DirectedOn">DirectedOn</a> <span class="fn">(<span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn">x_1</span></span></span>)</span> <span class="fn">𝔖</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hb : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Bases.html#Filter.HasBasis">Filter.HasBasis</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span></span>)</span> <span class="fn">p</span> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Bases.html#Filter.HasBasis">Filter.HasBasis</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span>)</span></span>)</span> <span class="fn">(<span class="fn">fun (<span class="fn">Si</span> : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">ι</span></span>) =&gt; <span class="fn"><span class="fn"><span class="fn"><span class="fn">Si</span>.1</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">p</span> <span class="fn"><span class="fn">Si</span>.2</span></span></span></span>)</span> <span class="fn">fun (<span class="fn">Si</span> : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">ι</span></span>) =&gt;
  <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> <span class="fn">𝔖</span> <span class="fn"><span class="fn">Si</span>.1</span> <span class="fn">(<span class="fn"><span class="fn">s</span> <span class="fn"><span class="fn">Si</span>.2</span></span>)</span></span></span></span></div></div><p>If <code>𝔖 : <a href="../../.././Mathlib/Init/Set.html#Set">Set</a> (Set α)</code> is nonempty and directed and <code>𝓑</code> is a filter basis of <code>𝓤 β</code>, then the
uniformity of <code>α →ᵤ[𝔖] β</code> admits the family <code>{(f, g) | ∀ x ∈ S, (f x, g x) ∈ V}</code> for <code>S ∈ 𝔖</code> and
<code>V ∈ 𝓑</code> as a filter basis.</p></div></div><div class="decl" id="UniformOnFun.hasBasis_uniformity"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L649-L652">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.hasBasis_uniformity"><span class="name">UniformOnFun</span>.<span class="name">hasBasis_uniformity</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set.Nonempty">Set.Nonempty</a> <span class="fn">𝔖</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h' : <span class="fn"><a href="../../.././Mathlib/Order/Directed.html#DirectedOn">DirectedOn</a> <span class="fn">(<span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn">x_1</span></span></span>)</span> <span class="fn">𝔖</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Bases.html#Filter.HasBasis">Filter.HasBasis</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span>)</span></span>)</span> <span class="fn">(<span class="fn">fun (<span class="fn">SV</span> : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span></span>) =&gt; <span class="fn"><span class="fn"><span class="fn"><span class="fn">SV</span>.1</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn">SV</span>.2</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span></span></span></span></span>)</span>
  <span class="fn">fun (<span class="fn">SV</span> : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span></span>) =&gt; <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> <span class="fn">𝔖</span> <span class="fn"><span class="fn">SV</span>.1</span> <span class="fn"><span class="fn">SV</span>.2</span></span></span></span></div></div><p>If <code>𝔖 : <a href="../../.././Mathlib/Init/Set.html#Set">Set</a> (Set α)</code> is nonempty and directed, then the uniformity of <code>α →ᵤ[𝔖] β</code> admits the
family <code>{(f, g) | ∀ x ∈ S, (f x, g x) ∈ V}</code> for <code>S ∈ 𝔖</code> and <code>V ∈ 𝓤 β</code> as a filter basis.</p></div></div><div class="decl" id="UniformOnFun.hasBasis_nhds_of_basis"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L658-L663">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.hasBasis_nhds_of_basis"><span class="name">UniformOnFun</span>.<span class="name">hasBasis_nhds_of_basis</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set.Nonempty">Set.Nonempty</a> <span class="fn">𝔖</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h' : <span class="fn"><a href="../../.././Mathlib/Order/Directed.html#DirectedOn">DirectedOn</a> <span class="fn">(<span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn">x_1</span></span></span>)</span> <span class="fn">𝔖</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Prop</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hb : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Bases.html#Filter.HasBasis">Filter.HasBasis</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span></span>)</span> <span class="fn">p</span> <span class="fn">s</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Bases.html#Filter.HasBasis">Filter.HasBasis</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/Basic.html#nhds">nhds</a> <span class="fn">f</span></span>)</span> <span class="fn">(<span class="fn">fun (<span class="fn">Si</span> : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">ι</span></span>) =&gt; <span class="fn"><span class="fn"><span class="fn"><span class="fn">Si</span>.1</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">p</span> <span class="fn"><span class="fn">Si</span>.2</span></span></span></span>)</span> <span class="fn">fun (<span class="fn">Si</span> : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">ι</span></span>) =&gt;
  <span class="fn">{<span class="fn">g</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span> | <span class="fn"><span class="fn">(<span class="fn">g</span>, <span class="fn">f</span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> <span class="fn">𝔖</span> <span class="fn"><span class="fn">Si</span>.1</span> <span class="fn">(<span class="fn"><span class="fn">s</span> <span class="fn"><span class="fn">Si</span>.2</span></span>)</span></span></span>}</span></span></span></div></div><p>For <code>f : α →ᵤ[𝔖] β</code>, where <code>𝔖 : <a href="../../.././Mathlib/Init/Set.html#Set">Set</a> (Set α)</code> is nonempty and directed, <code>𝓝 f</code> admits the
family <code>{g | ∀ x ∈ S, (f x, g x) ∈ V}</code> for <code>S ∈ 𝔖</code> and <code>V ∈ 𝓑</code> as a filter basis, for any basis
<code>𝓑</code> of <code>𝓤 β</code>.</p></div></div><div class="decl" id="UniformOnFun.hasBasis_nhds"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L668-L671">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.hasBasis_nhds"><span class="name">UniformOnFun</span>.<span class="name">hasBasis_nhds</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set.Nonempty">Set.Nonempty</a> <span class="fn">𝔖</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h' : <span class="fn"><a href="../../.././Mathlib/Order/Directed.html#DirectedOn">DirectedOn</a> <span class="fn">(<span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn">x_1</span></span></span>)</span> <span class="fn">𝔖</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Bases.html#Filter.HasBasis">Filter.HasBasis</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/Basic.html#nhds">nhds</a> <span class="fn">f</span></span>)</span> <span class="fn">(<span class="fn">fun (<span class="fn">SV</span> : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span></span>) =&gt; <span class="fn"><span class="fn"><span class="fn"><span class="fn">SV</span>.1</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn"><span class="fn">SV</span>.2</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#uniformity">uniformity</a> <span class="fn">β</span></span></span></span></span>)</span>
  <span class="fn">fun (<span class="fn">SV</span> : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">β</span></span>)</span></span></span>) =&gt; <span class="fn">{<span class="fn">g</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span> | <span class="fn"><span class="fn">(<span class="fn">g</span>, <span class="fn">f</span>)</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.gen">UniformOnFun.gen</a> <span class="fn">𝔖</span> <span class="fn"><span class="fn">SV</span>.1</span> <span class="fn"><span class="fn">SV</span>.2</span></span></span>}</span></span></span></div></div><p>For <code>f : α →ᵤ[𝔖] β</code>, where <code>𝔖 : <a href="../../.././Mathlib/Init/Set.html#Set">Set</a> (Set α)</code> is nonempty and directed, <code>𝓝 f</code> admits the
family <code>{g | ∀ x ∈ S, (f x, g x) ∈ V}</code> for <code>S ∈ 𝔖</code> and <code>V ∈ 𝓤 β</code> as a filter basis.</p></div></div><div class="decl" id="UniformOnFun.uniformContinuous_restrict"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L676-L680">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformContinuous_restrict"><span class="name">UniformOnFun</span>.<span class="name">uniformContinuous_restrict</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u_1)</span></span>
<span class="decl_args">
<span class="fn">(β : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">𝔖</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">(<span class="fn"><span class="fn">⇑<span class="fn">UniformFun.ofFun</span></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Function.html#Set.restrict">Set.restrict</a> <span class="fn">s</span></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">UniformOnFun.toFun</a> <span class="fn">𝔖</span></span>)</span></span></span></span>)</span></span></div></div><p>If <code>S ∈ 𝔖</code>, then the restriction to <code>S</code> is a uniformly continuous map from <code>α →ᵤ[𝔖] β</code> to
<code>↥S →ᵤ β</code>.</p></div></div><div class="decl" id="UniformOnFun.mono"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L687-L691">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.mono"><span class="name">UniformOnFun</span>.<span class="name">mono</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">⦃u₁ : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>⦄</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">⦃u₂ : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>⦄</span></span>
</span><span class="decl_args">
<span class="fn">(hu : <span class="fn"><span class="fn">u₁</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">u₂</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">⦃𝔖₁ : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>⦄</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">⦃𝔖₂ : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>⦄</span></span>
</span><span class="decl_args">
<span class="fn">(h𝔖 : <span class="fn"><span class="fn">𝔖₂</span> <a href="../../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn">𝔖₁</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace">UniformOnFun.uniformSpace</a> <span class="fn">α</span> <span class="fn">γ</span> <span class="fn">𝔖₁</span></span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace">UniformOnFun.uniformSpace</a> <span class="fn">α</span> <span class="fn">γ</span> <span class="fn">𝔖₂</span></span></span></div></div><p>Let <code>u₁</code>, <code>u₂</code> be two uniform structures on <code>γ</code> and <code>𝔖₁ 𝔖₂ : <a href="../../.././Mathlib/Init/Set.html#Set">Set</a> (Set α)</code>. If <code>u₁ ≤ u₂</code> and
<code>𝔖₂ ⊆ 𝔖₁</code> then <code>𝒱(α, γ, 𝔖₁, u₁) ≤ 𝒱(α, γ, 𝔖₂, u₂)</code>.</p></div></div><div class="decl" id="UniformOnFun.uniformContinuous_eval_of_mem"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L696-L699">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformContinuous_eval_of_mem"><span class="name">UniformOnFun</span>.<span class="name">uniformContinuous_eval_of_mem</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="decl_args">
<span class="fn">(β : <a href="../../.././foundational_types.html">Type</a> u_2)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{s : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hxs : <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">s</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hs : <span class="fn"><span class="fn">s</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">𝔖</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Mathlib/Logic/Function/Basic.html#Function.eval">Function.eval</a> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">UniformOnFun.toFun</a> <span class="fn">𝔖</span></span>)</span></span></span>)</span></span></div></div><p>If <code>x : α</code> is in some <code>S ∈ 𝔖</code>, then evaluation at <code>x</code> is uniformly continuous on
<code>α →ᵤ[𝔖] β</code>.</p></div></div><div class="decl" id="UniformOnFun.iInf_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L706-L710">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.iInf_eq"><span class="name">UniformOnFun</span>.<span class="name">iInf_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace">UniformOnFun.uniformSpace</a> <span class="fn">α</span> <span class="fn">γ</span> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">⨅ (i : <span class="fn">ι</span>), <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace">UniformOnFun.uniformSpace</a> <span class="fn">α</span> <span class="fn">γ</span> <span class="fn">𝔖</span></span></span></span></div></div><p>If <code>u</code> is a family of uniform structures on <code>γ</code>, then
<code>𝒱(α, γ, 𝔖, (⨅ i, u i)) = ⨅ i, 𝒱(α, γ, 𝔖, u i)</code>.</p></div></div><div class="decl" id="UniformOnFun.inf_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L715-L719">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.inf_eq"><span class="name">UniformOnFun</span>.<span class="name">inf_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u₁ : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{u₂ : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace">UniformOnFun.uniformSpace</a> <span class="fn">α</span> <span class="fn">γ</span> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace">UniformOnFun.uniformSpace</a> <span class="fn">α</span> <span class="fn">γ</span> <span class="fn">𝔖</span></span> <a href="../../.././Mathlib/Order/Notation.html#Inf.inf">⊓</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace">UniformOnFun.uniformSpace</a> <span class="fn">α</span> <span class="fn">γ</span> <span class="fn">𝔖</span></span></span></span></div></div><p>If <code>u₁</code> and <code>u₂</code> are two uniform structures on <code>γ</code>, then
<code>𝒱(α, γ, 𝔖, u₁ ⊓ u₂) = 𝒱(α, γ, 𝔖, u₁) ⊓ 𝒱(α, γ, 𝔖, u₂)</code>.</p></div></div><div class="decl" id="UniformOnFun.comap_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L724-L730">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.comap_eq"><span class="name">UniformOnFun</span>.<span class="name">comap_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">γ</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace">UniformOnFun.uniformSpace</a> <span class="fn">α</span> <span class="fn">γ</span> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace.comap">UniformSpace.comap</a> <span class="fn">(<span class="fn">fun (<span class="fn">x</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">x</span></span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformSpace">UniformOnFun.uniformSpace</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span>)</span></span></span></div></div><p>If <code>u</code> is a uniform structure on <code>β</code> and <code>f : γ → β</code>, then
<code>𝒱(α, γ, 𝔖, comap f u) = comap (fun g ↦ f ∘ g) 𝒱(α, γ, 𝔖, u₁)</code>.</p></div></div><div class="decl" id="UniformOnFun.postcomp_uniformContinuous"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L739-L743">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.postcomp_uniformContinuous"><span class="name">UniformOnFun</span>.<span class="name">postcomp_uniformContinuous</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">γ</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">(<span class="fn"><span class="fn">⇑<span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.ofFun">UniformOnFun.ofFun</a> <span class="fn">𝔖</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn"><span class="fn">(<span class="fn">fun (<span class="fn">x</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">x</span></span></span>)</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">UniformOnFun.toFun</a> <span class="fn">𝔖</span></span>)</span></span></span></span>)</span></span></div></div><p>Post-composition by a uniformly continuous function is uniformly continuous for the
uniform structures of <code>𝔖</code>-convergence.</p><p>More precisely, if <code>f : γ → β</code> is uniformly continuous, then
<code>(fun g ↦ f ∘ g) : (α →ᵤ[𝔖] γ) → (α →ᵤ[𝔖] β)</code> is uniformly continuous.</p></div></div><div class="decl" id="UniformOnFun.postcomp_uniformInducing"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L751-L760">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.postcomp_uniformInducing"><span class="name">UniformOnFun</span>.<span class="name">postcomp_uniformInducing</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">γ</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformInducing">UniformInducing</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformInducing">UniformInducing</a> <span class="fn">(<span class="fn"><span class="fn">⇑<span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.ofFun">UniformOnFun.ofFun</a> <span class="fn">𝔖</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn"><span class="fn">(<span class="fn">fun (<span class="fn">x</span> : <span class="fn"><span class="fn">α</span> → <span class="fn">γ</span></span>) =&gt; <span class="fn"><span class="fn">f</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">x</span></span></span>)</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">⇑<span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">UniformOnFun.toFun</a> <span class="fn">𝔖</span></span>)</span></span></span></span>)</span></span></div></div><p>Post-composition by a uniform inducing is a uniform inducing for the
uniform structures of <code>𝔖</code>-convergence.</p><p>More precisely, if <code>f : γ → β</code> is a uniform inducing, then
<code>(fun g ↦ f ∘ g) : (α →ᵤ[𝔖] γ) → (α →ᵤ[𝔖] β)</code> is a uniform inducing.</p></div></div><div class="decl" id="UniformOnFun.congrRight"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L765-L768">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.congrRight"><span class="name">UniformOnFun</span>.<span class="name">congrRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">γ</span> <a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#UniformEquiv">≃ᵤ</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">γ</span> <span class="fn">𝔖</span></span> <a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#UniformEquiv">≃ᵤ</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span></span></div></div><p>Turn a uniform isomorphism <code>γ ≃ᵤ β</code> into a uniform isomorphism <code>(α →ᵤ[𝔖] γ) ≃ᵤ (α →ᵤ[𝔖] β)</code>
by post-composing.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-UniformOnFun.congrRight" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformOnFun.precomp_uniformContinuous"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L777-L801">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.precomp_uniformContinuous"><span class="name">UniformOnFun</span>.<span class="name">precomp_uniformContinuous</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{𝔗 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">γ</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">γ</span> → <span class="fn">α</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hf : <span class="fn"><span class="fn">𝔗</span> <a href="../../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set.image">Set.image</a> <span class="fn">f</span></span> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.preimage">⁻¹'</a> <span class="fn">𝔖</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">fun (<span class="fn">g</span> : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span>) =&gt; <span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.ofFun">UniformOnFun.ofFun</a> <span class="fn">𝔗</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">g</span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">f</span></span>)</span></span></span></span></div></div><p>Let <code>f : γ → α</code>, <code>𝔖 : <a href="../../.././Mathlib/Init/Set.html#Set">Set</a> (Set α)</code>, <code>𝔗 : <a href="../../.././Mathlib/Init/Set.html#Set">Set</a> (Set γ)</code>, and assume that <code>∀ T ∈ 𝔗, f '' T ∈ 𝔖</code>.
Then, the function <code>(fun g ↦ g ∘ f) : (α →ᵤ[𝔖] β) → (γ →ᵤ[𝔗] β)</code> is uniformly continuous.</p><p>Note that one can easily see that assuming <code>∀ T ∈ 𝔗, ∃ S ∈ 𝔖, f '' T ⊆ S</code> would work too, but
we will get this for free when we prove that <code>𝒱(α, β, 𝔖, uβ) = 𝒱(α, β, 𝔖', uβ)</code> where <code>𝔖'</code> is the
<em><strong>noncovering</strong></em> bornology generated by <code>𝔖</code>.</p></div></div><div class="decl" id="UniformOnFun.congrLeft"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L806-L813">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.congrLeft"><span class="name">UniformOnFun</span>.<span class="name">congrLeft</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{𝔗 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">γ</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">γ</span> <a href="../../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(he : <span class="fn"><span class="fn">𝔗</span> <a href="../../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set.image">Set.image</a> <span class="fn">⇑<span class="fn">e</span></span></span> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.preimage">⁻¹'</a> <span class="fn">𝔖</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(he' : <span class="fn"><span class="fn">𝔖</span> <a href="../../.././Std/Classes/SetNotation.html#HasSubset.Subset">⊆</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set.preimage">Set.preimage</a> <span class="fn">⇑<span class="fn">e</span></span></span> <a href="../../.././Mathlib/Data/Set/Defs.html#Set.preimage">⁻¹'</a> <span class="fn">𝔗</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">γ</span> <span class="fn">β</span> <span class="fn">𝔗</span></span> <a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#UniformEquiv">≃ᵤ</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span></span></div></div><p>Turn a bijection <code>e : γ ≃ α</code> such that we have both <code>∀ T ∈ 𝔗, e '' T ∈ 𝔖</code> and
<code>∀ S ∈ 𝔖, e ⁻¹' S ∈ 𝔗</code> into a uniform isomorphism <code>(γ →ᵤ[𝔗] β) ≃ᵤ (α →ᵤ[𝔖] β)</code> by pre-composing.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-UniformOnFun.congrLeft" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformOnFun.t2Space_of_covering"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L817-L821">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.t2Space_of_covering"><span class="name">UniformOnFun</span>.<span class="name">t2Space_of_covering</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/Separation.html#T2Space">T2Space</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Lattice.html#Set.sUnion">⋃₀</a> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">Set.univ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/Separation.html#T2Space">T2Space</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span>)</span></span></div></div><p>If <code>𝔖</code> covers <code>α</code>, then the topology of <code>𝔖</code>-convergence is T₂.</p></div></div><div class="decl" id="UniformOnFun.uniformContinuous_toFun"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L829-L834">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformContinuous_toFun"><span class="name">UniformOnFun</span>.<span class="name">uniformContinuous_toFun</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../../.././Mathlib/Data/Set/Lattice.html#Set.sUnion">⋃₀</a> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">Set.univ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformContinuous">UniformContinuous</a> <span class="fn">⇑<span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">UniformOnFun.toFun</a> <span class="fn">𝔖</span></span>)</span></span></span></div></div><p>If <code>𝔖</code> covers <code>α</code>, the natural map <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">UniformOnFun.toFun</a></code> from <code>α →ᵤ[𝔖] β</code> to <code>α → β</code> is
uniformly continuous.</p><p>In other words, if <code>𝔖</code> covers <code>α</code>, then the uniform structure of <code>𝔖</code>-convergence is finer than
that of pointwise convergence.</p></div></div><div class="decl" id="UniformOnFun.tendsto_iff_tendstoUniformlyOn"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L839-L847">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.tendsto_iff_tendstoUniformlyOn"><span class="name">UniformOnFun</span>.<span class="name">tendsto_iff_tendstoUniformlyOn</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><a href="../../.././Mathlib/Order/Filter/Basic.html#Filter">Filter</a> <span class="fn">ι</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Order/Filter/Basic.html#Filter.Tendsto">Filter.Tendsto</a> <span class="fn">F</span> <span class="fn">p</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/Basic.html#nhds">nhds</a> <span class="fn">f</span></span>)</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn">∀ <span class="fn">s</span> ∈ <span class="fn">𝔖</span>, <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergence.html#TendstoUniformlyOn">TendstoUniformlyOn</a> <span class="fn">(<span class="fn"><span class="fn">⇑<span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">UniformOnFun.toFun</a> <span class="fn">𝔖</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Function.comp">∘</a> <span class="fn">F</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.toFun">UniformOnFun.toFun</a> <span class="fn">𝔖</span></span>)</span> <span class="fn">f</span></span>)</span> <span class="fn">p</span> <span class="fn">s</span></span></span></span></div></div><p>Convergence in the topology of <code>𝔖</code>-convergence means uniform convergence on <code>S</code> (in the sense
of <code><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergence.html#TendstoUniformlyOn">TendstoUniformlyOn</a></code>) for all <code>S ∈ 𝔖</code>.</p></div></div><div class="decl" id="UniformOnFun.uniformEquivProdArrow"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L852-L873">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformEquivProdArrow"><span class="name">UniformOnFun</span>.<span class="name">uniformEquivProdArrow</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <a href="../../.././foundational_types.html">Type</a> u_2}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <a href="../../.././foundational_types.html">Type</a> u_3}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">β</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">γ</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">(<span class="fn"><span class="fn">β</span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn">γ</span></span>)</span> <span class="fn">𝔖</span></span> <a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#UniformEquiv">≃ᵤ</a> <span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">𝔖</span></span> <a href="../../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">γ</span> <span class="fn">𝔖</span></span></span></span></div></div><p>The natural bijection between <code>α → β × γ</code> and <code>(α → β) × (α → γ)</code>, upgraded to a uniform
isomorphism between <code>α →ᵤ[𝔖] β × γ</code> and <code>(α →ᵤ[𝔖] β) × (α →ᵤ[𝔖] γ)</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-UniformOnFun.uniformEquivProdArrow" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="UniformOnFun.uniformEquivPiComm"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean#L881-L899">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformEquivPiComm"><span class="name">UniformOnFun</span>.<span class="name">uniformEquivPiComm</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../.././foundational_types.html">Type</a> u_4}</span></span>
</span><span class="decl_args">
<span class="fn">(𝔖 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">α</span></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(δ : <span class="fn"><span class="fn">ι</span> → <a href="../../.././foundational_types.html">Type</a> u_5</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Basic.html#UniformSpace">UniformSpace</a> <span class="fn">(<span class="fn"><span class="fn">δ</span> <span class="fn">i</span></span>)</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">(<span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><span class="fn">δ</span> <span class="fn">i</span></span></span>)</span> <span class="fn">𝔖</span></span> <a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#UniformEquiv">≃ᵤ</a> <span class="fn">(<span class="fn">(<span class="fn">i</span> : <span class="fn">ι</span>) → <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun">UniformOnFun</a> <span class="fn">α</span> <span class="fn">(<span class="fn"><span class="fn">δ</span> <span class="fn">i</span></span>)</span> <span class="fn">𝔖</span></span></span>)</span></span></div></div><p>The natural bijection between <code>α → Π i, δ i</code> and <code>Π i, α → δ i</code>, upgraded to a uniform
isomorphism between <code>α →ᵤ[𝔖] (Π i, δ i)</code> and <code>Π i, α →ᵤ[𝔖] δ i</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformConvergenceTopology.html#UniformOnFun.uniformEquivPiComm">UniformOnFun.uniformEquivPiComm</a> <span class="fn">𝔖</span> <span class="fn">δ</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/Equiv.html#Equiv.toUniformEquivOfUniformInducing">Equiv.toUniformEquivOfUniformInducing</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Logic/Equiv/Basic.html#Equiv.piComm">Equiv.piComm</a> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">i</span> : <span class="fn">ι</span>) =&gt; <span class="fn"><span class="fn">δ</span> <span class="fn">i</span></span></span></span>)</span>
    <span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/Topology/UniformSpace/UniformEmbedding.html#UniformInducing">UniformInducing</a> <span class="fn">⇑<span class="fn">(<span class="fn"><a href="../../.././Mathlib/Logic/Equiv/Basic.html#Equiv.piComm">Equiv.piComm</a> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span>) (<span class="fn">i</span> : <span class="fn">ι</span>) =&gt; <span class="fn"><span class="fn">δ</span> <span class="fn">i</span></span></span></span>)</span></span></span>)</span></span></span></li></ul></details><details id="instances-for-list-UniformOnFun.uniformEquivPiComm" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>