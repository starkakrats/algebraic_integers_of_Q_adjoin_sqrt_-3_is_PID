<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../../.././style.css"></link><link rel="stylesheet" href="../../../.././src/pygments.css"></link><link rel="shortcut icon" href="../../../.././favicon.ico"></link><link rel="prefetch" href="../../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.Topology.Sheaves.SheafCondition.OpensLeCover</title><script defer="true" src="../../../.././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../../.././";</script><script>const MODULE_NAME="Mathlib.Topology.Sheaves.SheafCondition.OpensLeCover";</script><script type="module" src="../../../.././jump-src.js"></script><script type="module" src="../../../.././search.js"></script><script type="module" src="../../../.././expand-nav.js"></script><script type="module" src="../../../.././how-about.js"></script><script type="module" src="../../../.././instances.js"></script><script type="module" src="../../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">Topology</span>.<span class="name">Sheaves</span>.<span class="name">SheafCondition</span>.<span class="name">OpensLeCover</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;
            <button id="search_button" onclick="javascript: form.action='../../../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../../.././Init.html">Init</a></li><li><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/Sites.html">Mathlib.Topology.Sheaves.SheafCondition.Sites</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.Topology.Sheaves.SheafCondition.OpensLeCover" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#TopCat.Presheaf.SheafCondition.OpensLeCover"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">SheafCondition</span>.<span class="name">OpensLeCover</span></a></div><div class="nav_link"><a class="break_within" href="#TopCat.Presheaf.SheafCondition.instCategoryOpensLeCover"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">SheafCondition</span>.<span class="name">instCategoryOpensLeCover</span></a></div><div class="nav_link"><a class="break_within" href="#TopCat.Presheaf.SheafCondition.instInhabitedOpensLeCover"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">SheafCondition</span>.<span class="name">instInhabitedOpensLeCover</span></a></div><div class="nav_link"><a class="break_within" href="#TopCat.Presheaf.SheafCondition.OpensLeCover.index"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">SheafCondition</span>.<span class="name">OpensLeCover</span>.<span class="name">index</span></a></div><div class="nav_link"><a class="break_within" href="#TopCat.Presheaf.SheafCondition.OpensLeCover.homToIndex"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">SheafCondition</span>.<span class="name">OpensLeCover</span>.<span class="name">homToIndex</span></a></div><div class="nav_link"><a class="break_within" href="#TopCat.Presheaf.SheafCondition.opensLeCoverCocone"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">SheafCondition</span>.<span class="name">opensLeCoverCocone</span></a></div><div class="nav_link"><a class="break_within" href="#TopCat.Presheaf.IsSheafOpensLeCover"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">IsSheafOpensLeCover</span></a></div><div class="nav_link"><a class="break_within" href="#TopCat.Presheaf.generateEquivalenceOpensLe_functor'_map"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">generateEquivalenceOpensLe_functor'_map</span></a></div><div class="nav_link"><a class="break_within" href="#TopCat.Presheaf.generateEquivalenceOpensLe_functor'_obj_obj"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">generateEquivalenceOpensLe_functor'_obj_obj</span></a></div><div class="nav_link"><a class="break_within" href="#TopCat.Presheaf.generateEquivalenceOpensLe_functor'"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">generateEquivalenceOpensLe_functor'</span></a></div><div class="nav_link"><a class="break_within" href="#TopCat.Presheaf.generateEquivalenceOpensLe_inverse'_map"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">generateEquivalenceOpensLe_inverse'_map</span></a></div><div class="nav_link"><a class="break_within" href="#TopCat.Presheaf.generateEquivalenceOpensLe_inverse'_obj_obj_right_as"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">generateEquivalenceOpensLe_inverse'_obj_obj_right_as</span></a></div><div class="nav_link"><a class="break_within" href="#TopCat.Presheaf.generateEquivalenceOpensLe_inverse'_obj_obj_left"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">generateEquivalenceOpensLe_inverse'_obj_obj_left</span></a></div><div class="nav_link"><a class="break_within" href="#TopCat.Presheaf.generateEquivalenceOpensLe_inverse'_obj_obj_hom"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">generateEquivalenceOpensLe_inverse'_obj_obj_hom</span></a></div><div class="nav_link"><a class="break_within" href="#TopCat.Presheaf.generateEquivalenceOpensLe_inverse'"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">generateEquivalenceOpensLe_inverse'</span></a></div><div class="nav_link"><a class="break_within" href="#TopCat.Presheaf.generateEquivalenceOpensLe_unitIso"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">generateEquivalenceOpensLe_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#TopCat.Presheaf.generateEquivalenceOpensLe_inverse"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">generateEquivalenceOpensLe_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#TopCat.Presheaf.generateEquivalenceOpensLe_counitIso"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">generateEquivalenceOpensLe_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#TopCat.Presheaf.generateEquivalenceOpensLe_functor"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">generateEquivalenceOpensLe_functor</span></a></div><div class="nav_link"><a class="break_within" href="#TopCat.Presheaf.generateEquivalenceOpensLe"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">generateEquivalenceOpensLe</span></a></div><div class="nav_link"><a class="break_within" href="#TopCat.Presheaf.whiskerIsoMapGenerateCocone_hom_hom"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">whiskerIsoMapGenerateCocone_hom_hom</span></a></div><div class="nav_link"><a class="break_within" href="#TopCat.Presheaf.whiskerIsoMapGenerateCocone_inv_hom"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">whiskerIsoMapGenerateCocone_inv_hom</span></a></div><div class="nav_link"><a class="break_within" href="#TopCat.Presheaf.whiskerIsoMapGenerateCocone"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">whiskerIsoMapGenerateCocone</span></a></div><div class="nav_link"><a class="break_within" href="#TopCat.Presheaf.isLimitOpensLeEquivGenerate₁"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">isLimitOpensLeEquivGenerate₁</span></a></div><div class="nav_link"><a class="break_within" href="#TopCat.Presheaf.isLimitOpensLeEquivGenerate₂"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">isLimitOpensLeEquivGenerate₂</span></a></div><div class="nav_link"><a class="break_within" href="#TopCat.Presheaf.isSheaf_iff_isSheafOpensLeCover"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">isSheaf_iff_isSheafOpensLeCover</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Another-version-of-the-sheaf-condition">Another version of the sheaf condition. <a class="hover-link" href="#Another-version-of-the-sheaf-condition">#</a></h1><p>Given a family of open sets <code>U : ι → Opens X</code> we can form the subcategory
<code>{ V : Opens X // ∃ i, V ≤ U i }</code>, which has <code><a href="../../../.././Mathlib/Order/CompleteLattice.html#iSup">iSup</a> U</code> as a cocone.</p><p>The sheaf condition on a presheaf <code>F</code> is equivalent to
<code>F</code> sending the opposite of this cocone to a limit cone in <code>C</code>, for every <code>U</code>.</p><p>This condition is particularly nice when checking the sheaf condition
because we don't need to do any case bashing
(depending on whether we're looking at single or double intersections,
or equivalently whether we're looking at the first or second object in an equalizer diagram).</p><h2 class="markdown-heading" id="Main-statement">Main statement <a class="hover-link" href="#Main-statement">#</a></h2><p><code><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.isSheaf_iff_isSheafOpensLeCover">TopCat.Presheaf.isSheaf_iff_isSheafOpensLeCover</a></code>: for a presheaf on a topological space,
the sheaf condition in terms of Grothendieck topology is equivalent to the <code><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.OpensLeCover">OpensLeCover</a></code>
sheaf condition. This result will be used to further connect to other sheaf conditions on spaces,
like <code>pairwise_intersections</code> and <code>equalizer_products</code>.</p><h2 class="markdown-heading" id="References">References <a class="hover-link" href="#References">#</a></h2><ul>
<li>This is the definition Lurie uses in [Spectral Algebraic Geometry][LurieSAG].</li>
</ul></div><div class="decl" id="TopCat.Presheaf.SheafCondition.OpensLeCover"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.lean#L54-L55">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.OpensLeCover"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">SheafCondition</span>.<span class="name">OpensLeCover</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../../../.././Mathlib/Topology/Category/TopCat/Basic.html#TopCat">TopCat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Type</a> w</div></div><p>The category of open sets contained in some element of the cover.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.OpensLeCover">TopCat.Presheaf.SheafCondition.OpensLeCover</a> <span class="fn">U</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/FullSubcategory.html#CategoryTheory.FullSubcategory">CategoryTheory.FullSubcategory</a> <span class="fn">fun (<span class="fn">V</span> : <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span>) =&gt; <span class="fn">∃ (i : <span class="fn">ι</span>), <span class="fn"><span class="fn">V</span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">U</span> <span class="fn">i</span></span></span></span></span></span></span></li></ul></details><details id="instances-for-list-TopCat.Presheaf.SheafCondition.OpensLeCover" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="TopCat.Presheaf.SheafCondition.instCategoryOpensLeCover"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.lean#L60-L60">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.instCategoryOpensLeCover"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">SheafCondition</span>.<span class="name">instCategoryOpensLeCover</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../../../.././Mathlib/Topology/Category/TopCat/Basic.html#TopCat">TopCat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{w, w}</a>    <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.OpensLeCover">TopCat.Presheaf.SheafCondition.OpensLeCover</a> <span class="fn">U</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.instCategoryOpensLeCover">TopCat.Presheaf.SheafCondition.instCategoryOpensLeCover</a> <span class="fn">U</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/FullSubcategory.html#CategoryTheory.FullSubcategory.category">CategoryTheory.FullSubcategory.category</a> <span class="fn">fun (<span class="fn">V</span> : <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span>) =&gt; <span class="fn">∃ (i : <span class="fn">ι</span>), <span class="fn"><span class="fn">V</span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">U</span> <span class="fn">i</span></span></span></span></span></span></span></li></ul></details></div></div><div class="decl" id="TopCat.Presheaf.SheafCondition.instInhabitedOpensLeCover"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.lean#L62-L63">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.instInhabitedOpensLeCover"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">SheafCondition</span>.<span class="name">instInhabitedOpensLeCover</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../../../.././Mathlib/Topology/Category/TopCat/Basic.html#TopCat">TopCat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">ι</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.OpensLeCover">TopCat.Presheaf.SheafCondition.OpensLeCover</a> <span class="fn">U</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.instInhabitedOpensLeCover">TopCat.Presheaf.SheafCondition.instInhabitedOpensLeCover</a> <span class="fn">U</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">default</span> := <span class="fn">{ <span class="fn">obj</span> := <a href="../../../.././Mathlib/Order/Notation.html#Bot.bot">⊥</a>, <span class="fn">property</span> := <span class="fn">(_ : <span class="fn">∃ (i : <span class="fn">ι</span>), <span class="fn"><a href="../../../.././Mathlib/Order/Notation.html#Bot.bot">⊥</a> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">U</span> <span class="fn">i</span></span></span></span>)</span> }</span> }</span></span></li></ul></details></div></div><div class="decl" id="TopCat.Presheaf.SheafCondition.OpensLeCover.index"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.lean#L71-L72">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.OpensLeCover.index"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">SheafCondition</span>.<span class="name">OpensLeCover</span>.<span class="name">index</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../../../.././Mathlib/Topology/Category/TopCat/Basic.html#TopCat">TopCat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(V : <span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.OpensLeCover">TopCat.Presheaf.SheafCondition.OpensLeCover</a> <span class="fn">U</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">ι</span></div></div><p>An arbitrarily chosen index such that <code>V ≤ U i</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.OpensLeCover.index">TopCat.Presheaf.SheafCondition.OpensLeCover.index</a> <span class="fn">V</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Std/Logic.html#Exists.choose">Exists.choose</a> <span class="fn">(_ : <span class="fn">∃ (i : <span class="fn">ι</span>), <span class="fn"><span class="fn"><span class="fn">V</span>.obj</span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">U</span> <span class="fn">i</span></span></span></span>)</span></span></span></li></ul></details><details id="instances-for-list-TopCat.Presheaf.SheafCondition.OpensLeCover.index" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="TopCat.Presheaf.SheafCondition.OpensLeCover.homToIndex"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.lean#L78-L79">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.OpensLeCover.homToIndex"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">SheafCondition</span>.<span class="name">OpensLeCover</span>.<span class="name">homToIndex</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../../../.././Mathlib/Topology/Category/TopCat/Basic.html#TopCat">TopCat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(V : <span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.OpensLeCover">TopCat.Presheaf.SheafCondition.OpensLeCover</a> <span class="fn">U</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">V</span>.obj</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">U</span> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.OpensLeCover.index">TopCat.Presheaf.SheafCondition.OpensLeCover.index</a> <span class="fn">V</span></span>)</span></span></span></div></div><p>The morphism from <code>V</code> to <code>U i</code> for some <code>i</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.OpensLeCover.homToIndex">TopCat.Presheaf.SheafCondition.OpensLeCover.homToIndex</a> <span class="fn">V</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Preorder.html#LE.le.hom">LE.le.hom</a> <span class="fn">(_ : <span class="fn"><span class="fn"><span class="fn">V</span>.obj</span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">U</span> <span class="fn">(<span class="fn"><a href="../../../.././Std/Logic.html#Exists.choose">Exists.choose</a> <span class="fn">(_ : <span class="fn">∃ (i : <span class="fn">ι</span>), <span class="fn"><span class="fn"><span class="fn">V</span>.obj</span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">U</span> <span class="fn">i</span></span></span></span>)</span></span>)</span></span></span>)</span></span></span></li></ul></details><details id="instances-for-list-TopCat.Presheaf.SheafCondition.OpensLeCover.homToIndex" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="TopCat.Presheaf.SheafCondition.opensLeCoverCocone"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.lean#L89-L91">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.opensLeCoverCocone"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">SheafCondition</span>.<span class="name">opensLeCoverCocone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../../../.././Mathlib/Topology/Category/TopCat/Basic.html#TopCat">TopCat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a>
  <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/FullSubcategory.html#CategoryTheory.fullSubcategoryInclusion">CategoryTheory.fullSubcategoryInclusion</a> <span class="fn">fun (<span class="fn">V</span> : <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span>) =&gt; <span class="fn">∃ (i : <span class="fn">ι</span>), <span class="fn"><span class="fn">V</span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">U</span> <span class="fn">i</span></span></span></span></span></span>)</span></span></div></div><p><code><a href="../../../.././Mathlib/Order/CompleteLattice.html#iSup">iSup</a> U</code> as a cocone over the opens sets contained in some element of the cover.</p><p>(In fact this is a colimit cocone.)</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-TopCat.Presheaf.SheafCondition.opensLeCoverCocone" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="TopCat.Presheaf.IsSheafOpensLeCover"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.lean#L107-L108">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.IsSheafOpensLeCover"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">IsSheafOpensLeCover</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../../../.././Mathlib/Topology/Category/TopCat/Basic.html#TopCat">TopCat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/Presheaf.html#TopCat.Presheaf">TopCat.Presheaf</a> <span class="fn">C</span> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../../.././foundational_types.html">Prop</a></div></div><p>An equivalent formulation of the sheaf condition
(which we prove equivalent to the usual one below as
<code><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.isSheaf_iff_isSheafOpensLeCover">isSheaf_iff_isSheafOpensLeCover</a></code>).</p><p>A presheaf is a sheaf if <code>F</code> sends the cone <code>(opensLeCoverCocone U).op</code> to a limit cone.
(Recall <code><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.opensLeCoverCocone">opensLeCoverCocone</a> U</code>, has cone point <code><a href="../../../.././Mathlib/Order/CompleteLattice.html#iSup">iSup</a> U</code>,
mapping down to any <code>V</code> which is contained in some <code>U i</code>.)</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-TopCat.Presheaf.IsSheafOpensLeCover" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="TopCat.Presheaf.generateEquivalenceOpensLe_functor'_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.lean#L122-L122">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.generateEquivalenceOpensLe_functor'_map"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">generateEquivalenceOpensLe_functor'_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../../../.././Mathlib/Topology/Category/TopCat/Basic.html#TopCat">TopCat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hY : <span class="fn"><span class="fn">Y</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Order/CompleteLattice.html#iSup">iSup</a> <span class="fn">U</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀
  {<span class="fn">x </span>x_1 :
    <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/FullSubcategory.html#CategoryTheory.FullSubcategory">CategoryTheory.FullSubcategory</a> <span class="fn">fun (<span class="fn">f</span> : <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">Y</span></span>) =&gt;
      <span class="fn"><span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.generate">CategoryTheory.Sieve.generate</a> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/Sites.html#TopCat.Presheaf.presieveOfCoveringAux">TopCat.Presheaf.presieveOfCoveringAux</a> <span class="fn">U</span> <span class="fn">Y</span></span>)</span></span>)</span>.arrows <span class="fn"><span class="fn">f</span>.hom</span></span></span></span>}
  (<span class="fn">g</span> : <span class="fn"><span class="fn">x</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">x_1</span></span>), <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.generateEquivalenceOpensLe_functor'">TopCat.Presheaf.generateEquivalenceOpensLe_functor'</a> <span class="fn">U</span> <span class="fn">hY</span></span>)</span>.map <span class="fn">g</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span>.left</span></span></span></div></div></div></div><div class="decl" id="TopCat.Presheaf.generateEquivalenceOpensLe_functor'_obj_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.lean#L122-L122">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.generateEquivalenceOpensLe_functor'_obj_obj"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">generateEquivalenceOpensLe_functor'_obj_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../../../.././Mathlib/Topology/Category/TopCat/Basic.html#TopCat">TopCat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hY : <span class="fn"><span class="fn">Y</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Order/CompleteLattice.html#iSup">iSup</a> <span class="fn">U</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/FullSubcategory.html#CategoryTheory.FullSubcategory">CategoryTheory.FullSubcategory</a> <span class="fn">fun (<span class="fn">f</span> : <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">Y</span></span>) =&gt;
  <span class="fn"><span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.generate">CategoryTheory.Sieve.generate</a> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/Sites.html#TopCat.Presheaf.presieveOfCoveringAux">TopCat.Presheaf.presieveOfCoveringAux</a> <span class="fn">U</span> <span class="fn">Y</span></span>)</span></span>)</span>.arrows <span class="fn"><span class="fn">f</span>.hom</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.generateEquivalenceOpensLe_functor'">TopCat.Presheaf.generateEquivalenceOpensLe_functor'</a> <span class="fn">U</span> <span class="fn">hY</span></span>)</span>.obj <span class="fn">f</span></span>)</span>.obj</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">f</span>.obj</span>.left</span></span></div></div></div></div><div class="decl" id="TopCat.Presheaf.generateEquivalenceOpensLe_functor'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.lean#L123-L130">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.generateEquivalenceOpensLe_functor'"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">generateEquivalenceOpensLe_functor'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../../../.././Mathlib/Topology/Category/TopCat/Basic.html#TopCat">TopCat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hY : <span class="fn"><span class="fn">Y</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Order/CompleteLattice.html#iSup">iSup</a> <span class="fn">U</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a>
  <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/FullSubcategory.html#CategoryTheory.FullSubcategory">CategoryTheory.FullSubcategory</a> <span class="fn">fun (<span class="fn">f</span> : <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">Y</span></span>) =&gt;
    <span class="fn"><span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.generate">CategoryTheory.Sieve.generate</a> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/Sites.html#TopCat.Presheaf.presieveOfCoveringAux">TopCat.Presheaf.presieveOfCoveringAux</a> <span class="fn">U</span> <span class="fn">Y</span></span>)</span></span>)</span>.arrows <span class="fn"><span class="fn">f</span>.hom</span></span></span></span>)</span>
  <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.OpensLeCover">TopCat.Presheaf.SheafCondition.OpensLeCover</a> <span class="fn">U</span></span>)</span></span></div></div><p>Given a family of opens <code>U</code> and an open <code>Y</code> equal to the union of opens in <code>U</code>, we may
take the presieve on <code>Y</code> associated to <code>U</code> and the sieve generated by it, and form the
full subcategory (subposet) of opens contained in <code>Y</code> (<code>over Y</code>) consisting of arrows
in the sieve. This full subcategory is equivalent to <code><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.OpensLeCover">OpensLeCover</a> U</code>, the (poset)
category of opens contained in some <code>U i</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-TopCat.Presheaf.generateEquivalenceOpensLe_functor'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="TopCat.Presheaf.generateEquivalenceOpensLe_inverse'_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.lean#L138-L138">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.generateEquivalenceOpensLe_inverse'_map"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">generateEquivalenceOpensLe_inverse'_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../../../.././Mathlib/Topology/Category/TopCat/Basic.html#TopCat">TopCat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hY : <span class="fn"><span class="fn">Y</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Order/CompleteLattice.html#iSup">iSup</a> <span class="fn">U</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">x </span>x_1 : <span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.OpensLeCover">TopCat.Presheaf.SheafCondition.OpensLeCover</a> <span class="fn">U</span></span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">x</span> <a href="../../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">x_1</span></span>),
  <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.generateEquivalenceOpensLe_inverse'">TopCat.Presheaf.generateEquivalenceOpensLe_inverse'</a> <span class="fn">U</span> <span class="fn">hY</span></span>)</span>.map <span class="fn">g</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.homMk">CategoryTheory.Over.homMk</a> <span class="fn">g</span></span></span></span></div></div></div></div><div class="decl" id="TopCat.Presheaf.generateEquivalenceOpensLe_inverse'_obj_obj_right_as"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.lean#L138-L138">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.generateEquivalenceOpensLe_inverse'_obj_obj_right_as"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">generateEquivalenceOpensLe_inverse'_obj_obj_right_as</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../../../.././Mathlib/Topology/Category/TopCat/Basic.html#TopCat">TopCat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hY : <span class="fn"><span class="fn">Y</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Order/CompleteLattice.html#iSup">iSup</a> <span class="fn">U</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(V : <span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.OpensLeCover">TopCat.Presheaf.SheafCondition.OpensLeCover</a> <span class="fn">U</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.generateEquivalenceOpensLe_inverse'">TopCat.Presheaf.generateEquivalenceOpensLe_inverse'</a> <span class="fn">U</span> <span class="fn">hY</span></span>)</span>.obj <span class="fn">V</span></span>)</span>.obj</span>.right</span>.as</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <a href="../../../.././Init/Prelude.html#PUnit.unit">PUnit.unit</a></span></div></div></div></div><div class="decl" id="TopCat.Presheaf.generateEquivalenceOpensLe_inverse'_obj_obj_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.lean#L138-L138">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.generateEquivalenceOpensLe_inverse'_obj_obj_left"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">generateEquivalenceOpensLe_inverse'_obj_obj_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../../../.././Mathlib/Topology/Category/TopCat/Basic.html#TopCat">TopCat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hY : <span class="fn"><span class="fn">Y</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Order/CompleteLattice.html#iSup">iSup</a> <span class="fn">U</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(V : <span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.OpensLeCover">TopCat.Presheaf.SheafCondition.OpensLeCover</a> <span class="fn">U</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.generateEquivalenceOpensLe_inverse'">TopCat.Presheaf.generateEquivalenceOpensLe_inverse'</a> <span class="fn">U</span> <span class="fn">hY</span></span>)</span>.obj <span class="fn">V</span></span>)</span>.obj</span>.left</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">V</span>.obj</span></span></div></div></div></div><div class="decl" id="TopCat.Presheaf.generateEquivalenceOpensLe_inverse'_obj_obj_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.lean#L138-L138">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.generateEquivalenceOpensLe_inverse'_obj_obj_hom"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">generateEquivalenceOpensLe_inverse'_obj_obj_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../../../.././Mathlib/Topology/Category/TopCat/Basic.html#TopCat">TopCat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hY : <span class="fn"><span class="fn">Y</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Order/CompleteLattice.html#iSup">iSup</a> <span class="fn">U</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(V : <span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.OpensLeCover">TopCat.Presheaf.SheafCondition.OpensLeCover</a> <span class="fn">U</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.generateEquivalenceOpensLe_inverse'">TopCat.Presheaf.generateEquivalenceOpensLe_inverse'</a> <span class="fn">U</span> <span class="fn">hY</span></span>)</span>.obj <span class="fn">V</span></span>)</span>.obj</span>.hom</span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.homOfLE">CategoryTheory.homOfLE</a>
    <span class="fn">(_ :
      <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span>)</span></span>)</span>.obj <span class="fn"><span class="fn">V</span>.obj</span></span> <a href="../../../.././Init/Prelude.html#LE.le">≤</a>         <span class="fn"><span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">Y</span></span>)</span>.obj <span class="fn">{ <span class="fn">as</span> := <a href="../../../.././Init/Prelude.html#PUnit.unit">PUnit.unit</a> }</span></span></span>)</span></span></span></div></div></div></div><div class="decl" id="TopCat.Presheaf.generateEquivalenceOpensLe_inverse'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.lean#L139-L154">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.generateEquivalenceOpensLe_inverse'"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">generateEquivalenceOpensLe_inverse'</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../../../.././Mathlib/Topology/Category/TopCat/Basic.html#TopCat">TopCat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hY : <span class="fn"><span class="fn">Y</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Order/CompleteLattice.html#iSup">iSup</a> <span class="fn">U</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.OpensLeCover">TopCat.Presheaf.SheafCondition.OpensLeCover</a> <span class="fn">U</span></span>)</span>
  <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/FullSubcategory.html#CategoryTheory.FullSubcategory">CategoryTheory.FullSubcategory</a> <span class="fn">fun (<span class="fn">f</span> : <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">Y</span></span>) =&gt;
    <span class="fn"><span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.generate">CategoryTheory.Sieve.generate</a> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/Sites.html#TopCat.Presheaf.presieveOfCoveringAux">TopCat.Presheaf.presieveOfCoveringAux</a> <span class="fn">U</span> <span class="fn">Y</span></span>)</span></span>)</span>.arrows <span class="fn"><span class="fn">f</span>.hom</span></span></span></span>)</span></span></div></div><p>Given a family of opens <code>U</code> and an open <code>Y</code> equal to the union of opens in <code>U</code>, we may
take the presieve on <code>Y</code> associated to <code>U</code> and the sieve generated by it, and form the
full subcategory (subposet) of opens contained in <code>Y</code> (<code>over Y</code>) consisting of arrows
in the sieve. This full subcategory is equivalent to <code><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.OpensLeCover">OpensLeCover</a> U</code>, the (poset)
category of opens contained in some <code>U i</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-TopCat.Presheaf.generateEquivalenceOpensLe_inverse'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="TopCat.Presheaf.generateEquivalenceOpensLe_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.lean#L161-L161">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.generateEquivalenceOpensLe_unitIso"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">generateEquivalenceOpensLe_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../../../.././Mathlib/Topology/Category/TopCat/Basic.html#TopCat">TopCat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hY : <span class="fn"><span class="fn">Y</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Order/CompleteLattice.html#iSup">iSup</a> <span class="fn">U</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.generateEquivalenceOpensLe">TopCat.Presheaf.generateEquivalenceOpensLe</a> <span class="fn">U</span> <span class="fn">hY</span></span>)</span>.unitIso</span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToIso">CategoryTheory.eqToIso</a>
    <span class="fn">(_ :
      <span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a>
          <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/FullSubcategory.html#CategoryTheory.FullSubcategory">CategoryTheory.FullSubcategory</a> <span class="fn">fun (<span class="fn">f</span> : <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">Y</span></span>) =&gt;
            <span class="fn"><span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.generate">CategoryTheory.Sieve.generate</a> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/Sites.html#TopCat.Presheaf.presieveOfCoveringAux">TopCat.Presheaf.presieveOfCoveringAux</a> <span class="fn">U</span> <span class="fn">Y</span></span>)</span></span>)</span>.arrows <span class="fn"><span class="fn">f</span>.hom</span></span></span></span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>         <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.generateEquivalenceOpensLe_functor'">TopCat.Presheaf.generateEquivalenceOpensLe_functor'</a> <span class="fn">U</span> <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Order/CompleteLattice.html#iSup">iSup</a> <span class="fn">U</span></span></span>)</span></span>)</span>
          <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.generateEquivalenceOpensLe_inverse'">TopCat.Presheaf.generateEquivalenceOpensLe_inverse'</a> <span class="fn">U</span> <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Order/CompleteLattice.html#iSup">iSup</a> <span class="fn">U</span></span></span>)</span></span>)</span></span></span>)</span></span></span></div></div></div></div><div class="decl" id="TopCat.Presheaf.generateEquivalenceOpensLe_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.lean#L161-L161">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.generateEquivalenceOpensLe_inverse"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">generateEquivalenceOpensLe_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../../../.././Mathlib/Topology/Category/TopCat/Basic.html#TopCat">TopCat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hY : <span class="fn"><span class="fn">Y</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Order/CompleteLattice.html#iSup">iSup</a> <span class="fn">U</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.generateEquivalenceOpensLe">TopCat.Presheaf.generateEquivalenceOpensLe</a> <span class="fn">U</span> <span class="fn">hY</span></span>)</span>.inverse</span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.generateEquivalenceOpensLe_inverse'">TopCat.Presheaf.generateEquivalenceOpensLe_inverse'</a> <span class="fn">U</span> <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Order/CompleteLattice.html#iSup">iSup</a> <span class="fn">U</span></span></span>)</span></span></span></div></div></div></div><div class="decl" id="TopCat.Presheaf.generateEquivalenceOpensLe_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.lean#L161-L161">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.generateEquivalenceOpensLe_counitIso"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">generateEquivalenceOpensLe_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../../../.././Mathlib/Topology/Category/TopCat/Basic.html#TopCat">TopCat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hY : <span class="fn"><span class="fn">Y</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Order/CompleteLattice.html#iSup">iSup</a> <span class="fn">U</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.generateEquivalenceOpensLe">TopCat.Presheaf.generateEquivalenceOpensLe</a> <span class="fn">U</span> <span class="fn">hY</span></span>)</span>.counitIso</span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToIso">CategoryTheory.eqToIso</a>
    <span class="fn">(_ :
      <span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.generateEquivalenceOpensLe_inverse'">TopCat.Presheaf.generateEquivalenceOpensLe_inverse'</a> <span class="fn">U</span> <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Order/CompleteLattice.html#iSup">iSup</a> <span class="fn">U</span></span></span>)</span></span>)</span>
          <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.generateEquivalenceOpensLe_functor'">TopCat.Presheaf.generateEquivalenceOpensLe_functor'</a> <span class="fn">U</span> <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Order/CompleteLattice.html#iSup">iSup</a> <span class="fn">U</span></span></span>)</span></span>)</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>         <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.OpensLeCover">TopCat.Presheaf.SheafCondition.OpensLeCover</a> <span class="fn">U</span></span>)</span></span></span>)</span></span></span></div></div></div></div><div class="decl" id="TopCat.Presheaf.generateEquivalenceOpensLe_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.lean#L161-L161">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.generateEquivalenceOpensLe_functor"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">generateEquivalenceOpensLe_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../../../.././Mathlib/Topology/Category/TopCat/Basic.html#TopCat">TopCat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hY : <span class="fn"><span class="fn">Y</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Order/CompleteLattice.html#iSup">iSup</a> <span class="fn">U</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.generateEquivalenceOpensLe">TopCat.Presheaf.generateEquivalenceOpensLe</a> <span class="fn">U</span> <span class="fn">hY</span></span>)</span>.functor</span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.generateEquivalenceOpensLe_functor'">TopCat.Presheaf.generateEquivalenceOpensLe_functor'</a> <span class="fn">U</span> <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Order/CompleteLattice.html#iSup">iSup</a> <span class="fn">U</span></span></span>)</span></span></span></div></div></div></div><div class="decl" id="TopCat.Presheaf.generateEquivalenceOpensLe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.lean#L162-L172">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.generateEquivalenceOpensLe"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">generateEquivalenceOpensLe</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../../../.././Mathlib/Topology/Category/TopCat/Basic.html#TopCat">TopCat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hY : <span class="fn"><span class="fn">Y</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Order/CompleteLattice.html#iSup">iSup</a> <span class="fn">U</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/FullSubcategory.html#CategoryTheory.FullSubcategory">CategoryTheory.FullSubcategory</a> <span class="fn">fun (<span class="fn">f</span> : <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">Y</span></span>) =&gt;
    <span class="fn"><span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.generate">CategoryTheory.Sieve.generate</a> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/Sites.html#TopCat.Presheaf.presieveOfCoveringAux">TopCat.Presheaf.presieveOfCoveringAux</a> <span class="fn">U</span> <span class="fn">Y</span></span>)</span></span>)</span>.arrows <span class="fn"><span class="fn">f</span>.hom</span></span></span></span>)</span> <a href="../../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a>   <span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.OpensLeCover">TopCat.Presheaf.SheafCondition.OpensLeCover</a> <span class="fn">U</span></span></span></div></div><p>Given a family of opens <code>U</code> and an open <code>Y</code> equal to the union of opens in <code>U</code>, we may
take the presieve on <code>Y</code> associated to <code>U</code> and the sieve generated by it, and form the
full subcategory (subposet) of opens contained in <code>Y</code> (<code>over Y</code>) consisting of arrows
in the sieve. This full subcategory is equivalent to <code><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.OpensLeCover">OpensLeCover</a> U</code>, the (poset)
category of opens contained in some <code>U i</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-TopCat.Presheaf.generateEquivalenceOpensLe" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="TopCat.Presheaf.whiskerIsoMapGenerateCocone_hom_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.lean#L179-L179">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.whiskerIsoMapGenerateCocone_hom_hom"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">whiskerIsoMapGenerateCocone_hom_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../../../.././Mathlib/Topology/Category/TopCat/Basic.html#TopCat">TopCat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/Presheaf.html#TopCat.Presheaf">TopCat.Presheaf</a> <span class="fn">C</span> <span class="fn">X</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hY : <span class="fn"><span class="fn">Y</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Order/CompleteLattice.html#iSup">iSup</a> <span class="fn">U</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.whiskerIsoMapGenerateCocone">TopCat.Presheaf.whiskerIsoMapGenerateCocone</a> <span class="fn">F</span> <span class="fn">U</span> <span class="fn">hY</span></span>)</span>.hom</span>.hom</span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">F</span>.map
    <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom">CategoryTheory.eqToHom</a>
      <span class="fn">(_ :
        <span class="fn"><span class="fn"><a href="../../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn"><span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.opensLeCoverCocone">TopCat.Presheaf.SheafCondition.opensLeCoverCocone</a> <span class="fn">U</span></span>)</span>.pt</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>           <span class="fn"><a href="../../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a>
            <span class="fn"><span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.cocone">CategoryTheory.Presieve.cocone</a>
                <span class="fn"><span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.generate">CategoryTheory.Sieve.generate</a> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/Sites.html#TopCat.Presheaf.presieveOfCoveringAux">TopCat.Presheaf.presieveOfCoveringAux</a> <span class="fn">U</span> <span class="fn">Y</span></span>)</span></span>)</span>.arrows</span></span>)</span>.pt</span></span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="TopCat.Presheaf.whiskerIsoMapGenerateCocone_inv_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.lean#L179-L179">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.whiskerIsoMapGenerateCocone_inv_hom"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">whiskerIsoMapGenerateCocone_inv_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../../../.././Mathlib/Topology/Category/TopCat/Basic.html#TopCat">TopCat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/Presheaf.html#TopCat.Presheaf">TopCat.Presheaf</a> <span class="fn">C</span> <span class="fn">X</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hY : <span class="fn"><span class="fn">Y</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Order/CompleteLattice.html#iSup">iSup</a> <span class="fn">U</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.whiskerIsoMapGenerateCocone">TopCat.Presheaf.whiskerIsoMapGenerateCocone</a> <span class="fn">F</span> <span class="fn">U</span> <span class="fn">hY</span></span>)</span>.inv</span>.hom</span> <a href="../../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><span class="fn">F</span>.map
    <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/EqToHom.html#CategoryTheory.eqToHom">CategoryTheory.eqToHom</a>
      <span class="fn">(_ :
        <span class="fn"><span class="fn"><a href="../../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a>
            <span class="fn"><span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.cocone">CategoryTheory.Presieve.cocone</a>
                <span class="fn"><span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.generate">CategoryTheory.Sieve.generate</a> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/Sites.html#TopCat.Presheaf.presieveOfCoveringAux">TopCat.Presheaf.presieveOfCoveringAux</a> <span class="fn">U</span> <span class="fn">Y</span></span>)</span></span>)</span>.arrows</span></span>)</span>.pt</span></span> <a href="../../../.././Init/Prelude.html#Eq">=</a>           <span class="fn"><a href="../../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn"><span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.opensLeCoverCocone">TopCat.Presheaf.SheafCondition.opensLeCoverCocone</a> <span class="fn">U</span></span>)</span>.pt</span></span></span>)</span></span>)</span></span></span></div></div></div></div><div class="decl" id="TopCat.Presheaf.whiskerIsoMapGenerateCocone"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.lean#L180-L200">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.whiskerIsoMapGenerateCocone"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">whiskerIsoMapGenerateCocone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../../../.././Mathlib/Topology/Category/TopCat/Basic.html#TopCat">TopCat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/Presheaf.html#TopCat.Presheaf">TopCat.Presheaf</a> <span class="fn">C</span> <span class="fn">X</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hY : <span class="fn"><span class="fn">Y</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Order/CompleteLattice.html#iSup">iSup</a> <span class="fn">U</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone.whisker">CategoryTheory.Limits.Cone.whisker</a>
    <span class="fn"><span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Opposites.html#CategoryTheory.Equivalence.op">CategoryTheory.Equivalence.op</a> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.generateEquivalenceOpensLe">TopCat.Presheaf.generateEquivalenceOpensLe</a> <span class="fn">U</span> <span class="fn">hY</span></span>)</span></span>)</span>.functor</span>
    <span class="fn">(<span class="fn"><span class="fn">F</span>.mapCone <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.op">CategoryTheory.Limits.Cocone.op</a> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.opensLeCoverCocone">TopCat.Presheaf.SheafCondition.opensLeCoverCocone</a> <span class="fn">U</span></span>)</span></span>)</span></span>)</span></span> <a href="../../../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a>   <span class="fn"><span class="fn">F</span>.mapCone
    <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.op">CategoryTheory.Limits.Cocone.op</a>
      <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.cocone">CategoryTheory.Presieve.cocone</a>
        <span class="fn"><span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.generate">CategoryTheory.Sieve.generate</a> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/Sites.html#TopCat.Presheaf.presieveOfCoveringAux">TopCat.Presheaf.presieveOfCoveringAux</a> <span class="fn">U</span> <span class="fn">Y</span></span>)</span></span>)</span>.arrows</span></span>)</span></span>)</span></span></span></div></div><p>Given a family of opens <code><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.opensLeCoverCocone">opensLeCoverCocone</a> U</code> is essentially the natural cocone
associated to the sieve generated by the presieve associated to <code>U</code> with indexing
category changed using the above equivalence.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-TopCat.Presheaf.whiskerIsoMapGenerateCocone" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="TopCat.Presheaf.isLimitOpensLeEquivGenerate₁"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.lean#L208-L212">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.isLimitOpensLeEquivGenerate₁"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">isLimitOpensLeEquivGenerate₁</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../../../.././Mathlib/Topology/Category/TopCat/Basic.html#TopCat">TopCat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/Presheaf.html#TopCat.Presheaf">TopCat.Presheaf</a> <span class="fn">C</span> <span class="fn">X</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{ι : <a href="../../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><span class="fn">ι</span> → <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hY : <span class="fn"><span class="fn">Y</span> <a href="../../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../../.././Mathlib/Order/CompleteLattice.html#iSup">iSup</a> <span class="fn">U</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit">CategoryTheory.Limits.IsLimit</a>
    <span class="fn">(<span class="fn"><span class="fn">F</span>.mapCone <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.op">CategoryTheory.Limits.Cocone.op</a> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.opensLeCoverCocone">TopCat.Presheaf.SheafCondition.opensLeCoverCocone</a> <span class="fn">U</span></span>)</span></span>)</span></span>)</span></span> <a href="../../../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a>   <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit">CategoryTheory.Limits.IsLimit</a>
    <span class="fn">(<span class="fn"><span class="fn">F</span>.mapCone
      <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.op">CategoryTheory.Limits.Cocone.op</a>
        <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.cocone">CategoryTheory.Presieve.cocone</a>
          <span class="fn"><span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.generate">CategoryTheory.Sieve.generate</a> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/Sites.html#TopCat.Presheaf.presieveOfCoveringAux">TopCat.Presheaf.presieveOfCoveringAux</a> <span class="fn">U</span> <span class="fn">Y</span></span>)</span></span>)</span>.arrows</span></span>)</span></span>)</span></span>)</span></span></span></div></div><p>Given a presheaf <code>F</code> on the topological space <code>X</code> and a family of opens <code>U</code> of <code>X</code>,
the natural cone associated to <code>F</code> and <code>U</code> used in the definition of
<code>F.<a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.IsSheafOpensLeCover">IsSheafOpensLeCover</a></code> is a limit cone iff the natural cone associated to <code>F</code>
and the sieve generated by the presieve associated to <code>U</code> is a limit cone.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-TopCat.Presheaf.isLimitOpensLeEquivGenerate₁" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="TopCat.Presheaf.isLimitOpensLeEquivGenerate₂"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.lean#L223-L229">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.isLimitOpensLeEquivGenerate₂"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">isLimitOpensLeEquivGenerate₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../../../.././Mathlib/Topology/Category/TopCat/Basic.html#TopCat">TopCat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/Presheaf.html#TopCat.Presheaf">TopCat.Presheaf</a> <span class="fn">C</span> <span class="fn">X</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../../../.././Mathlib/Topology/Sets/Opens.html#TopologicalSpace.Opens">TopologicalSpace.Opens</a> <span class="fn">↑<span class="fn">X</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(R : <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve">CategoryTheory.Presieve</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hR : <span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.generate">CategoryTheory.Sieve.generate</a> <span class="fn">R</span></span> <a href="../../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Sites/Grothendieck.html#CategoryTheory.GrothendieckTopology.sieves">CategoryTheory.GrothendieckTopology.sieves</a> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Sites/Spaces.html#Opens.grothendieckTopology">Opens.grothendieckTopology</a> <span class="fn">↑<span class="fn">X</span></span></span>)</span> <span class="fn">Y</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit">CategoryTheory.Limits.IsLimit</a>
    <span class="fn">(<span class="fn"><span class="fn">F</span>.mapCone
      <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.op">CategoryTheory.Limits.Cocone.op</a>
        <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.SheafCondition.opensLeCoverCocone">TopCat.Presheaf.SheafCondition.opensLeCoverCocone</a> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/Sites.html#TopCat.Presheaf.coveringOfPresieve">TopCat.Presheaf.coveringOfPresieve</a> <span class="fn">Y</span> <span class="fn">R</span></span>)</span></span>)</span></span>)</span></span>)</span></span> <a href="../../../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a>   <span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsLimit">CategoryTheory.Limits.IsLimit</a>
    <span class="fn">(<span class="fn"><span class="fn">F</span>.mapCone
      <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone.op">CategoryTheory.Limits.Cocone.op</a> <span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.cocone">CategoryTheory.Presieve.cocone</a> <span class="fn"><span class="fn">(<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Sieve.generate">CategoryTheory.Sieve.generate</a> <span class="fn">R</span></span>)</span>.arrows</span></span>)</span></span>)</span></span>)</span></span></span></div></div><p>Given a presheaf <code>F</code> on the topological space <code>X</code> and a presieve <code>R</code> whose generated sieve
is covering for the associated Grothendieck topology (equivalently, the presieve is covering
for the associated pretopology), the natural cone associated to <code>F</code> and the family of opens
associated to <code>R</code> is a limit cone iff the natural cone associated to <code>F</code> and the generated
sieve is a limit cone.
Since only the existence of a 1-1 correspondence will be used, the exact definition does
not matter, so tactics are used liberally.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-TopCat.Presheaf.isLimitOpensLeEquivGenerate₂" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="TopCat.Presheaf.isSheaf_iff_isSheafOpensLeCover"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.lean#L237-L248">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.isSheaf_iff_isSheafOpensLeCover"><span class="name">TopCat</span>.<span class="name">Presheaf</span>.<span class="name">isSheaf_iff_isSheafOpensLeCover</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <a href="../../../.././Mathlib/Topology/Category/TopCat/Basic.html#TopCat">TopCat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/Presheaf.html#TopCat.Presheaf">TopCat.Presheaf</a> <span class="fn">C</span> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/Sheaf.html#TopCat.Presheaf.IsSheaf">TopCat.Presheaf.IsSheaf</a> <span class="fn">F</span></span> <a href="../../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.IsSheafOpensLeCover">TopCat.Presheaf.IsSheafOpensLeCover</a> <span class="fn">F</span></span></span></div></div><p>A presheaf <code>(opens X)ᵒᵖ ⥤ C</code> on a topological space <code>X</code> is a sheaf on the site <code>opens X</code> iff
it satisfies the <code><a href="../../../.././Mathlib/Topology/Sheaves/SheafCondition/OpensLeCover.html#TopCat.Presheaf.IsSheafOpensLeCover">IsSheafOpensLeCover</a></code> sheaf condition. The latter is not the
official definition of sheaves on spaces, but has the advantage that it does not
require <code>has_products C</code>.</p></div></div></main>
<nav class="nav"><iframe src="../../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>