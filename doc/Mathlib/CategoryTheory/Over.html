<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="stylesheet" href="../.././src/pygments.css"></link><link rel="shortcut icon" href="../.././favicon.ico"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.CategoryTheory.Over</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.CategoryTheory.Over";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">CategoryTheory</span>.<span class="name">Over</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;
            <button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/CategoryTheory/PUnit.html">Mathlib.CategoryTheory.PUnit</a></li><li><a href="../.././Mathlib/CategoryTheory/StructuredArrow.html">Mathlib.CategoryTheory.StructuredArrow</a></li><li><a href="../.././Mathlib/CategoryTheory/Functor/EpiMono.html">Mathlib.CategoryTheory.Functor.EpiMono</a></li><li><a href="../.././Mathlib/CategoryTheory/Functor/ReflectsIso.html">Mathlib.CategoryTheory.Functor.ReflectsIso</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.CategoryTheory.Over" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over"><span class="name">CategoryTheory</span>.<span class="name">Over</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instCategoryOver"><span class="name">CategoryTheory</span>.<span class="name">instCategoryOver</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.inhabited"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">inhabited</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.OverMorphism.ext"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">OverMorphism</span>.<span class="name">ext</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.over_right"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">over_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.id_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">id_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.comp_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">comp_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.w_assoc"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">w_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.w"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">w</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mk_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mk_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mk_hom"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mk_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mk"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mk</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.coeFromHom"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">coeFromHom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.coe_hom"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">coe_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.homMk_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">homMk_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.homMk_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">homMk_right_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.homMk"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">homMk</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.isoMk_hom_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">isoMk_hom_right_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.isoMk_inv_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">isoMk_inv_right_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.isoMk_inv_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">isoMk_inv_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.isoMk_hom_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">isoMk_hom_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.isoMk"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">isoMk</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.forget"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forget</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.forget_obj"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forget_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.forget_map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forget_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.forgetCocone_ι_app"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forgetCocone_ι_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.forgetCocone_pt"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forgetCocone_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.forgetCocone"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forgetCocone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.map_obj_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">map_obj_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.map_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">map_obj_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.map_map_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">map_map_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mapId"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapId</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mapComp"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapComp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.forget_reflects_iso"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forget_reflects_iso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mkIdTerminal"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mkIdTerminal</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.forget_faithful"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forget_faithful</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.epi_of_epi_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">epi_of_epi_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mono_of_mono_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mono_of_mono_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.mono_left_of_mono"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mono_left_of_mono</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceForward_obj"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceForward_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceForward_map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceForward_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceForward"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceForward</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceBackward_obj"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceBackward_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceBackward_map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceBackward_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceBackward"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceBackward</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceEquiv_functor"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceEquiv_functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceEquiv_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceEquiv_unitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceEquiv_inverse"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceEquiv_inverse</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceEquiv_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceEquiv_counitIso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceEquiv"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceEquiv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceForward_forget"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceForward_forget</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.iteratedSliceBackward_forget_forget"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceBackward_forget_forget</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.post_obj"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">post_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.post_map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">post_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Over.post"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">post</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.toOver_obj_right"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver_obj_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.toOver_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver_obj_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.toOver_map_right"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver_map_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.toOver_map_left"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver_map_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.toOver_obj_left"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver_obj_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.toOver"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.instFaithfulCostructuredArrowInstCategoryCostructuredArrowOverInstCategoryOverToOver"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">instFaithfulCostructuredArrowInstCategoryCostructuredArrowOverInstCategoryOverToOver</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.instFullCostructuredArrowInstCategoryCostructuredArrowOverInstCategoryOverToOver"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">instFullCostructuredArrowInstCategoryCostructuredArrowOverInstCategoryOverToOver</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.instEssSurjCostructuredArrowOverInstCategoryCostructuredArrowInstCategoryOverToOver"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">instEssSurjCostructuredArrowOverInstCategoryCostructuredArrowInstCategoryOverToOver</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.CostructuredArrow.isEquivalenceToOver"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">isEquivalenceToOver</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under"><span class="name">CategoryTheory</span>.<span class="name">Under</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instCategoryUnder"><span class="name">CategoryTheory</span>.<span class="name">instCategoryUnder</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.inhabited"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">inhabited</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.UnderMorphism.ext"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">UnderMorphism</span>.<span class="name">ext</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.under_left"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">under_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.id_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">id_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.comp_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">comp_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.w_assoc"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">w_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.w"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">w</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mk_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mk_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mk_hom"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mk_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mk"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mk</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.homMk_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">homMk_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.homMk_left_down_down"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">homMk_left_down_down</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.homMk"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">homMk</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.isoMk"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">isoMk</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.isoMk_hom_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">isoMk_hom_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.isoMk_inv_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">isoMk_inv_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.forget"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forget</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.forget_obj"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forget_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.forget_map"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forget_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.forgetCone_pt"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forgetCone_pt</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.forgetCone_π_app"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forgetCone_π_app</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.forgetCone"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forgetCone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.map"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.map_obj_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">map_obj_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.map_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">map_obj_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.map_map_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">map_map_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mapId"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapId</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mapComp"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapComp</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.forget_reflects_iso"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forget_reflects_iso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mkIdInitial"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mkIdInitial</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.forget_faithful"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forget_faithful</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.mono_of_mono_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mono_of_mono_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.epi_of_epi_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">epi_of_epi_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.epi_right_of_epi"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">epi_right_of_epi</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.post_obj"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">post_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.post_map"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">post_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Under.post"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">post</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.toUnder_map_left"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder_map_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.toUnder_obj_left"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder_obj_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.toUnder_map_right"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder_map_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.toUnder_obj_right"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder_obj_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.toUnder_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder_obj_hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.toUnder"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.instFaithfulStructuredArrowInstCategoryStructuredArrowUnderInstCategoryUnderToUnder"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">instFaithfulStructuredArrowInstCategoryStructuredArrowUnderInstCategoryUnderToUnder</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.instFullStructuredArrowInstCategoryStructuredArrowUnderInstCategoryUnderToUnder"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">instFullStructuredArrowInstCategoryStructuredArrowUnderInstCategoryUnderToUnder</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.instEssSurjStructuredArrowUnderInstCategoryStructuredArrowInstCategoryUnderToUnder"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">instEssSurjStructuredArrowUnderInstCategoryStructuredArrowInstCategoryUnderToUnder</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.StructuredArrow.isEquivalenceToUnder"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">isEquivalenceToUnder</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.toOver_map_left"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toOver_map_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.toOver_obj_left"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toOver_obj_left</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.toOver"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toOver</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.toOverCompForget"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toOverCompForget</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.toOver_comp_forget"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toOver_comp_forget</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.toUnder_obj_right"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toUnder_obj_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.toUnder_map_right"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toUnder_map_right</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.toUnder"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toUnder</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.toUnderCompForget"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toUnderCompForget</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.toUnder_comp_forget"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toUnder_comp_forget</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Over-and-under-categories">Over and under categories <a class="hover-link" href="#Over-and-under-categories">#</a></h1><p>Over (and under) categories are special cases of comma categories.</p><ul>
<li>If <code>L</code> is the identity functor and <code>R</code> is a constant functor, then <code>Comma L R</code> is the "slice" or
"over" category over the object <code>R</code> maps to.</li>
<li>Conversely, if <code>L</code> is a constant functor and <code>R</code> is the identity functor, then <code>Comma L R</code> is the
"coslice" or "under" category under the object <code>L</code> maps to.</li>
</ul><h2 class="markdown-heading" id="Tags">Tags <a class="hover-link" href="#Tags">#</a></h2><p>Comma, Slice, Coslice, Over, Under</p></div><div class="decl" id="CategoryTheory.Over"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L40-L41">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over"><span class="name">CategoryTheory</span>.<span class="name">Over</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> (max u₁ v₁)</div></div><p>The over category has as objects arrows in <code>T</code> with codomain <code>X</code> and as morphisms commutative
triangles.</p><p>See <https://stacks.math.columbia.edu/tag/001G>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/StructuredArrow.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span> <span class="fn">X</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.instCategoryOver"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L44-L44">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.instCategoryOver"><span class="name">CategoryTheory</span>.<span class="name">instCategoryOver</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, max u₁ v₁}</a>            <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.instCategoryOver">CategoryTheory.instCategoryOver</a> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">CategoryTheory.commaCategory</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Over.inhabited"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L47-L51">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.inhabited"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">inhabited</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">default</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">CategoryTheory.Over.inhabited</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{
    <span class="fn">default</span> :=
      <span class="fn">{ <span class="fn">left</span> := <span class="fn">default</span>, <span class="fn">right</span> := <span class="fn">default</span>,
        <span class="fn">hom</span> := <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span>.obj <span class="fn">default</span></span>)</span></span> }</span> }</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Over.OverMorphism.ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L59-L63">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.OverMorphism.ext"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">OverMorphism</span>.<span class="name">ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{V : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">U</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">V</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">U</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">V</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">f</span>.left</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span>.left</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.over_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L67-L67">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.over_right"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">over_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">U</span>.right</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">as</span> := <a href="../.././Init/Prelude.html#PUnit.unit">PUnit.unit</a> }</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.id_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L71-L72">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.id_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">id_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">U</span></span>)</span>.left</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">U</span>.left</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.comp_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L76-L77">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.comp_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">comp_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">a</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">b</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span>.left</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.left</span> <span class="fn"><span class="fn">g</span>.left</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.w_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L80-L80">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.w_assoc"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">w_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">A</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span></span>)</span>.obj <span class="fn"><span class="fn">B</span>.right</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.left</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">B</span>.hom</span> <span class="fn">h</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">A</span>.hom</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.w"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L81-L81">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.w"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">w</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">A</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.left</span> <span class="fn"><span class="fn">B</span>.hom</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">A</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.mk_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L85-L85">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.mk_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mk_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.mk">CategoryTheory.Over.mk</a> <span class="fn">f</span></span>)</span>.left</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">Y</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.mk_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L85-L85">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.mk_hom"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mk_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.mk">CategoryTheory.Over.mk</a> <span class="fn">f</span></span>)</span>.hom</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.mk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L86-L87">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.mk"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span></div></div><p>To give an object in the over category, it suffices to give a morphism with codomain <code>X</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.mk">CategoryTheory.Over.mk</a> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/StructuredArrow.html#CategoryTheory.CostructuredArrow.mk">CategoryTheory.CostructuredArrow.mk</a> <span class="fn">f</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.mk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.coeFromHom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L92-L92">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.coeFromHom"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">coeFromHom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Coe.html#CoeOut">CoeOut</a> <span class="fn">(<span class="fn"><span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span></div></div><p>We can set up a coercion from arrows with codomain <code>X</code> to <code>over X</code>. This most likely should not
be a global instance, but it is sometimes useful.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">CategoryTheory.Over.coeFromHom</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">coe</span> := <span class="fn">CategoryTheory.Over.mk</span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.coeFromHom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.coe_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L100-L101">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.coe_hom"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">coe_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.mk">CategoryTheory.Over.mk</a> <span class="fn">f</span></span>)</span>.hom</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.homMk_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L108-L108">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.homMk_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">homMk_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{V : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">U</span>.left</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">V</span>.left</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../.././Init/Meta.html#autoParam">autoParam</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn"><span class="fn">V</span>.hom</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">U</span>.hom</span></span>)</span> <a href="../.././Mathlib/CategoryTheory/Over.html#_auto._@.Mathlib.CategoryTheory.Over._hyg.447">_auto✝</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.homMk">CategoryTheory.Over.homMk</a> <span class="fn">f</span></span>)</span>.left</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.homMk_right_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L108-L108">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.homMk_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">homMk_right_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{V : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">U</span>.left</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">V</span>.left</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../.././Init/Meta.html#autoParam">autoParam</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn"><span class="fn">V</span>.hom</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">U</span>.hom</span></span>)</span> <a href="../.././Mathlib/CategoryTheory/Over.html#_auto._@.Mathlib.CategoryTheory.Over._hyg.447">_auto✝</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(_ : <span class="fn"><span class="fn"><span class="fn"><span class="fn">V</span>.right</span>.as</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">V</span>.right</span>.as</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(_ : <span class="fn"><span class="fn"><span class="fn"><span class="fn">V</span>.right</span>.as</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">V</span>.right</span>.as</span></span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.homMk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L109-L110">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.homMk"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">homMk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{V : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">U</span>.left</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">V</span>.left</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../.././Init/Meta.html#autoParam">autoParam</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn"><span class="fn">V</span>.hom</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">U</span>.hom</span></span>)</span> <a href="../.././Mathlib/CategoryTheory/Over.html#_auto._@.Mathlib.CategoryTheory.Over._hyg.447">_auto✝</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">U</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">V</span></span></div></div><p>To give a morphism in the over category, it suffices to give an arrow fitting in a commutative
triangle.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.homMk">CategoryTheory.Over.homMk</a> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/StructuredArrow.html#CategoryTheory.CostructuredArrow.homMk">CategoryTheory.CostructuredArrow.homMk</a> <span class="fn">f</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.homMk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.isoMk_hom_right_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L119-L119">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.isoMk_hom_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">isoMk_hom_right_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hl : <span class="fn"><span class="fn"><span class="fn">f</span>.left</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">g</span>.left</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hw : <span class="fn"><a href="../.././Init/Meta.html#autoParam">autoParam</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">hl</span>.hom</span> <span class="fn"><span class="fn">g</span>.hom</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.hom</span></span>)</span> <a href="../.././Mathlib/CategoryTheory/Over.html#_auto._@.Mathlib.CategoryTheory.Over._hyg.511">_auto✝</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(_ : <span class="fn"><span class="fn"><span class="fn"><span class="fn">g</span>.right</span>.as</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">g</span>.right</span>.as</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(_ : <span class="fn"><span class="fn"><span class="fn"><span class="fn">g</span>.right</span>.as</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">g</span>.right</span>.as</span></span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.isoMk_inv_right_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L119-L119">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.isoMk_inv_right_down_down"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">isoMk_inv_right_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hl : <span class="fn"><span class="fn"><span class="fn">f</span>.left</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">g</span>.left</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hw : <span class="fn"><a href="../.././Init/Meta.html#autoParam">autoParam</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">hl</span>.hom</span> <span class="fn"><span class="fn">g</span>.hom</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.hom</span></span>)</span> <a href="../.././Mathlib/CategoryTheory/Over.html#_auto._@.Mathlib.CategoryTheory.Over._hyg.511">_auto✝</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(_ : <span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.right</span>.as</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">f</span>.right</span>.as</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(_ : <span class="fn"><span class="fn"><span class="fn"><span class="fn">f</span>.right</span>.as</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">f</span>.right</span>.as</span></span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.isoMk_inv_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L119-L119">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.isoMk_inv_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">isoMk_inv_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hl : <span class="fn"><span class="fn"><span class="fn">f</span>.left</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">g</span>.left</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hw : <span class="fn"><a href="../.././Init/Meta.html#autoParam">autoParam</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">hl</span>.hom</span> <span class="fn"><span class="fn">g</span>.hom</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.hom</span></span>)</span> <a href="../.././Mathlib/CategoryTheory/Over.html#_auto._@.Mathlib.CategoryTheory.Over._hyg.511">_auto✝</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.isoMk">CategoryTheory.Over.isoMk</a> <span class="fn">hl</span></span>)</span>.inv</span>.left</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">hl</span>.inv</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.isoMk_hom_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L119-L119">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.isoMk_hom_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">isoMk_hom_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hl : <span class="fn"><span class="fn"><span class="fn">f</span>.left</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">g</span>.left</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hw : <span class="fn"><a href="../.././Init/Meta.html#autoParam">autoParam</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">hl</span>.hom</span> <span class="fn"><span class="fn">g</span>.hom</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.hom</span></span>)</span> <a href="../.././Mathlib/CategoryTheory/Over.html#_auto._@.Mathlib.CategoryTheory.Over._hyg.511">_auto✝</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.isoMk">CategoryTheory.Over.isoMk</a> <span class="fn">hl</span></span>)</span>.hom</span>.left</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">hl</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.isoMk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L120-L122">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.isoMk"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">isoMk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hl : <span class="fn"><span class="fn"><span class="fn">f</span>.left</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">g</span>.left</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hw : <span class="fn"><a href="../.././Init/Meta.html#autoParam">autoParam</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">hl</span>.hom</span> <span class="fn"><span class="fn">g</span>.hom</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.hom</span></span>)</span> <a href="../.././Mathlib/CategoryTheory/Over.html#_auto._@.Mathlib.CategoryTheory.Over._hyg.511">_auto✝</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">g</span></span></div></div><p>Construct an isomorphism in the over category given isomorphisms of the objects whose forward
direction gives a commutative triangle.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.isoMk">CategoryTheory.Over.isoMk</a> <span class="fn">hl</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/StructuredArrow.html#CategoryTheory.CostructuredArrow.isoMk">CategoryTheory.CostructuredArrow.isoMk</a> <span class="fn">hl</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.isoMk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.forget"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L136-L137">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.forget"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forget</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span> <span class="fn">T</span></span></div></div><p>The forgetful functor mapping an arrow to its domain.</p><p>See <https://stacks.math.columbia.edu/tag/001G>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Comma.html#CategoryTheory.Comma.fst">CategoryTheory.Comma.fst</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.forget" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.forget_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L143-L144">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.forget_obj"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forget_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span></span>)</span>.obj <span class="fn">U</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">U</span>.left</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.forget_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L148-L149">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.forget_map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forget_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{V : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">U</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">V</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span></span>)</span>.map <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.left</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.forgetCocone_ι_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L153-L153">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.forgetCocone_ι_app"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forgetCocone_ι_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(self : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Comma.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.forgetCocone">CategoryTheory.Over.forgetCocone</a> <span class="fn">X</span></span>)</span>.ι</span>.app <span class="fn">self</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">self</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.forgetCocone_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L153-L153">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.forgetCocone_pt"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forgetCocone_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.forgetCocone">CategoryTheory.Over.forgetCocone</a> <span class="fn">X</span></span>)</span>.pt</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">X</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.forgetCocone"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L154-L156">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.forgetCocone"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forgetCocone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span></span>)</span></span></div></div><p>The natural cocone over the forgetful functor <code><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">Over</a> X ⥤ T</code> with cocone point <code>X</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.forgetCocone">CategoryTheory.Over.forgetCocone</a> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">pt</span> := <span class="fn">X</span>, <span class="fn">ι</span> := <span class="fn"><a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.mk">CategoryTheory.NatTrans.mk</a> <span class="fn">CategoryTheory.Comma.hom</span></span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.forgetCocone" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L163-L164">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">Y</span></span>)</span></span></div></div><p>A morphism <code>f : X ⟶ Y</code> induces a functor <code><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">Over</a> X ⥤ <a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">Over</a> Y</code> in the obvious way.</p><p>See <https://stacks.math.columbia.edu/tag/001G>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Comma.html#CategoryTheory.Comma.mapRight">CategoryTheory.Comma.mapRight</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natTrans">CategoryTheory.Discrete.natTrans</a> <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete">CategoryTheory.Discrete</a> <a href="../.././Init/Prelude.html#PUnit">PUnit.{1}</a></span>) =&gt; <span class="fn">f</span></span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.map" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.map_obj_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L172-L173">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.map_obj_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">map_obj_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">f</span></span>)</span>.obj <span class="fn">U</span></span>)</span>.left</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">U</span>.left</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.map_obj_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L177-L178">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.map_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">map_obj_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">f</span></span>)</span>.obj <span class="fn">U</span></span>)</span>.hom</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">U</span>.hom</span> <span class="fn">f</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.map_map_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L182-L183">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.map_map_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">map_map_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{V : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">U</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">V</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">f</span></span>)</span>.map <span class="fn">g</span></span>)</span>.left</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span>.left</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.mapId"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L189-L190">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.mapId"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapId</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(Y : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">Y</span></span>)</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">Y</span></span>)</span></span></span></div></div><p>Mapping by the identity morphism is just the identity functor.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Over.mapId" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.mapComp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L194-L195">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.mapComp"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mapComp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">f</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.map">CategoryTheory.Over.map</a> <span class="fn">g</span></span>)</span></span></span></div></div><p>Mapping by the composite morphism <code>f ≫ g</code> is the same as mapping by <code>f</code> then by <code>g</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Over.mapComp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.forget_reflects_iso"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L200-L206">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.forget_reflects_iso"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forget_reflects_iso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/ReflectsIso.html#CategoryTheory.ReflectsIsomorphisms">CategoryTheory.ReflectsIsomorphisms</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/ReflectsIso.html#CategoryTheory.ReflectsIsomorphisms">CategoryTheory.ReflectsIsomorphisms</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span></span>)</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/ReflectsIso.html#CategoryTheory.ReflectsIsomorphisms">CategoryTheory.ReflectsIsomorphisms</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span></span>)</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Over.mkIdTerminal"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L210-L211">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.mkIdTerminal"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mkIdTerminal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/Terminal.html#CategoryTheory.Limits.IsTerminal">CategoryTheory.Limits.IsTerminal</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.mk">CategoryTheory.Over.mk</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">X</span></span>)</span></span>)</span></span></div></div><p>The identity over <code>X</code> is terminal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">CategoryTheory.Over.mkIdTerminal</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">CategoryTheory.CostructuredArrow.mkIdTerminal</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Over.mkIdTerminal" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.forget_faithful"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L213-L213">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.forget_faithful"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">forget_faithful</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Faithful">CategoryTheory.Faithful</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Faithful">CategoryTheory.Faithful</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span></span>)</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Faithful">CategoryTheory.Faithful</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span></span>)</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Over.epi_of_epi_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L223-L224">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.epi_of_epi_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">epi_of_epi_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(k : <span class="fn"><span class="fn">f</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[hk : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">CategoryTheory.Epi</a> <span class="fn"><span class="fn">k</span>.left</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">CategoryTheory.Epi</a> <span class="fn">k</span></span></div></div><p>If <code>k.left</code> is an epimorphism, then <code>k</code> is an epimorphism. In other words, <code><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.forget">Over.forget</a> X</code> reflects
epimorphisms.
The converse does not hold without additional assumptions on the underlying category, see
<code>CategoryTheory.Over.epi_left_of_epi</code>.</p></div></div><div class="decl" id="CategoryTheory.Over.mono_of_mono_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L234-L235">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.mono_of_mono_left"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mono_of_mono_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(k : <span class="fn"><span class="fn">f</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[hk : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">CategoryTheory.Mono</a> <span class="fn"><span class="fn">k</span>.left</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">CategoryTheory.Mono</a> <span class="fn">k</span></span></div></div><p>If <code>k.left</code> is a monomorphism, then <code>k</code> is a monomorphism. In other words, <code><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.forget">Over.forget</a> X</code> reflects
monomorphisms.
The converse of <code><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.mono_left_of_mono">CategoryTheory.Over.mono_left_of_mono</a></code>.</p><p>This lemma is not an instance, to avoid loops in type class inference.</p></div></div><div class="decl" id="CategoryTheory.Over.mono_left_of_mono"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L243-L250">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.mono_left_of_mono"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">mono_left_of_mono</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(k : <span class="fn"><span class="fn">f</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">CategoryTheory.Mono</a> <span class="fn">k</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">CategoryTheory.Mono</a> <span class="fn"><span class="fn">k</span>.left</span></span></div></div><p>If <code>k</code> is a monomorphism, then <code>k.left</code> is a monomorphism. In other words, <code><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.forget">Over.forget</a> X</code> preserves
monomorphisms.
The converse of <code><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.mono_of_mono_left">CategoryTheory.Over.mono_of_mono_left</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">CategoryTheory.Mono</a> <span class="fn"><span class="fn">k</span>.left</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">CategoryTheory.Mono</a> <span class="fn"><span class="fn">k</span>.left</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceForward_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L258-L258">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.iteratedSliceForward_obj"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceForward_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(α : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">f</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.iteratedSliceForward">CategoryTheory.Over.iteratedSliceForward</a> <span class="fn">f</span></span>)</span>.obj <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.mk">CategoryTheory.Over.mk</a> <span class="fn"><span class="fn"><span class="fn">α</span>.hom</span>.left</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceForward_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L258-L258">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.iteratedSliceForward_map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceForward_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X_1 </span>Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">f</span></span>} (<span class="fn">κ</span> : <span class="fn"><span class="fn">X_1</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>),
  <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.iteratedSliceForward">CategoryTheory.Over.iteratedSliceForward</a> <span class="fn">f</span></span>)</span>.map <span class="fn">κ</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.homMk">CategoryTheory.Over.homMk</a> <span class="fn"><span class="fn"><span class="fn">κ</span>.left</span>.left</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceForward"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L259-L262">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.iteratedSliceForward"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceForward</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">f</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn"><span class="fn">f</span>.left</span></span>)</span></span></div></div><p>Given f : Y ⟶ X, this is the obvious functor from (T/X)/f to T/Y</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Over.iteratedSliceForward" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceBackward_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L266-L266">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.iteratedSliceBackward_obj"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceBackward_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn"><span class="fn">f</span>.left</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.iteratedSliceBackward">CategoryTheory.Over.iteratedSliceBackward</a> <span class="fn">f</span></span>)</span>.obj <span class="fn">g</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.mk">CategoryTheory.Over.mk</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.homMk">CategoryTheory.Over.homMk</a> <span class="fn"><span class="fn">g</span>.hom</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceBackward_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L266-L266">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.iteratedSliceBackward_map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceBackward_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X_1 </span>Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn"><span class="fn">f</span>.left</span></span>} (<span class="fn">α</span> : <span class="fn"><span class="fn">X_1</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>),
  <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.iteratedSliceBackward">CategoryTheory.Over.iteratedSliceBackward</a> <span class="fn">f</span></span>)</span>.map <span class="fn">α</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.homMk">CategoryTheory.Over.homMk</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.homMk">CategoryTheory.Over.homMk</a> <span class="fn"><span class="fn">α</span>.left</span></span>)</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceBackward"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L267-L270">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.iteratedSliceBackward"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceBackward</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn"><span class="fn">f</span>.left</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">f</span></span>)</span></span></div></div><p>Given f : Y ⟶ X, this is the obvious functor from T/Y to (T/X)/f</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Over.iteratedSliceBackward" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceEquiv_functor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L274-L274">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.iteratedSliceEquiv_functor"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceEquiv_functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.iteratedSliceEquiv">CategoryTheory.Over.iteratedSliceEquiv</a> <span class="fn">f</span></span>)</span>.functor</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.iteratedSliceForward">CategoryTheory.Over.iteratedSliceForward</a> <span class="fn">f</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceEquiv_unitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L274-L274">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.iteratedSliceEquiv_unitIso"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceEquiv_unitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.iteratedSliceEquiv">CategoryTheory.Over.iteratedSliceEquiv</a> <span class="fn">f</span></span>)</span>.unitIso</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a> <span class="fn">fun (<span class="fn">g</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">f</span></span>) =&gt;
    <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.isoMk">CategoryTheory.Over.isoMk</a>
      <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.isoMk">CategoryTheory.Over.isoMk</a>
        <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a> <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">f</span></span>)</span></span>)</span>.obj <span class="fn">g</span></span>)</span>.left</span>.left</span></span>)</span></span>)</span></span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceEquiv_inverse"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L274-L274">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.iteratedSliceEquiv_inverse"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceEquiv_inverse</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.iteratedSliceEquiv">CategoryTheory.Over.iteratedSliceEquiv</a> <span class="fn">f</span></span>)</span>.inverse</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.iteratedSliceBackward">CategoryTheory.Over.iteratedSliceBackward</a> <span class="fn">f</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceEquiv_counitIso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L274-L274">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.iteratedSliceEquiv_counitIso"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceEquiv_counitIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.iteratedSliceEquiv">CategoryTheory.Over.iteratedSliceEquiv</a> <span class="fn">f</span></span>)</span>.counitIso</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/NatIso.html#CategoryTheory.NatIso.ofComponents">CategoryTheory.NatIso.ofComponents</a> <span class="fn">fun (<span class="fn">g</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn"><span class="fn">f</span>.left</span></span>) =&gt;
    <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.isoMk">CategoryTheory.Over.isoMk</a>
      <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso.refl">CategoryTheory.Iso.refl</a>
        <span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.iteratedSliceBackward">CategoryTheory.Over.iteratedSliceBackward</a> <span class="fn">f</span></span>)</span>
                <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.iteratedSliceForward">CategoryTheory.Over.iteratedSliceForward</a> <span class="fn">f</span></span>)</span></span>)</span>.obj
            <span class="fn">g</span></span>)</span>.left</span></span>)</span></span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceEquiv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L275-L280">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.iteratedSliceEquiv"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceEquiv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">f</span></span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn"><span class="fn">f</span>.left</span></span></span></div></div><p>Given f : Y ⟶ X, we have an equivalence between (T/X)/f and T/Y</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Over.iteratedSliceEquiv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceForward_forget"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L283-L285">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.iteratedSliceForward_forget"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceForward_forget</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.iteratedSliceForward">CategoryTheory.Over.iteratedSliceForward</a> <span class="fn">f</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn"><span class="fn">f</span>.left</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">f</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.iteratedSliceBackward_forget_forget"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L288-L290">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.iteratedSliceBackward_forget_forget"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">iteratedSliceBackward_forget_forget</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.iteratedSliceBackward">CategoryTheory.Over.iteratedSliceBackward</a> <span class="fn">f</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">f</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span></span>)</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn"><span class="fn">f</span>.left</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.post_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L300-L300">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.post_obj"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">post_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.post">CategoryTheory.Over.post</a> <span class="fn">F</span></span>)</span>.obj <span class="fn">Y</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.mk">CategoryTheory.Over.mk</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.map <span class="fn"><span class="fn">Y</span>.hom</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.post_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L300-L300">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.post_map"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">post_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X_1 </span>Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">X_1</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>),
  <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.post">CategoryTheory.Over.post</a> <span class="fn">F</span></span>)</span>.map <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.homMk">CategoryTheory.Over.homMk</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.map <span class="fn"><span class="fn">f</span>.left</span></span>)</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Over.post"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L301-L305">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.post"><span class="name">CategoryTheory</span>.<span class="name">Over</span>.<span class="name">post</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.obj <span class="fn">X</span></span>)</span></span>)</span></span></div></div><p>A functor <code>F : T ⥤ D</code> induces a functor <code><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">Over</a> X ⥤ <a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">Over</a> (F.obj X)</code> in the obvious way.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Over.post" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.toOver_obj_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L318-L318">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.CostructuredArrow.toOver_obj_right"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver_obj_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Comma.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">F</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X✝</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.CostructuredArrow.toOver">CategoryTheory.CostructuredArrow.toOver</a> <span class="fn">F</span> <span class="fn">X✝</span></span>)</span>.obj <span class="fn">X</span></span>)</span>.right</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">X</span>.right</span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.toOver_obj_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L318-L318">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.CostructuredArrow.toOver_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver_obj_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Comma.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">F</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X✝</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.CostructuredArrow.toOver">CategoryTheory.CostructuredArrow.toOver</a> <span class="fn">F</span> <span class="fn">X✝</span></span>)</span>.obj <span class="fn">X</span></span>)</span>.hom</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">X</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.toOver_map_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L318-L318">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.CostructuredArrow.toOver_map_right"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver_map_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀
  {<span class="fn">X_1 </span>Y :
    <span class="fn"><a href="../.././Mathlib/CategoryTheory/Comma.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">F</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span></span>)</span>
      <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span></span>)</span></span>}
  (<span class="fn">f</span> : <span class="fn"><span class="fn">X_1</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>),
  <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.CostructuredArrow.toOver">CategoryTheory.CostructuredArrow.toOver</a> <span class="fn">F</span> <span class="fn">X</span></span>)</span>.map <span class="fn">f</span></span>)</span>.right</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">X_1</span>.right</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.toOver_map_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L318-L318">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.CostructuredArrow.toOver_map_left"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver_map_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀
  {<span class="fn">X_1 </span>Y :
    <span class="fn"><a href="../.././Mathlib/CategoryTheory/Comma.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">F</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span></span>)</span>
      <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span></span>)</span></span>}
  (<span class="fn">f</span> : <span class="fn"><span class="fn">X_1</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>), <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.CostructuredArrow.toOver">CategoryTheory.CostructuredArrow.toOver</a> <span class="fn">F</span> <span class="fn">X</span></span>)</span>.map <span class="fn">f</span></span>)</span>.left</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">F</span>.map <span class="fn"><span class="fn">f</span>.left</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.toOver_obj_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L318-L318">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.CostructuredArrow.toOver_obj_left"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver_obj_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Comma.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">F</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X✝</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.CostructuredArrow.toOver">CategoryTheory.CostructuredArrow.toOver</a> <span class="fn">F</span> <span class="fn">X✝</span></span>)</span>.obj <span class="fn">X</span></span>)</span>.left</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">F</span>.obj <span class="fn"><span class="fn">X</span>.left</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.toOver"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L319-L320">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.CostructuredArrow.toOver"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">toOver</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/StructuredArrow.html#CategoryTheory.CostructuredArrow">CategoryTheory.CostructuredArrow</a> <span class="fn">F</span> <span class="fn">X</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span></div></div><p>Reinterpreting an <code>F</code>-costructured arrow <code>F.obj d ⟶ X</code> as an arrow over <code>X</code> induces a functor
<code>CostructuredArrow F X ⥤ <a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">Over</a> X</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.CostructuredArrow.toOver">CategoryTheory.CostructuredArrow.toOver</a> <span class="fn">F</span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/StructuredArrow.html#CategoryTheory.CostructuredArrow.pre">CategoryTheory.CostructuredArrow.pre</a> <span class="fn">F</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span> <span class="fn">X</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.CostructuredArrow.toOver" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.instFaithfulCostructuredArrowInstCategoryCostructuredArrowOverInstCategoryOverToOver"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L322-L323">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.CostructuredArrow.instFaithfulCostructuredArrowInstCategoryCostructuredArrowOverInstCategoryOverToOver"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">instFaithfulCostructuredArrowInstCategoryCostructuredArrowOverInstCategoryOverToOver</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Faithful">CategoryTheory.Faithful</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Faithful">CategoryTheory.Faithful</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.CostructuredArrow.toOver">CategoryTheory.CostructuredArrow.toOver</a> <span class="fn">F</span> <span class="fn">X</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Faithful">CategoryTheory.Faithful</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.CostructuredArrow.toOver">CategoryTheory.CostructuredArrow.toOver</a> <span class="fn">F</span> <span class="fn">X</span></span>)</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Faithful">CategoryTheory.Faithful</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/StructuredArrow.html#CategoryTheory.CostructuredArrow.pre">CategoryTheory.CostructuredArrow.pre</a> <span class="fn">F</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span> <span class="fn">X</span></span>)</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.instFullCostructuredArrowInstCategoryCostructuredArrowOverInstCategoryOverToOver"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L325-L326">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.CostructuredArrow.instFullCostructuredArrowInstCategoryCostructuredArrowOverInstCategoryOverToOver"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">instFullCostructuredArrowInstCategoryCostructuredArrowOverInstCategoryOverToOver</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Full">CategoryTheory.Full</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Full">CategoryTheory.Full</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.CostructuredArrow.toOver">CategoryTheory.CostructuredArrow.toOver</a> <span class="fn">F</span> <span class="fn">X</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.CostructuredArrow.instFullCostructuredArrowInstCategoryCostructuredArrowOverInstCategoryOverToOver">CategoryTheory.CostructuredArrow.instFullCostructuredArrowInstCategoryCostructuredArrowOverInstCategoryOverToOver</a> <span class="fn">F</span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">let_fun this := <span class="fn">inferInstance</span>;
  <span class="fn">this</span></span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.instEssSurjCostructuredArrowOverInstCategoryCostructuredArrowInstCategoryOverToOver"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L328-L329">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.CostructuredArrow.instEssSurjCostructuredArrowOverInstCategoryCostructuredArrowInstCategoryOverToOver"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">instEssSurjCostructuredArrowOverInstCategoryCostructuredArrowInstCategoryOverToOver</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.EssSurj">CategoryTheory.EssSurj</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.EssSurj">CategoryTheory.EssSurj</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.CostructuredArrow.toOver">CategoryTheory.CostructuredArrow.toOver</a> <span class="fn">F</span> <span class="fn">X</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.EssSurj">CategoryTheory.EssSurj</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.CostructuredArrow.toOver">CategoryTheory.CostructuredArrow.toOver</a> <span class="fn">F</span> <span class="fn">X</span></span>)</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.EssSurj">CategoryTheory.EssSurj</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/StructuredArrow.html#CategoryTheory.CostructuredArrow.pre">CategoryTheory.CostructuredArrow.pre</a> <span class="fn">F</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span> <span class="fn">X</span></span>)</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.CostructuredArrow.isEquivalenceToOver"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L332-L334">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.CostructuredArrow.isEquivalenceToOver"><span class="name">CategoryTheory</span>.<span class="name">CostructuredArrow</span>.<span class="name">isEquivalenceToOver</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.CostructuredArrow.toOver">CategoryTheory.CostructuredArrow.toOver</a> <span class="fn">F</span> <span class="fn">X</span></span>)</span></span></div></div><p>An equivalence <code>F</code> induces an equivalence <code>CostructuredArrow F X ≌ <a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">Over</a> X</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.CostructuredArrow.isEquivalenceToOver">CategoryTheory.CostructuredArrow.isEquivalenceToOver</a> <span class="fn">F</span> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/StructuredArrow.html#CategoryTheory.CostructuredArrow.isEquivalencePre">CategoryTheory.CostructuredArrow.isEquivalencePre</a> <span class="fn">F</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span> <span class="fn">X</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.CostructuredArrow.isEquivalenceToOver" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L340-L341">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under"><span class="name">CategoryTheory</span>.<span class="name">Under</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> (max u₁ v₁)</div></div><p>The under category has as objects arrows with domain <code>X</code> and as morphisms commutative
triangles.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/StructuredArrow.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.instCategoryUnder"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L344-L344">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.instCategoryUnder"><span class="name">CategoryTheory</span>.<span class="name">instCategoryUnder</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, max u₁ v₁}</a>            <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.instCategoryUnder">CategoryTheory.instCategoryUnder</a> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">CategoryTheory.commaCategory</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Under.inhabited"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L347-L351">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.inhabited"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">inhabited</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">default</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="CategoryTheory.Under.UnderMorphism.ext"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L359-L362">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.UnderMorphism.ext"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">UnderMorphism</span>.<span class="name">ext</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{V : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">U</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">V</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">U</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">V</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">f</span>.right</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span>.right</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.under_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L366-L366">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.under_left"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">under_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">U</span>.left</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">as</span> := <a href="../.././Init/Prelude.html#PUnit.unit">PUnit.unit</a> }</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.id_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L370-L371">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.id_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">id_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(U : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">U</span></span>)</span>.right</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">U</span>.right</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.comp_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L375-L376">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.comp_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">comp_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(c : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">a</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">b</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span>.right</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.right</span> <span class="fn"><span class="fn">g</span>.right</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.w_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L379-L379">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.w_assoc"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">w_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">A</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><span class="fn">B</span>.right</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">A</span>.hom</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.right</span> <span class="fn">h</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">B</span>.hom</span> <span class="fn">h</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.w"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L380-L380">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.w"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">w</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{A : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">A</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">A</span>.hom</span> <span class="fn"><span class="fn">f</span>.right</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">B</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.mk_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L384-L384">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.mk_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mk_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.mk">CategoryTheory.Under.mk</a> <span class="fn">f</span></span>)</span>.right</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">Y</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.mk_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L384-L384">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.mk_hom"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mk_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.mk">CategoryTheory.Under.mk</a> <span class="fn">f</span></span>)</span>.hom</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.mk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L385-L386">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.mk"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span></div></div><p>To give an object in the under category, it suffices to give an arrow with domain <code>X</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.mk">CategoryTheory.Under.mk</a> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/StructuredArrow.html#CategoryTheory.StructuredArrow.mk">CategoryTheory.StructuredArrow.mk</a> <span class="fn">f</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under.mk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.homMk_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L391-L391">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.homMk_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">homMk_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{V : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">U</span>.right</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">V</span>.right</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../.././Init/Meta.html#autoParam">autoParam</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">U</span>.hom</span> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">V</span>.hom</span></span>)</span> <a href="../.././Mathlib/CategoryTheory/Over.html#_auto._@.Mathlib.CategoryTheory.Over._hyg.2627">_auto✝</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.homMk">CategoryTheory.Under.homMk</a> <span class="fn">f</span></span>)</span>.right</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.homMk_left_down_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L391-L391">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.homMk_left_down_down"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">homMk_left_down_down</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{V : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">U</span>.right</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">V</span>.right</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../.././Init/Meta.html#autoParam">autoParam</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">U</span>.hom</span> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">V</span>.hom</span></span>)</span> <a href="../.././Mathlib/CategoryTheory/Over.html#_auto._@.Mathlib.CategoryTheory.Over._hyg.2627">_auto✝</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(_ : <span class="fn"><span class="fn"><span class="fn"><span class="fn">V</span>.left</span>.as</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">V</span>.left</span>.as</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(_ : <span class="fn"><span class="fn"><span class="fn"><span class="fn">V</span>.left</span>.as</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">V</span>.left</span>.as</span></span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.homMk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L392-L393">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.homMk"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">homMk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{V : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn"><span class="fn">U</span>.right</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">V</span>.right</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(w : <span class="fn"><a href="../.././Init/Meta.html#autoParam">autoParam</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">U</span>.hom</span> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">V</span>.hom</span></span>)</span> <a href="../.././Mathlib/CategoryTheory/Over.html#_auto._@.Mathlib.CategoryTheory.Over._hyg.2627">_auto✝</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">U</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">V</span></span></div></div><p>To give a morphism in the under category, it suffices to give a morphism fitting in a
commutative triangle.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.homMk">CategoryTheory.Under.homMk</a> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/StructuredArrow.html#CategoryTheory.StructuredArrow.homMk">CategoryTheory.StructuredArrow.homMk</a> <span class="fn">f</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under.homMk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.isoMk"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L402-L404">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.isoMk"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">isoMk</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr : <span class="fn"><span class="fn"><span class="fn">f</span>.right</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">g</span>.right</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hw : <span class="fn"><a href="../.././Init/Meta.html#autoParam">autoParam</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.hom</span> <span class="fn"><span class="fn">hr</span>.hom</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span>.hom</span></span>)</span> <a href="../.././Mathlib/CategoryTheory/Over.html#_auto._@.Mathlib.CategoryTheory.Over._hyg.2690">_auto✝</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">f</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">g</span></span></div></div><p>Construct an isomorphism in the over category given isomorphisms of the objects whose forward
direction gives a commutative triangle.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.isoMk">CategoryTheory.Under.isoMk</a> <span class="fn">hr</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/StructuredArrow.html#CategoryTheory.StructuredArrow.isoMk">CategoryTheory.StructuredArrow.isoMk</a> <span class="fn">hr</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under.isoMk" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.isoMk_hom_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L408-L410">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.isoMk_hom_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">isoMk_hom_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr : <span class="fn"><span class="fn"><span class="fn">f</span>.right</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">g</span>.right</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hw : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.hom</span> <span class="fn"><span class="fn">hr</span>.hom</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span>.hom</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.isoMk">CategoryTheory.Under.isoMk</a> <span class="fn">hr</span></span>)</span>.hom</span>.right</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">hr</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.isoMk_inv_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L414-L416">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.isoMk_inv_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">isoMk_inv_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hr : <span class="fn"><span class="fn"><span class="fn">f</span>.right</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><span class="fn">g</span>.right</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hw : <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">f</span>.hom</span> <span class="fn"><span class="fn">hr</span>.hom</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span>.hom</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.isoMk">CategoryTheory.Under.isoMk</a> <span class="fn">hr</span></span>)</span>.inv</span>.right</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">hr</span>.inv</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.forget"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L424-L425">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.forget"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forget</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span> <span class="fn">T</span></span></div></div><p>The forgetful functor mapping an arrow to its domain.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Comma.html#CategoryTheory.Comma.snd">CategoryTheory.Comma.snd</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under.forget" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.forget_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L431-L432">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.forget_obj"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forget_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span></span>)</span>.obj <span class="fn">U</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">U</span>.right</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.forget_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L436-L437">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.forget_map"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forget_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{V : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">U</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">V</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span></span>)</span>.map <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span>.right</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.forgetCone_pt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L441-L441">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.forgetCone_pt"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forgetCone_pt</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.forgetCone">CategoryTheory.Under.forgetCone</a> <span class="fn">X</span></span>)</span>.pt</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">X</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.forgetCone_π_app"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L441-L441">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.forgetCone_π_app"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forgetCone_π_app</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(self : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Comma.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.forgetCone">CategoryTheory.Under.forgetCone</a> <span class="fn">X</span></span>)</span>.π</span>.app <span class="fn">self</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">self</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.forgetCone"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L442-L444">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.forgetCone"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forgetCone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span></span>)</span></span></div></div><p>The natural cone over the forgetful functor <code><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">Under</a> X ⥤ T</code> with cone point <code>X</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.forgetCone">CategoryTheory.Under.forgetCone</a> <span class="fn">X</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">pt</span> := <span class="fn">X</span>, <span class="fn">π</span> := <span class="fn"><a href="../.././Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.mk">CategoryTheory.NatTrans.mk</a> <span class="fn">CategoryTheory.Comma.hom</span></span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under.forgetCone" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L448-L449">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.map"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">Y</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span></div></div><p>A morphism <code>X ⟶ Y</code> induces a functor <code><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">Under</a> Y ⥤ <a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">Under</a> X</code> in the obvious way.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Comma.html#CategoryTheory.Comma.mapLeft">CategoryTheory.Comma.mapLeft</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.natTrans">CategoryTheory.Discrete.natTrans</a> <span class="fn">fun (<span class="fn">x</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete">CategoryTheory.Discrete</a> <a href="../.././Init/Prelude.html#PUnit">PUnit.{1}</a></span>) =&gt; <span class="fn">f</span></span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under.map" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.map_obj_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L457-L458">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.map_obj_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">map_obj_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">f</span></span>)</span>.obj <span class="fn">U</span></span>)</span>.right</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">U</span>.right</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.map_obj_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L462-L463">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.map_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">map_obj_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">f</span></span>)</span>.obj <span class="fn">U</span></span>)</span>.hom</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn"><span class="fn">U</span>.hom</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.map_map_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L467-L468">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.map_map_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">map_map_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{U : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{V : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><span class="fn">U</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">V</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">f</span></span>)</span>.map <span class="fn">g</span></span>)</span>.right</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span>.right</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.mapId"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L472-L473">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.mapId"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapId</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">Y</span></span>)</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">Y</span></span>)</span></span></span></div></div><p>Mapping by the identity morphism is just the identity functor.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Under.mapId" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.mapComp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L477-L478">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.mapComp"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mapComp</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span>)</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">g</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.map">CategoryTheory.Under.map</a> <span class="fn">f</span></span>)</span></span></span></div></div><p>Mapping by the composite morphism <code>f ≫ g</code> is the same as mapping by <code>f</code> then by <code>g</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Under.mapComp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.forget_reflects_iso"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L483-L489">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.forget_reflects_iso"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forget_reflects_iso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/ReflectsIso.html#CategoryTheory.ReflectsIsomorphisms">CategoryTheory.ReflectsIsomorphisms</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/ReflectsIso.html#CategoryTheory.ReflectsIsomorphisms">CategoryTheory.ReflectsIsomorphisms</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span></span>)</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/ReflectsIso.html#CategoryTheory.ReflectsIsomorphisms">CategoryTheory.ReflectsIsomorphisms</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span></span>)</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Under.mkIdInitial"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L493-L494">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.mkIdInitial"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mkIdInitial</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Limits/Shapes/Terminal.html#CategoryTheory.Limits.IsInitial">CategoryTheory.Limits.IsInitial</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.mk">CategoryTheory.Under.mk</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn">X</span></span>)</span></span>)</span></span></div></div><p>The identity under <code>X</code> is initial.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">CategoryTheory.Under.mkIdInitial</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">CategoryTheory.StructuredArrow.mkIdInitial</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Under.mkIdInitial" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Under.forget_faithful"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L496-L496">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.forget_faithful"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">forget_faithful</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Faithful">CategoryTheory.Faithful</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Faithful">CategoryTheory.Faithful</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span></span>)</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Faithful">CategoryTheory.Faithful</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span></span>)</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Under.mono_of_mono_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L505-L506">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.mono_of_mono_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">mono_of_mono_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(k : <span class="fn"><span class="fn">f</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[hk : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">CategoryTheory.Mono</a> <span class="fn"><span class="fn">k</span>.right</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Mono">CategoryTheory.Mono</a> <span class="fn">k</span></span></div></div><p>If <code>k.right</code> is a monomorphism, then <code>k</code> is a monomorphism. In other words, <code><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.forget">Under.forget</a> X</code>
reflects epimorphisms.
The converse does not hold without additional assumptions on the underlying category, see
<code>CategoryTheory.Under.mono_right_of_mono</code>.</p></div></div><div class="decl" id="CategoryTheory.Under.epi_of_epi_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L516-L517">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.epi_of_epi_right"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">epi_of_epi_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(k : <span class="fn"><span class="fn">f</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[hk : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">CategoryTheory.Epi</a> <span class="fn"><span class="fn">k</span>.right</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">CategoryTheory.Epi</a> <span class="fn">k</span></span></div></div><p>If <code>k.right</code> is an epimorphism, then <code>k</code> is an epimorphism. In other words, <code><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.forget">Under.forget</a> X</code>
reflects epimorphisms.
The converse of <code><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.epi_right_of_epi">CategoryTheory.Under.epi_right_of_epi</a></code>.</p><p>This lemma is not an instance, to avoid loops in type class inference.</p></div></div><div class="decl" id="CategoryTheory.Under.epi_right_of_epi"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L525-L531">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.epi_right_of_epi"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">epi_right_of_epi</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(k : <span class="fn"><span class="fn">f</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">g</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">CategoryTheory.Epi</a> <span class="fn">k</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">CategoryTheory.Epi</a> <span class="fn"><span class="fn">k</span>.right</span></span></div></div><p>If <code>k</code> is an epimorphism, then <code>k.right</code> is an epimorphism. In other words, <code><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.forget">Under.forget</a> X</code>
preserves epimorphisms.
The converse of <code>CategoryTheory.under.<a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.epi_of_epi_right">epi_of_epi_right</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">CategoryTheory.Epi</a> <span class="fn"><span class="fn">k</span>.right</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi">CategoryTheory.Epi</a> <span class="fn"><span class="fn">k</span>.right</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.Under.post_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L539-L539">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.post_obj"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">post_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.post">CategoryTheory.Under.post</a> <span class="fn">F</span></span>)</span>.obj <span class="fn">Y</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.mk">CategoryTheory.Under.mk</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.map <span class="fn"><span class="fn">Y</span>.hom</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.post_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L539-L539">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.post_map"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">post_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X_1 </span>Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">X_1</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>),
  <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.post">CategoryTheory.Under.post</a> <span class="fn">F</span></span>)</span>.map <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.homMk">CategoryTheory.Under.homMk</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.map <span class="fn"><span class="fn">f</span>.right</span></span>)</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Under.post"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L540-L543">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.post"><span class="name">CategoryTheory</span>.<span class="name">Under</span>.<span class="name">post</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">T</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">T</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.obj <span class="fn">X</span></span>)</span></span>)</span></span></div></div><p>A functor <code>F : T ⥤ D</code> induces a functor <code><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">Under</a> X ⥤ <a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">Under</a> (F.obj X)</code> in the obvious way.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Under.post" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.StructuredArrow.toUnder_map_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L556-L556">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.StructuredArrow.toUnder_map_left"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder_map_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀
  {<span class="fn">X_1 </span>Y :
    <span class="fn"><a href="../.././Mathlib/CategoryTheory/Comma.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span></span>)</span>
      <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">F</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span></span>)</span></span>}
  (<span class="fn">f</span> : <span class="fn"><span class="fn">X_1</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>), <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.StructuredArrow.toUnder">CategoryTheory.StructuredArrow.toUnder</a> <span class="fn">X</span> <span class="fn">F</span></span>)</span>.map <span class="fn">f</span></span>)</span>.left</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id">CategoryTheory.CategoryStruct.id</a> <span class="fn"><span class="fn">X_1</span>.left</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.toUnder_obj_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L556-L556">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.StructuredArrow.toUnder_obj_left"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder_obj_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Comma.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X✝</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">F</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.StructuredArrow.toUnder">CategoryTheory.StructuredArrow.toUnder</a> <span class="fn">X✝</span> <span class="fn">F</span></span>)</span>.obj <span class="fn">X</span></span>)</span>.left</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">X</span>.left</span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.toUnder_map_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L556-L556">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.StructuredArrow.toUnder_map_right"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder_map_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀
  {<span class="fn">X_1 </span>Y :
    <span class="fn"><a href="../.././Mathlib/CategoryTheory/Comma.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X</span></span>)</span>
      <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">F</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span></span>)</span></span>}
  (<span class="fn">f</span> : <span class="fn"><span class="fn">X_1</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>), <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.StructuredArrow.toUnder">CategoryTheory.StructuredArrow.toUnder</a> <span class="fn">X</span> <span class="fn">F</span></span>)</span>.map <span class="fn">f</span></span>)</span>.right</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">F</span>.map <span class="fn"><span class="fn">f</span>.right</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.toUnder_obj_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L556-L556">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.StructuredArrow.toUnder_obj_right"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder_obj_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Comma.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X✝</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">F</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.StructuredArrow.toUnder">CategoryTheory.StructuredArrow.toUnder</a> <span class="fn">X✝</span> <span class="fn">F</span></span>)</span>.obj <span class="fn">X</span></span>)</span>.right</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">F</span>.obj <span class="fn"><span class="fn">X</span>.right</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.toUnder_obj_hom"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L556-L556">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.StructuredArrow.toUnder_obj_hom"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder_obj_hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Comma.html#CategoryTheory.Comma">CategoryTheory.Comma</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/PUnit.html#CategoryTheory.Functor.fromPUnit">CategoryTheory.Functor.fromPUnit</a> <span class="fn">X✝</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">F</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.StructuredArrow.toUnder">CategoryTheory.StructuredArrow.toUnder</a> <span class="fn">X✝</span> <span class="fn">F</span></span>)</span>.obj <span class="fn">X</span></span>)</span>.hom</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">X</span>.hom</span></span></div></div></div></div><div class="decl" id="CategoryTheory.StructuredArrow.toUnder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L557-L558">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.StructuredArrow.toUnder"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">toUnder</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/StructuredArrow.html#CategoryTheory.StructuredArrow">CategoryTheory.StructuredArrow</a> <span class="fn">X</span> <span class="fn">F</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span></div></div><p>Reinterpreting an <code>F</code>-structured arrow <code>X ⟶ F.obj d</code> as an arrow under <code>X</code> induces a functor
<code>StructuredArrow X F ⥤ <a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">Under</a> X</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.StructuredArrow.toUnder">CategoryTheory.StructuredArrow.toUnder</a> <span class="fn">X</span> <span class="fn">F</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/StructuredArrow.html#CategoryTheory.StructuredArrow.pre">CategoryTheory.StructuredArrow.pre</a> <span class="fn">X</span> <span class="fn">F</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.StructuredArrow.toUnder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.StructuredArrow.instFaithfulStructuredArrowInstCategoryStructuredArrowUnderInstCategoryUnderToUnder"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L560-L561">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.StructuredArrow.instFaithfulStructuredArrowInstCategoryStructuredArrowUnderInstCategoryUnderToUnder"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">instFaithfulStructuredArrowInstCategoryStructuredArrowUnderInstCategoryUnderToUnder</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Faithful">CategoryTheory.Faithful</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Faithful">CategoryTheory.Faithful</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.StructuredArrow.toUnder">CategoryTheory.StructuredArrow.toUnder</a> <span class="fn">X</span> <span class="fn">F</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Faithful">CategoryTheory.Faithful</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.StructuredArrow.toUnder">CategoryTheory.StructuredArrow.toUnder</a> <span class="fn">X</span> <span class="fn">F</span></span>)</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Faithful">CategoryTheory.Faithful</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/StructuredArrow.html#CategoryTheory.StructuredArrow.pre">CategoryTheory.StructuredArrow.pre</a> <span class="fn">X</span> <span class="fn">F</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span></span>)</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.StructuredArrow.instFullStructuredArrowInstCategoryStructuredArrowUnderInstCategoryUnderToUnder"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L563-L564">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.StructuredArrow.instFullStructuredArrowInstCategoryStructuredArrowUnderInstCategoryUnderToUnder"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">instFullStructuredArrowInstCategoryStructuredArrowUnderInstCategoryUnderToUnder</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Full">CategoryTheory.Full</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Full">CategoryTheory.Full</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.StructuredArrow.toUnder">CategoryTheory.StructuredArrow.toUnder</a> <span class="fn">X</span> <span class="fn">F</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.StructuredArrow.instFullStructuredArrowInstCategoryStructuredArrowUnderInstCategoryUnderToUnder">CategoryTheory.StructuredArrow.instFullStructuredArrowInstCategoryStructuredArrowUnderInstCategoryUnderToUnder</a> <span class="fn">X</span> <span class="fn">F</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">let_fun this := <span class="fn">inferInstance</span>;
  <span class="fn">this</span></span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.StructuredArrow.instEssSurjStructuredArrowUnderInstCategoryStructuredArrowInstCategoryUnderToUnder"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L566-L567">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.StructuredArrow.instEssSurjStructuredArrowUnderInstCategoryStructuredArrowInstCategoryUnderToUnder"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">instEssSurjStructuredArrowUnderInstCategoryStructuredArrowInstCategoryUnderToUnder</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.EssSurj">CategoryTheory.EssSurj</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.EssSurj">CategoryTheory.EssSurj</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.StructuredArrow.toUnder">CategoryTheory.StructuredArrow.toUnder</a> <span class="fn">X</span> <span class="fn">F</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.EssSurj">CategoryTheory.EssSurj</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.StructuredArrow.toUnder">CategoryTheory.StructuredArrow.toUnder</a> <span class="fn">X</span> <span class="fn">F</span></span>)</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.EssSurj">CategoryTheory.EssSurj</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/StructuredArrow.html#CategoryTheory.StructuredArrow.pre">CategoryTheory.StructuredArrow.pre</a> <span class="fn">X</span> <span class="fn">F</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span></span>)</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.StructuredArrow.isEquivalenceToUnder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L570-L572">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.StructuredArrow.isEquivalenceToUnder"><span class="name">CategoryTheory</span>.<span class="name">StructuredArrow</span>.<span class="name">isEquivalenceToUnder</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">T</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.StructuredArrow.toUnder">CategoryTheory.StructuredArrow.toUnder</a> <span class="fn">X</span> <span class="fn">F</span></span>)</span></span></div></div><p>An equivalence <code>F</code> induces an equivalence <code>StructuredArrow X F ≌ <a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">Under</a> X</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.StructuredArrow.isEquivalenceToUnder">CategoryTheory.StructuredArrow.isEquivalenceToUnder</a> <span class="fn">X</span> <span class="fn">F</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/StructuredArrow.html#CategoryTheory.StructuredArrow.isEquivalencePre">CategoryTheory.StructuredArrow.isEquivalencePre</a> <span class="fn">X</span> <span class="fn">F</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">T</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.StructuredArrow.isEquivalenceToUnder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.toOver_map_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L583-L583">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Functor.toOver_map_left"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toOver_map_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">S</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">Y</span> : <span class="fn">S</span>) → <span class="fn"><span class="fn"><span class="fn">F</span>.obj <span class="fn">Y</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ {<span class="fn">Y </span>Z : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.map <span class="fn">g</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">Z</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Y</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X_1 </span>Y : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">X_1</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>), <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Functor.toOver">CategoryTheory.Functor.toOver</a> <span class="fn">F</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">h</span></span>)</span>.map <span class="fn">g</span></span>)</span>.left</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">F</span>.map <span class="fn">g</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.toOver_obj_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L583-L583">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Functor.toOver_obj_left"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toOver_obj_left</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">S</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">Y</span> : <span class="fn">S</span>) → <span class="fn"><span class="fn"><span class="fn">F</span>.obj <span class="fn">Y</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ {<span class="fn">Y </span>Z : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.map <span class="fn">g</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">Z</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Y</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">S</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Functor.toOver">CategoryTheory.Functor.toOver</a> <span class="fn">F</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">h</span></span>)</span>.obj <span class="fn">Y</span></span>)</span>.left</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">F</span>.obj <span class="fn">Y</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.toOver"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L584-L586">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Functor.toOver"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toOver</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">S</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">Y</span> : <span class="fn">S</span>) → <span class="fn"><span class="fn"><span class="fn">F</span>.obj <span class="fn">Y</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ {<span class="fn">Y </span>Z : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.map <span class="fn">g</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">Z</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Y</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">CategoryTheory.Over</a> <span class="fn">X</span></span>)</span></span></div></div><p>Given <code>X : T</code>, to upgrade a functor <code>F : S ⥤ T</code> to a functor <code>S ⥤ <a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">Over</a> X</code>, it suffices to
provide maps <code>F.obj Y ⟶ X</code> for all <code>Y</code> making the obvious triangles involving all <code>F.<a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.map">map</a> g</code>
commute.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Functor.toOver" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.toOverCompForget"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L590-L592">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Functor.toOverCompForget"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toOverCompForget</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">S</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">Y</span> : <span class="fn">S</span>) → <span class="fn"><span class="fn"><span class="fn">F</span>.obj <span class="fn">Y</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ {<span class="fn">Y </span>Z : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.map <span class="fn">g</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">Z</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Y</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Functor.toOver">CategoryTheory.Functor.toOver</a> <span class="fn">F</span> <span class="fn">X</span> <span class="fn">f</span>
      <span class="fn">(_ : <span class="fn">∀ {<span class="fn">Y </span>Z : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.map <span class="fn">g</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">Z</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Y</span></span></span></span>)</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span></span>)</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a>   <span class="fn">F</span></span></div></div><p>Upgrading a functor <code>S ⥤ T</code> to a functor <code>S ⥤ <a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">Over</a> X</code> and composing with the forgetful functor
<code><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over">Over</a> X ⥤ T</code> recovers the original functor.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Functor.toOverCompForget" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.toOver_comp_forget"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L595-L597">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Functor.toOver_comp_forget"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toOver_comp_forget</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">S</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">Y</span> : <span class="fn">S</span>) → <span class="fn"><span class="fn"><span class="fn">F</span>.obj <span class="fn">Y</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ {<span class="fn">Y </span>Z : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.map <span class="fn">g</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">Z</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Y</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Functor.toOver">CategoryTheory.Functor.toOver</a> <span class="fn">F</span> <span class="fn">X</span> <span class="fn">f</span>
      <span class="fn">(_ : <span class="fn">∀ {<span class="fn">Y </span>Z : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.map <span class="fn">g</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">Z</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Y</span></span></span></span>)</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.forget">CategoryTheory.Over.forget</a> <span class="fn">X</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">F</span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.toUnder_obj_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L602-L602">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Functor.toUnder_obj_right"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toUnder_obj_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">S</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">Y</span> : <span class="fn">S</span>) → <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">F</span>.obj <span class="fn">Y</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ {<span class="fn">Y </span>Z : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">Y</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">F</span>.map <span class="fn">g</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Z</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(Y : <span class="fn">S</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Functor.toUnder">CategoryTheory.Functor.toUnder</a> <span class="fn">F</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">h</span></span>)</span>.obj <span class="fn">Y</span></span>)</span>.right</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">F</span>.obj <span class="fn">Y</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.toUnder_map_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L602-L602">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Functor.toUnder_map_right"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toUnder_map_right</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">S</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">Y</span> : <span class="fn">S</span>) → <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">F</span>.obj <span class="fn">Y</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ {<span class="fn">Y </span>Z : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">Y</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">F</span>.map <span class="fn">g</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Z</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X_1 </span>Y : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">X_1</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>), <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Functor.toUnder">CategoryTheory.Functor.toUnder</a> <span class="fn">F</span> <span class="fn">X</span> <span class="fn">f</span> <span class="fn">h</span></span>)</span>.map <span class="fn">g</span></span>)</span>.right</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">F</span>.map <span class="fn">g</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.Functor.toUnder"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L603-L605">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Functor.toUnder"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toUnder</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">S</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">Y</span> : <span class="fn">S</span>) → <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">F</span>.obj <span class="fn">Y</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ {<span class="fn">Y </span>Z : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">Y</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">F</span>.map <span class="fn">g</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Z</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">CategoryTheory.Under</a> <span class="fn">X</span></span>)</span></span></div></div><p>Given <code>X : T</code>, to upgrade a functor <code>F : S ⥤ T</code> to a functor <code>S ⥤ <a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">Under</a> X</code>, it suffices to
provide maps <code>X ⟶ F.obj Y</code> for all <code>Y</code> making the obvious triangles involving all <code>F.<a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Over.map">map</a> g</code>
commute.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Functor.toUnder" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.toUnderCompForget"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L609-L611">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Functor.toUnderCompForget"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toUnderCompForget</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">S</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">Y</span> : <span class="fn">S</span>) → <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">F</span>.obj <span class="fn">Y</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ {<span class="fn">Y </span>Z : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">Y</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">F</span>.map <span class="fn">g</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Z</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Functor.toUnder">CategoryTheory.Functor.toUnder</a> <span class="fn">F</span> <span class="fn">X</span> <span class="fn">f</span>
      <span class="fn">(_ : <span class="fn">∀ {<span class="fn">Y </span>Z : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">Y</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">F</span>.map <span class="fn">g</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Z</span></span></span></span>)</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span></span>)</span></span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a>   <span class="fn">F</span></span></div></div><p>Upgrading a functor <code>S ⥤ T</code> to a functor <code>S ⥤ <a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">Under</a> X</code> and composing with the forgetful functor
<code><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under">Under</a> X ⥤ T</code> recovers the original functor.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Functor.toUnderCompForget" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.toUnder_comp_forget"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Over.lean#L614-L616">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Functor.toUnder_comp_forget"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">toUnder_comp_forget</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{T : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">T</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">S</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">S</span> <span class="fn">T</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(X : <span class="fn">T</span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn">(<span class="fn">Y</span> : <span class="fn">S</span>) → <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><span class="fn">F</span>.obj <span class="fn">Y</span></span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">∀ {<span class="fn">Y </span>Z : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">Y</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">F</span>.map <span class="fn">g</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Z</span></span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Functor.toUnder">CategoryTheory.Functor.toUnder</a> <span class="fn">F</span> <span class="fn">X</span> <span class="fn">f</span>
      <span class="fn">(_ : <span class="fn">∀ {<span class="fn">Y </span>Z : <span class="fn">S</span>} (<span class="fn">g</span> : <span class="fn"><span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">f</span> <span class="fn">Y</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">F</span>.map <span class="fn">g</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">Z</span></span></span></span>)</span></span>)</span>
    <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Over.html#CategoryTheory.Under.forget">CategoryTheory.Under.forget</a> <span class="fn">X</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">F</span></span></div></div></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>