<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="stylesheet" href="../../.././src/pygments.css"></link><link rel="shortcut icon" href="../../.././favicon.ico"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.CategoryTheory.Filtered.Basic</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.CategoryTheory.Filtered.Basic";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">CategoryTheory</span>.<span class="name">Filtered</span>.<span class="name">Basic</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;
            <button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/CategoryTheory/FinCategory.html">Mathlib.CategoryTheory.FinCategory</a></li><li><a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html">Mathlib.CategoryTheory.Adjunction.Basic</a></li><li><a href="../../.././Mathlib/CategoryTheory/Category/Preorder.html">Mathlib.CategoryTheory.Category.Preorder</a></li><li><a href="../../.././Mathlib/CategoryTheory/Category/ULift.html">Mathlib.CategoryTheory.Category.ULift</a></li><li><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html">Mathlib.CategoryTheory.Limits.Cones</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.CategoryTheory.Filtered.Basic" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFilteredOrEmpty_of_semilatticeSup"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_of_semilatticeSup</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFiltered_of_semilatticeSup_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_of_semilatticeSup_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFilteredOrEmpty_of_directed_le"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_of_directed_le</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFiltered_of_directed_le_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_of_directed_le_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsFilteredDiscretePUnitDiscreteCategory"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredDiscretePUnitDiscreteCategory</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.max"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">max</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.leftToMax"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">leftToMax</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.rightToMax"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">rightToMax</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeqHom"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeqHom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq_condition_assoc"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq_condition_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq_condition"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq_condition</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFilteredOrEmpty.of_right_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">of_right_adjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFilteredOrEmpty.of_isRightAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">of_isRightAdjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFilteredOrEmpty.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">of_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.sup_objs_exists"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">sup_objs_exists</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.sup_exists"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">sup_exists</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.sup"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">sup</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.toSup"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">toSup</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.toSup_commutes"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">toSup_commutes</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.cocone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">cocone_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.cocone"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">cocone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.of_right_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_right_adjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.of_isRightAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_isRightAdjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.max₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">max₃</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.firstToMax₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">firstToMax₃</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.secondToMax₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">secondToMax₃</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.thirdToMax₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">thirdToMax₃</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq₃Hom"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃Hom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq₃_condition₁"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃_condition₁</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq₃_condition₂"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃_condition₂</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.coeq₃_condition₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃_condition₃</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.span"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">span</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.bowtie"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">bowtie</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsFiltered.tulip"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">tulip</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofilteredOrEmpty_of_semilatticeInf"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_of_semilatticeInf</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofiltered_of_semilatticeInf_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_of_semilatticeInf_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofilteredOrEmpty_of_directed_ge"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_of_directed_ge</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofiltered_of_directed_ge_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_of_directed_ge_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsCofilteredDiscretePUnitDiscreteCategory"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredDiscretePUnitDiscreteCategory</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.min"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">min</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.minToLeft"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">minToLeft</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.minToRight"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">minToRight</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.eq"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.eqHom"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eqHom</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.eq_condition_assoc"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eq_condition_assoc</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.eq_condition"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eq_condition</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.cospan"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">cospan</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.ranges_directed"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">ranges_directed</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofilteredOrEmpty.of_left_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">of_left_adjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofilteredOrEmpty.of_isLeftAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">of_isLeftAdjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofilteredOrEmpty.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">of_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.inf_objs_exists"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">inf_objs_exists</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.inf_exists"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">inf_exists</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.inf"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">inf</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.infTo"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">infTo</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.infTo_commutes"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">infTo_commutes</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.cone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">cone_nonempty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.cone"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">cone</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.of_left_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_left_adjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.of_isLeftAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_isLeftAdjoint</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsCofiltered.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofilteredOrEmpty_op_of_isFilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_op_of_isFilteredOrEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofiltered_op_of_isFiltered"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_op_of_isFiltered</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFilteredOrEmpty_op_of_isCofilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_op_of_isCofilteredOrEmpty</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFiltered_op_of_isCofiltered"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_op_of_isCofiltered</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofilteredOrEmpty_of_isFilteredOrEmpty_op"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_of_isFilteredOrEmpty_op</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFilteredOrEmpty_of_isCofilteredOrEmpty_op"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_of_isCofilteredOrEmpty_op</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isCofiltered_of_isFiltered_op"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_of_isFiltered_op</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isFiltered_of_isCofiltered_op"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_of_isCofiltered_op</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsFilteredULiftUliftCategory"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredULiftUliftCategory</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsCofilteredULiftUliftCategory"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredULiftUliftCategory</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsFilteredULiftHomCategory"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredULiftHomCategory</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsCofilteredULiftHomCategory"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredULiftHomCategory</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsFilteredAsSmallInstSmallCategoryAsSmall"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredAsSmallInstSmallCategoryAsSmall</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instIsCofilteredAsSmallInstSmallCategoryAsSmall"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredAsSmallInstSmallCategoryAsSmall</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Filtered-categories">Filtered categories <a class="hover-link" href="#Filtered-categories">#</a></h1><p>A category is filtered if every finite diagram admits a cocone.
We give a simple characterisation of this condition as</p><ol>
<li>for every pair of objects there exists another object "to the right",</li>
<li>for every pair of parallel morphisms there exists a morphism to the right so the compositions
are equal, and</li>
<li>there exists some object.</li>
</ol><p>Filtered colimits are often better behaved than arbitrary colimits.
See <code>CategoryTheory/Limits/Types</code> for some details.</p><p>Filtered categories are nice because colimits indexed by filtered categories tend to be
easier to describe than general colimits (and more often preserved by functors).</p><p>In this file we show that any functor from a finite category to a filtered category admits a cocone:</p><ul>
<li><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.cocone_nonempty">cocone_nonempty</a> [FinCategory J] [IsFiltered C] (F : J ⥤ C) : <a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> (Cocone F)</code>
More generally,
for any finite collection of objects and morphisms between them in a filtered category
(even if not closed under composition) there exists some object <code>Z</code> receiving maps from all of them,
so that all the triangles (one edge from the finite set, two from morphisms to <code>Z</code>) commute.
This formulation is often more useful in practice and is available via <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.sup_exists">sup_exists</a></code>,
which takes a finset of objects, and an indexed family (indexed by source and target)
of finsets of morphisms.</li>
</ul><p>Furthermore, we give special support for two diagram categories: The <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.bowtie">bowtie</a></code> and the <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.tulip">tulip</a></code>.
This is because these shapes show up in the proofs that forgetful functors of algebraic categories
(e.g. <code>MonCat</code>, <code>CommRingCat</code>, ...) preserve filtered colimits.</p><p>All of the above API, except for the <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.bowtie">bowtie</a></code> and the <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.tulip">tulip</a></code>, is also provided for cofiltered
categories.</p><h2 class="markdown-heading" id="See-also">See also <a class="hover-link" href="#See-also">#</a></h2><p>In <code>CategoryTheory.Limits.FilteredColimitCommutesFiniteLimit</code> we show that filtered colimits
commute with finite limits.</p></div><div class="decl" id="CategoryTheory.IsFilteredOrEmpty"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L68-L73">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A category <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">IsFilteredOrEmpty</a></code> if</p><ol>
<li>for every pair of objects there exists another object "to the right", and</li>
<li>for every pair of parallel morphisms there exists a morphism to the right so the compositions
are equal.</li>
</ol><ul class="structure_fields" id="CategoryTheory.IsFilteredOrEmpty.mk"><li id="CategoryTheory.IsFilteredOrEmpty.cocone_objs" class="structure_field"><div class="structure_field_info">cocone_objs : <span class="fn">∀ (<span class="fn">X </span>Y : <span class="fn">C</span>), <span class="fn">∃ (Z : <span class="fn">C</span>) (x : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>) (x : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <a href="../../.././Init/Prelude.html#True">True</a></span></span></div><div class="structure_field_doc"><p>for every pair of objects there exists another object "to the right"</p></div></li><li id="CategoryTheory.IsFilteredOrEmpty.cocone_maps" class="structure_field"><div class="structure_field_info">cocone_maps : <span class="fn">∀ ⦃<span class="fn">X </span>Y : <span class="fn">C</span>⦄ (<span class="fn">f </span>g : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>),
  <span class="fn">∃ (Z : <span class="fn">C</span>) (h : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">h</span></span></span></span></span></div><div class="structure_field_doc"><p>for every pair of parallel morphisms there exists a morphism to the right
so the compositions are equal</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.IsFilteredOrEmpty" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L84-L86">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="decl_extends">extends</span><span class="decl_parent">
<span class="fn"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span></a></span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A category <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code> if</p><ol>
<li>for every pair of objects there exists another object "to the right",</li>
<li>for every pair of parallel morphisms there exists a morphism to the right so the compositions
are equal, and</li>
<li>there exists some object.</li>
</ol><p>See <https://stacks.math.columbia.edu/tag/002V>. (They also define a diagram being filtered.)</p><ul class="structure_fields" id="CategoryTheory.IsFiltered.mk"><li id="CategoryTheory.IsFiltered.cocone_objs" class="structure_field"><div class="structure_field_info">cocone_objs : <span class="fn">∀ (<span class="fn">X </span>Y : <span class="fn">C</span>), <span class="fn">∃ (Z : <span class="fn">C</span>) (x : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>) (x : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <a href="../../.././Init/Prelude.html#True">True</a></span></span></div></li><li id="CategoryTheory.IsFiltered.cocone_maps" class="structure_field"><div class="structure_field_info">cocone_maps : <span class="fn">∀ ⦃<span class="fn">X </span>Y : <span class="fn">C</span>⦄ (<span class="fn">f </span>g : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>),
  <span class="fn">∃ (Z : <span class="fn">C</span>) (h : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">h</span></span></span></span></span></div></li><li id="CategoryTheory.IsFiltered.nonempty" class="structure_field"><div class="structure_field_info">nonempty : <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">C</span></span></div><div class="structure_field_doc"><p>a filtered category must be non empty</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.IsFiltered" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.isFilteredOrEmpty_of_semilatticeSup"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L89-L95">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFilteredOrEmpty_of_semilatticeSup"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_of_semilatticeSup</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Lattice.html#SemilatticeSup">SemilatticeSup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">α</span></span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">α</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.isFiltered_of_semilatticeSup_nonempty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L98-L99">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFiltered_of_semilatticeSup_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_of_semilatticeSup_nonempty</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Lattice.html#SemilatticeSup">SemilatticeSup</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">α</span></span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">α</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.isFilteredOrEmpty_of_directed_le"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L102-L109">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFilteredOrEmpty_of_directed_le"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_of_directed_le</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Init/Order/Defs.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Directed.html#IsDirected">IsDirected</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">α</span></span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">α</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.isFiltered_of_directed_le_nonempty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L112-L113">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFiltered_of_directed_le_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_of_directed_le_nonempty</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Init/Order/Defs.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Directed.html#IsDirected">IsDirected</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">α</span></span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">α</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.instIsFilteredDiscretePUnitDiscreteCategory"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L121-L125">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsFilteredDiscretePUnitDiscreteCategory"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredDiscretePUnitDiscreteCategory</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete">CategoryTheory.Discrete</a> <a href="../../.././Init/Prelude.html#PUnit">PUnit.{u_1 + 1}</a>     </span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsFilteredDiscretePUnitDiscreteCategory">CategoryTheory.instIsFilteredDiscretePUnitDiscreteCategory</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete">CategoryTheory.Discrete</a> <a href="../../.././Init/Prelude.html#PUnit">PUnit.{u_1 + 1}</a>     </span>)</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.max"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L148-L149">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">max</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j' : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max">max</a> j j'</code> is an arbitrary choice of object to the right of both <code>j</code> and <code>j'</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max">CategoryTheory.IsFiltered.max</a> <span class="fn">j</span> <span class="fn">j'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Std/Logic.html#Exists.choose">Exists.choose</a> <span class="fn">(_ : <span class="fn">∃ (Z : <span class="fn">C</span>) (x : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>) (x : <span class="fn"><span class="fn">j'</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <a href="../../.././Init/Prelude.html#True">True</a></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.max" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.leftToMax"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L155-L156">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.leftToMax"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">leftToMax</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j' : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max">CategoryTheory.IsFiltered.max</a> <span class="fn">j</span> <span class="fn">j'</span></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.leftToMax">leftToMax</a> j j'</code> is an arbitrary choice of morphism from <code>j</code> to <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max">max</a> j j'</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.leftToMax" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.rightToMax"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L162-L163">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.rightToMax"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">rightToMax</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j' : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">j'</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max">CategoryTheory.IsFiltered.max</a> <span class="fn">j</span> <span class="fn">j'</span></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.rightToMax">rightToMax</a> j j'</code> is an arbitrary choice of morphism from <code>j'</code> to <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max">max</a> j j'</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.rightToMax">CategoryTheory.IsFiltered.rightToMax</a> <span class="fn">j</span> <span class="fn">j'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Std/Logic.html#Exists.choose">Exists.choose</a> <span class="fn">(_ : <span class="fn">∃ (x : <span class="fn"><span class="fn">j'</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Std/Logic.html#Exists.choose">Exists.choose</a> <span class="fn">(_ : <span class="fn">∃ (Z : <span class="fn">C</span>) (x : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>) (x : <span class="fn"><span class="fn">j'</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <a href="../../.././Init/Prelude.html#True">True</a></span>)</span></span></span>), <a href="../../.././Init/Prelude.html#True">True</a></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.rightToMax" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L171-L172">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq">coeq</a> f f'</code>, for morphisms <code>f f' : j ⟶ j'</code>, is an arbitrary choice of object
which admits a morphism <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f' : j' ⟶ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq">coeq</a> f f'</code> such that
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq_condition">coeq_condition</a> : f ≫ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f' = f' ≫ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f'</code>.
Its existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq">CategoryTheory.IsFiltered.coeq</a> <span class="fn">f</span> <span class="fn">f'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Std/Logic.html#Exists.choose">Exists.choose</a>
    <span class="fn">(_ : <span class="fn">∃ (Z : <span class="fn">C</span>) (h : <span class="fn"><span class="fn">j'</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">h</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">h</span></span></span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.coeq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeqHom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L180-L181">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeqHom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">j'</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq">CategoryTheory.IsFiltered.coeq</a> <span class="fn">f</span> <span class="fn">f'</span></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f'</code>, for morphisms <code>f f' : j ⟶ j'</code>, is an arbitrary choice of morphism
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f' : j' ⟶ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq">coeq</a> f f'</code> such that
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq_condition">coeq_condition</a> : f ≫ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f' = f' ≫ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f'</code>.
Its existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.coeqHom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq_condition_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L188-L188">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq_condition_assoc"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq_condition_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq">CategoryTheory.IsFiltered.coeq</a> <span class="fn">f</span> <span class="fn">f'</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">CategoryTheory.IsFiltered.coeqHom</a> <span class="fn">f</span> <span class="fn">f'</span></span>)</span> <span class="fn">h</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">CategoryTheory.IsFiltered.coeqHom</a> <span class="fn">f</span> <span class="fn">f'</span></span>)</span> <span class="fn">h</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq_condition"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L189-L190">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq_condition"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq_condition</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">CategoryTheory.IsFiltered.coeqHom</a> <span class="fn">f</span> <span class="fn">f'</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">CategoryTheory.IsFiltered.coeqHom</a> <span class="fn">f</span> <span class="fn">f'</span></span>)</span></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq_condition">coeq_condition</a> f f'</code>, for morphisms <code>f f' : j ⟶ j'</code>, is the proof that
<code>f ≫ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f' = f' ≫ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeqHom">coeqHom</a> f f'</code>.</p></div></div><div class="decl" id="CategoryTheory.IsFilteredOrEmpty.of_right_adjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L207-L212">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty.of_right_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">of_right_adjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{L : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">L</span> <a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Adjunction">⊣</a> <span class="fn">R</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is filtered or emtpy, and we have a functor <code>R : C ⥤ D</code> with a left adjoint, then <code>D</code> is
filtered or empty.</p></div></div><div class="decl" id="CategoryTheory.IsFilteredOrEmpty.of_isRightAdjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L216-L217">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty.of_isRightAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">of_isRightAdjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(R : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.IsRightAdjoint">CategoryTheory.IsRightAdjoint</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is filtered or empty, and we have a right adjoint functor <code>R : C ⥤ D</code>, then <code>D</code> is
filtered or empty.</p></div></div><div class="decl" id="CategoryTheory.IsFilteredOrEmpty.of_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L220-L221">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsFilteredOrEmpty</span>.<span class="name">of_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">C</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">D</span></span></div></div><p>Being filtered or empty is preserved by equivalence of categories.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.sup_objs_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L236-L245">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.sup_objs_exists"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">sup_objs_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(O : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (S : <span class="fn">C</span>), <span class="fn">∀ {<span class="fn">X</span> : <span class="fn">C</span>}, <span class="fn"><span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">S</span></span>)</span></span></span></span></span></div></div><p>Any finite collection of objects in a filtered category has an object "to the right".</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.sup_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L255-L284">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.sup_exists"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">sup_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(O : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">(<span class="fn">(X : <span class="fn">C</span>) ×' <span class="fn">(Y : <span class="fn">C</span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(<span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span></span></span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (S : <span class="fn">C</span>) (T : <span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>} → <span class="fn"><span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span> → <span class="fn">(<span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">S</span></span>)</span></span></span>),
  <span class="fn">∀ {<span class="fn">X </span>Y : <span class="fn">C</span>} (<span class="fn">mX</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) (<span class="fn">mY</span> : <span class="fn"><span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) {<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>},
    <span class="fn"><span class="fn"><span class="fn">{ <span class="fn">fst</span> := <span class="fn">X</span>, <span class="fn">snd</span> := <span class="fn">{ <span class="fn">fst</span> := <span class="fn">Y</span>, <span class="fn">snd</span> := <span class="fn">{ <span class="fn">fst</span> := <span class="fn">mX</span>, <span class="fn">snd</span> := <span class="fn">{ <span class="fn">fst</span> := <span class="fn">mY</span>, <span class="fn">snd</span> := <span class="fn">f</span> }</span> }</span> }</span> }</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">H</span></span> →
      <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><span class="fn">T</span> <span class="fn">mY</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">T</span> <span class="fn">mX</span></span></span></span></span></span></div></div><p>Given any <code><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a></code> of objects <code>{X, ...}</code> and
indexed collection of <code><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a></code>s of morphisms <code>{f, ...}</code> in <code>C</code>,
there exists an object <code>S</code>, with a morphism <code>T X : X ⟶ S</code> from each <code>X</code>,
such that the triangles commute: <code>f ≫ T Y = T X</code>, for <code>f : X ⟶ Y</code> in the <code><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a></code>.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.sup"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L291-L292">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.sup"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">sup</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(O : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">(<span class="fn">(X : <span class="fn">C</span>) ×' <span class="fn">(Y : <span class="fn">C</span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(<span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span></span></span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p>An arbitrary choice of object "to the right"
of a finite collection of objects <code>O</code> and morphisms <code>H</code>,
making all the triangles commute.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.sup" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.toSup"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L297-L298">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.toSup"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">toSup</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(O : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">(<span class="fn">(X : <span class="fn">C</span>) ×' <span class="fn">(Y : <span class="fn">C</span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(<span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span></span></span></span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.sup">CategoryTheory.IsFiltered.sup</a> <span class="fn">O</span> <span class="fn">H</span></span></span></div></div><p>The morphisms to <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.sup">sup</a> O H</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.toSup" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.toSup_commutes"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L303-L306">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.toSup_commutes"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">toSup_commutes</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(O : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">(<span class="fn">(X : <span class="fn">C</span>) ×' <span class="fn">(Y : <span class="fn">C</span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(<span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span></span></span></span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(mX : <span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(mY : <span class="fn"><span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(mf : <span class="fn"><span class="fn">{ <span class="fn">fst</span> := <span class="fn">X</span>, <span class="fn">snd</span> := <span class="fn">{ <span class="fn">fst</span> := <span class="fn">Y</span>, <span class="fn">snd</span> := <span class="fn">{ <span class="fn">fst</span> := <span class="fn">mX</span>, <span class="fn">snd</span> := <span class="fn">{ <span class="fn">fst</span> := <span class="fn">mY</span>, <span class="fn">snd</span> := <span class="fn">f</span> }</span> }</span> }</span> }</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">H</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.toSup">CategoryTheory.IsFiltered.toSup</a> <span class="fn">O</span> <span class="fn">H</span> <span class="fn">mY</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.toSup">CategoryTheory.IsFiltered.toSup</a> <span class="fn">O</span> <span class="fn">H</span> <span class="fn">mX</span></span></span></div></div><p>The triangles of consisting of a morphism in <code>H</code> and the maps to <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.sup">sup</a> O H</code> commute.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.cocone_nonempty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L314-L329">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.cocone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">cocone_nonempty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">CategoryTheory.SmallCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/FinCategory.html#CategoryTheory.FinCategory">CategoryTheory.FinCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span></div></div><p>If we have <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> C</code>, then for any functor <code>F : J ⥤ C</code> with <code>FinCategory J</code>,
there exists a cocone over <code>F</code>.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.cocone"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L334-L335">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.cocone"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">cocone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> v}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">CategoryTheory.SmallCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/FinCategory.html#CategoryTheory.FinCategory">CategoryTheory.FinCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span></div></div><p>An arbitrary choice of cocone over <code>F : J ⥤ C</code>, for <code>FinCategory J</code> and <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a> C</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.cocone">CategoryTheory.IsFiltered.cocone</a> <span class="fn">F</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Logic/Nonempty.html#Nonempty.some">Nonempty.some</a> <span class="fn">(_ : <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cocone">CategoryTheory.Limits.Cocone</a> <span class="fn">F</span></span>)</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.cocone" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.of_right_adjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L342-L344">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.of_right_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_right_adjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{L : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">L</span> <a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Adjunction">⊣</a> <span class="fn">R</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is filtered, and we have a functor <code>R : C ⥤ D</code> with a left adjoint, then <code>D</code> is filtered.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.of_isRightAdjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L348-L349">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.of_isRightAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_isRightAdjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(R : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.IsRightAdjoint">CategoryTheory.IsRightAdjoint</a> <span class="fn">R</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is filtered, and we have a right adjoint functor <code>R : C ⥤ D</code>, then <code>D</code> is filtered.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.of_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L353-L354">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">of_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">C</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">D</span></span></div></div><p>Being filtered is preserved by equivalence of categories.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.max₃"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L367-L368">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">max₃</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j₁ : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j₂ : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j₃ : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max₃">max₃</a> j₁ j₂ j₃</code> is an arbitrary choice of object to the right of <code>j₁</code>, <code>j₂</code> and <code>j₃</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max₃">CategoryTheory.IsFiltered.max₃</a> <span class="fn">j₁</span> <span class="fn">j₂</span> <span class="fn">j₃</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max">CategoryTheory.IsFiltered.max</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max">CategoryTheory.IsFiltered.max</a> <span class="fn">j₁</span> <span class="fn">j₂</span></span>)</span> <span class="fn">j₃</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.max₃" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.firstToMax₃"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L374-L375">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.firstToMax₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">firstToMax₃</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j₁ : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j₂ : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j₃ : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max₃">CategoryTheory.IsFiltered.max₃</a> <span class="fn">j₁</span> <span class="fn">j₂</span> <span class="fn">j₃</span></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.firstToMax₃">firstToMax₃</a> j₁ j₂ j₃</code> is an arbitrary choice of morphism from <code>j₁</code> to <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max₃">max₃</a> j₁ j₂ j₃</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.firstToMax₃" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.secondToMax₃"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L381-L382">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.secondToMax₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">secondToMax₃</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j₁ : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j₂ : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j₃ : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">j₂</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max₃">CategoryTheory.IsFiltered.max₃</a> <span class="fn">j₁</span> <span class="fn">j₂</span> <span class="fn">j₃</span></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.secondToMax₃">secondToMax₃</a> j₁ j₂ j₃</code> is an arbitrary choice of morphism from <code>j₂</code> to <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max₃">max₃</a> j₁ j₂ j₃</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.secondToMax₃" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.thirdToMax₃"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L388-L389">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.thirdToMax₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">thirdToMax₃</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j₁ : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j₂ : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j₃ : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">j₃</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max₃">CategoryTheory.IsFiltered.max₃</a> <span class="fn">j₁</span> <span class="fn">j₂</span> <span class="fn">j₃</span></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.thirdToMax₃">thirdToMax₃</a> j₁ j₂ j₃</code> is an arbitrary choice of morphism from <code>j₃</code> to <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max₃">max₃</a> j₁ j₂ j₃</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.thirdToMax₃">CategoryTheory.IsFiltered.thirdToMax₃</a> <span class="fn">j₁</span> <span class="fn">j₂</span> <span class="fn">j₃</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.rightToMax">CategoryTheory.IsFiltered.rightToMax</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.max">CategoryTheory.IsFiltered.max</a> <span class="fn">j₁</span> <span class="fn">j₂</span></span>)</span> <span class="fn">j₃</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.thirdToMax₃" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq₃"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L397-L399">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₁ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₂ : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃">coeq₃</a> f g h</code>, for morphisms <code>f g h : j₁ ⟶ j₂</code>, is an arbitrary choice of object
which admits a morphism <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃Hom">coeq₃Hom</a> f g h : j₂ ⟶ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃">coeq₃</a> f g h</code> such that
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃_condition₁">coeq₃_condition₁</a></code>, <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃_condition₂">coeq₃_condition₂</a></code> and <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃_condition₃">coeq₃_condition₃</a></code> are satisfied.
Its existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.coeq₃" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq₃Hom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L406-L410">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃Hom"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃Hom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₁ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₂ : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">j₂</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃">CategoryTheory.IsFiltered.coeq₃</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃Hom">coeq₃Hom</a> f g h</code>, for morphisms <code>f g h : j₁ ⟶ j₂</code>, is an arbitrary choice of morphism
<code>j₂ ⟶ <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃">coeq₃</a> f g h</code> such that <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃_condition₁">coeq₃_condition₁</a></code>, <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃_condition₂">coeq₃_condition₂</a></code> and <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃_condition₃">coeq₃_condition₃</a></code>
are satisfied. Its existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">IsFiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.IsFiltered.coeq₃Hom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq₃_condition₁"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L413-L414">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃_condition₁"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃_condition₁</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₁ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₂ : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃Hom">CategoryTheory.IsFiltered.coeq₃Hom</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃Hom">CategoryTheory.IsFiltered.coeq₃Hom</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq₃_condition₂"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L417-L423">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃_condition₂"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃_condition₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₁ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₂ : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃Hom">CategoryTheory.IsFiltered.coeq₃Hom</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃Hom">CategoryTheory.IsFiltered.coeq₃Hom</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsFiltered.coeq₃_condition₃"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L426-L427">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃_condition₃"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">coeq₃_condition₃</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₁ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₂ : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃Hom">CategoryTheory.IsFiltered.coeq₃Hom</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.coeq₃Hom">CategoryTheory.IsFiltered.coeq₃Hom</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">h</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsFiltered.span"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L432-L436">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.span"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">span</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">i</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">i</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (k : <span class="fn">C</span>) (g : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k</span></span>) (g' : <span class="fn"><span class="fn">j'</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">g</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">g'</span></span></span></span></div></div><p>For every span <code>j ⟵ i ⟶ j'</code>, there
exists a cocone <code>j ⟶ k ⟵ j'</code> such that the square commutes.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.bowtie"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L452-L457">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.bowtie"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">bowtie</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₁ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₂ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{k₁ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{k₂ : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f₁ : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g₁ : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f₂ : <span class="fn"><span class="fn">j₂</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g₂ : <span class="fn"><span class="fn">j₂</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (s : <span class="fn">C</span>) (α : <span class="fn"><span class="fn">k₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">s</span></span>) (β : <span class="fn"><span class="fn">k₂</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">s</span></span>),
  <span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f₁</span> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g₁</span> <span class="fn">β</span></span></span> <a href="../../.././Init/Prelude.html#And">∧</a>     <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f₂</span> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g₂</span> <span class="fn">β</span></span></span></span></span></div></div><p>Given a "bowtie" of morphisms</p><pre><code> j₁   j₂
 |\  /|
 | \/ |
 | /\ |
 |/  \∣
 vv  vv
 k₁  k₂
</code></pre><p>in a filtered category, we can construct an object <code>s</code> and two morphisms from <code>k₁</code> and <code>k₂</code> to <code>s</code>,
making the resulting squares commute.</p></div></div><div class="decl" id="CategoryTheory.IsFiltered.tulip"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L477-L484">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered.tulip"><span class="name">CategoryTheory</span>.<span class="name">IsFiltered</span>.<span class="name">tulip</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₁ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₂ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j₃ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{k₁ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{k₂ : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{l : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f₁ : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f₂ : <span class="fn"><span class="fn">j₂</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₁</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f₃ : <span class="fn"><span class="fn">j₂</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f₄ : <span class="fn"><span class="fn">j₃</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">k₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g₁ : <span class="fn"><span class="fn">j₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g₂ : <span class="fn"><span class="fn">j₃</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">l</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (s : <span class="fn">C</span>) (α : <span class="fn"><span class="fn">k₁</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">s</span></span>) (β : <span class="fn"><span class="fn">l</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">s</span></span>) (γ : <span class="fn"><span class="fn">k₂</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">s</span></span>),
  <span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f₁</span> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g₁</span> <span class="fn">β</span></span></span> <a href="../../.././Init/Prelude.html#And">∧</a>     <span class="fn"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f₂</span> <span class="fn">α</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f₃</span> <span class="fn">γ</span></span></span> <a href="../../.././Init/Prelude.html#And">∧</a>       <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f₄</span> <span class="fn">γ</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g₂</span> <span class="fn">β</span></span></span></span></span></span></div></div><p>Given a "tulip" of morphisms</p><pre><code> j₁    j₂    j₃
 |\   / \   / |
 | \ /   \ /  |
 |  vv    vv  |
 \  k₁    k₂ /
  \         /
   \       /
    \     /
     \   /
      v v
       l
</code></pre><p>in a filtered category, we can construct an object <code>s</code> and three morphisms from <code>k₁</code>, <code>k₂</code> and <code>l</code>
to <code>s</code>, making the resulting squares commute.</p></div></div><div class="decl" id="CategoryTheory.IsCofilteredOrEmpty"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L496-L501">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A category <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">IsCofilteredOrEmpty</a></code> if</p><ol>
<li>for every pair of objects there exists another object "to the left", and</li>
<li>for every pair of parallel morphisms there exists a morphism to the left so the compositions
are equal.</li>
</ol><ul class="structure_fields" id="CategoryTheory.IsCofilteredOrEmpty.mk"><li id="CategoryTheory.IsCofilteredOrEmpty.cone_objs" class="structure_field"><div class="structure_field_info">cone_objs : <span class="fn">∀ (<span class="fn">X </span>Y : <span class="fn">C</span>), <span class="fn">∃ (W : <span class="fn">C</span>) (x : <span class="fn"><span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>) (x : <span class="fn"><span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>), <a href="../../.././Init/Prelude.html#True">True</a></span></span></div><div class="structure_field_doc"><p>for every pair of objects there exists another object "to the left"</p></div></li><li id="CategoryTheory.IsCofilteredOrEmpty.cone_maps" class="structure_field"><div class="structure_field_info">cone_maps : <span class="fn">∀ ⦃<span class="fn">X </span>Y : <span class="fn">C</span>⦄ (<span class="fn">f </span>g : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>),
  <span class="fn">∃ (W : <span class="fn">C</span>) (h : <span class="fn"><span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">g</span></span></span></span></span></div><div class="structure_field_doc"><p>for every pair of parallel morphisms there exists a morphism to the left
so the compositions are equal</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.IsCofilteredOrEmpty" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L512-L514">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="decl_extends">extends</span><span class="decl_parent">
<span class="fn"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span></a></span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A category <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a></code> if</p><ol>
<li>for every pair of objects there exists another object "to the left",</li>
<li>for every pair of parallel morphisms there exists a morphism to the left so the compositions
are equal, and</li>
<li>there exists some object.</li>
</ol><p>See <https://stacks.math.columbia.edu/tag/04AZ>.</p><ul class="structure_fields" id="CategoryTheory.IsCofiltered.mk"><li id="CategoryTheory.IsCofiltered.cone_objs" class="structure_field"><div class="structure_field_info">cone_objs : <span class="fn">∀ (<span class="fn">X </span>Y : <span class="fn">C</span>), <span class="fn">∃ (W : <span class="fn">C</span>) (x : <span class="fn"><span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>) (x : <span class="fn"><span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>), <a href="../../.././Init/Prelude.html#True">True</a></span></span></div></li><li id="CategoryTheory.IsCofiltered.cone_maps" class="structure_field"><div class="structure_field_info">cone_maps : <span class="fn">∀ ⦃<span class="fn">X </span>Y : <span class="fn">C</span>⦄ (<span class="fn">f </span>g : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>),
  <span class="fn">∃ (W : <span class="fn">C</span>) (h : <span class="fn"><span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">g</span></span></span></span></span></div></li><li id="CategoryTheory.IsCofiltered.nonempty" class="structure_field"><div class="structure_field_info">nonempty : <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">C</span></span></div><div class="structure_field_doc"><p>a cofiltered category must be non empty</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.IsCofiltered" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.isCofilteredOrEmpty_of_semilatticeInf"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L517-L522">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofilteredOrEmpty_of_semilatticeInf"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_of_semilatticeInf</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Lattice.html#SemilatticeInf">SemilatticeInf</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">α</span></span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">α</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.isCofiltered_of_semilatticeInf_nonempty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L525-L526">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofiltered_of_semilatticeInf_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_of_semilatticeInf_nonempty</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Lattice.html#SemilatticeInf">SemilatticeInf</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">α</span></span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">α</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.isCofilteredOrEmpty_of_directed_ge"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L529-L536">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofilteredOrEmpty_of_directed_ge"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_of_directed_ge</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Init/Order/Defs.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Directed.html#IsDirected">IsDirected</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#GE.ge">≥</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">α</span></span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">α</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.isCofiltered_of_directed_ge_nonempty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L539-L540">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofiltered_of_directed_ge_nonempty"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_of_directed_ge_nonempty</span></a></span><span class="decl_args">
<span class="fn">(α : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Init/Order/Defs.html#Preorder">Preorder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Order/Directed.html#IsDirected">IsDirected</a> <span class="fn">α</span> <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Init/Prelude.html#GE.ge">≥</a> <span class="fn">x_1</span></span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">α</span></span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">α</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.instIsCofilteredDiscretePUnitDiscreteCategory"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L548-L552">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsCofilteredDiscretePUnitDiscreteCategory"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredDiscretePUnitDiscreteCategory</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete">CategoryTheory.Discrete</a> <a href="../../.././Init/Prelude.html#PUnit">PUnit.{u_1 + 1}</a>     </span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsCofilteredDiscretePUnitDiscreteCategory">CategoryTheory.instIsCofilteredDiscretePUnitDiscreteCategory</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete">CategoryTheory.Discrete</a> <a href="../../.././Init/Prelude.html#PUnit">PUnit.{u_1 + 1}</a>     </span>)</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.min"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L575-L576">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.min"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">min</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j' : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.min">min</a> j j'</code> is an arbitrary choice of object to the left of both <code>j</code> and <code>j'</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.min">CategoryTheory.IsCofiltered.min</a> <span class="fn">j</span> <span class="fn">j'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Std/Logic.html#Exists.choose">Exists.choose</a> <span class="fn">(_ : <span class="fn">∃ (W : <span class="fn">C</span>) (x : <span class="fn"><span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j</span></span>) (x : <span class="fn"><span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>), <a href="../../.././Init/Prelude.html#True">True</a></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsCofiltered.min" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.minToLeft"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L582-L583">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.minToLeft"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">minToLeft</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j' : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.min">CategoryTheory.IsCofiltered.min</a> <span class="fn">j</span> <span class="fn">j'</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j</span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.minToLeft">minToLeft</a> j j'</code> is an arbitrary choice of morphism from <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.min">min</a> j j'</code> to <code>j</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.IsCofiltered.minToLeft" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.minToRight"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L589-L590">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.minToRight"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">minToRight</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(j : <span class="fn">C</span>)</span></span>
<span class="decl_args">
<span class="fn">(j' : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.min">CategoryTheory.IsCofiltered.min</a> <span class="fn">j</span> <span class="fn">j'</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.minToRight">minToRight</a> j j'</code> is an arbitrary choice of morphism from <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.min">min</a> j j'</code> to <code>j'</code>,
whose existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.minToRight">CategoryTheory.IsCofiltered.minToRight</a> <span class="fn">j</span> <span class="fn">j'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Std/Logic.html#Exists.choose">Exists.choose</a> <span class="fn">(_ : <span class="fn">∃ (x : <span class="fn"><span class="fn"><a href="../../.././Std/Logic.html#Exists.choose">Exists.choose</a> <span class="fn">(_ : <span class="fn">∃ (W : <span class="fn">C</span>) (x : <span class="fn"><span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j</span></span>) (x : <span class="fn"><span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>), <a href="../../.././Init/Prelude.html#True">True</a></span>)</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>), <a href="../../.././Init/Prelude.html#True">True</a></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsCofiltered.minToRight" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.eq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L598-L599">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq">eq</a> f f'</code>, for morphisms <code>f f' : j ⟶ j'</code>, is an arbitrary choice of object
which admits a morphism <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' : <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq">eq</a> f f' ⟶ j</code> such that
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq_condition">eq_condition</a> : <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' ≫ f = <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' ≫ f'</code>.
Its existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq">CategoryTheory.IsCofiltered.eq</a> <span class="fn">f</span> <span class="fn">f'</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Std/Logic.html#Exists.choose">Exists.choose</a>
    <span class="fn">(_ : <span class="fn">∃ (W : <span class="fn">C</span>) (h : <span class="fn"><span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">f'</span></span></span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsCofiltered.eq" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.eqHom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L607-L608">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eqHom</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq">CategoryTheory.IsCofiltered.eq</a> <span class="fn">f</span> <span class="fn">f'</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j</span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f'</code>, for morphisms <code>f f' : j ⟶ j'</code>, is an arbitrary choice of morphism
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' : <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq">eq</a> f f' ⟶ j</code> such that
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq_condition">eq_condition</a> : <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' ≫ f = <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' ≫ f'</code>.
Its existence is ensured by <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.IsCofiltered.eqHom" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.eq_condition_assoc"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L615-L615">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq_condition_assoc"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eq_condition_assoc</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">j'</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">CategoryTheory.IsCofiltered.eqHom</a> <span class="fn">f</span> <span class="fn">f'</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f</span> <span class="fn">h</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">CategoryTheory.IsCofiltered.eqHom</a> <span class="fn">f</span> <span class="fn">f'</span></span>)</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">f'</span> <span class="fn">h</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsCofiltered.eq_condition"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L616-L617">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq_condition"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">eq_condition</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">CategoryTheory.IsCofiltered.eqHom</a> <span class="fn">f</span> <span class="fn">f'</span></span>)</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">CategoryTheory.IsCofiltered.eqHom</a> <span class="fn">f</span> <span class="fn">f'</span></span>)</span> <span class="fn">f'</span></span></span></div></div><p><code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eq_condition">eq_condition</a> f f'</code>, for morphisms <code>f f' : j ⟶ j'</code>, is the proof that
<code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' ≫ f = <a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.eqHom">eqHom</a> f f' ≫ f'</code>.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.cospan"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L622-L626">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.cospan"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">cospan</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j' : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">j</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">i</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f' : <span class="fn"><span class="fn">j'</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">i</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (k : <span class="fn">C</span>) (g : <span class="fn"><span class="fn">k</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j</span></span>) (g' : <span class="fn"><span class="fn">k</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j'</span></span>), <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g'</span> <span class="fn">f'</span></span></span></span></div></div><p>For every cospan <code>j ⟶ i ⟵ j'</code>,
there exists a cone <code>j ⟵ k ⟶ j'</code> such that the square commutes.</p></div></div><div class="decl" id="CategoryTheory.Functor.ranges_directed"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L629-L632">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.Functor.ranges_directed"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">ranges_directed</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <a href="../../.././foundational_types.html">(<a href="../../.././foundational_types.html">Type</a> u_1)</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(j : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/Order/Directed.html#Directed">Directed</a> <span class="fn">(<span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn"><a href="../../.././Mathlib/Init/Set.html#Set">Set</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.obj <span class="fn">j</span></span>)</span></span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../../.././Std/Classes/SetNotation.html#Superset">⊇</a> <span class="fn">x_1</span></span></span>)</span> <span class="fn">fun (<span class="fn">f</span> : <span class="fn">(i : <span class="fn">C</span>) ×' <span class="fn">(<span class="fn"><span class="fn">i</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">j</span></span>)</span></span>) =&gt; <span class="fn"><a href="../../.././Mathlib/Data/Set/Defs.html#Set.range">Set.range</a> <span class="fn">(<span class="fn"><span class="fn">F</span>.map <span class="fn"><span class="fn">f</span>.snd</span></span>)</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.IsCofilteredOrEmpty.of_left_adjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L649-L655">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty.of_left_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">of_left_adjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{L : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">L</span> <a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Adjunction">⊣</a> <span class="fn">R</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is cofiltered or empty, and we have a functor <code>L : C ⥤ D</code> with a right adjoint,
then <code>D</code> is cofiltered or empty.</p></div></div><div class="decl" id="CategoryTheory.IsCofilteredOrEmpty.of_isLeftAdjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L659-L660">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty.of_isLeftAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">of_isLeftAdjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(L : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.IsLeftAdjoint">CategoryTheory.IsLeftAdjoint</a> <span class="fn">L</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is cofiltered or empty, and we have a left adjoint functor <code>L : C ⥤ D</code>, then <code>D</code> is
cofiltered or empty.</p></div></div><div class="decl" id="CategoryTheory.IsCofilteredOrEmpty.of_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L663-L664">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsCofilteredOrEmpty</span>.<span class="name">of_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">C</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">D</span></span></div></div><p>Being cofiltered or empty is preserved by equivalence of categories.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.inf_objs_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L679-L688">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.inf_objs_exists"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">inf_objs_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(O : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (S : <span class="fn">C</span>), <span class="fn">∀ {<span class="fn">X</span> : <span class="fn">C</span>}, <span class="fn"><span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span> → <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<span class="fn"><span class="fn">S</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>)</span></span></span></span></span></div></div><p>Any finite collection of objects in a cofiltered category has an object "to the left".</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.inf_exists"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L698-L727">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.inf_exists"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">inf_exists</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(O : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">(<span class="fn">(X : <span class="fn">C</span>) ×' <span class="fn">(Y : <span class="fn">C</span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(<span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span></span></span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∃ (S : <span class="fn">C</span>) (T : <span class="fn">{<span class="fn">X</span> : <span class="fn">C</span>} → <span class="fn"><span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span> → <span class="fn">(<span class="fn"><span class="fn">S</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>)</span></span></span>),
  <span class="fn">∀ {<span class="fn">X </span>Y : <span class="fn">C</span>} (<span class="fn">mX</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) (<span class="fn">mY</span> : <span class="fn"><span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) {<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>},
    <span class="fn"><span class="fn"><span class="fn">{ <span class="fn">fst</span> := <span class="fn">X</span>, <span class="fn">snd</span> := <span class="fn">{ <span class="fn">fst</span> := <span class="fn">Y</span>, <span class="fn">snd</span> := <span class="fn">{ <span class="fn">fst</span> := <span class="fn">mX</span>, <span class="fn">snd</span> := <span class="fn">{ <span class="fn">fst</span> := <span class="fn">mY</span>, <span class="fn">snd</span> := <span class="fn">f</span> }</span> }</span> }</span> }</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">H</span></span> →
      <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><span class="fn">T</span> <span class="fn">mX</span></span>)</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">T</span> <span class="fn">mY</span></span></span></span></span></span></div></div><p>Given any <code><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a></code> of objects <code>{X, ...}</code> and
indexed collection of <code><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a></code>s of morphisms <code>{f, ...}</code> in <code>C</code>,
there exists an object <code>S</code>, with a morphism <code>T X : S ⟶ X</code> from each <code>X</code>,
such that the triangles commute: <code>T X ≫ f = T Y</code>, for <code>f : X ⟶ Y</code> in the <code><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a></code>.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.inf"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L734-L735">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.inf"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">inf</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(O : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">(<span class="fn">(X : <span class="fn">C</span>) ×' <span class="fn">(Y : <span class="fn">C</span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(<span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span></span></span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p>An arbitrary choice of object "to the left"
of a finite collection of objects <code>O</code> and morphisms <code>H</code>,
making all the triangles commute.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.IsCofiltered.inf" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.infTo"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L740-L741">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.infTo"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">infTo</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(O : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">(<span class="fn">(X : <span class="fn">C</span>) ×' <span class="fn">(Y : <span class="fn">C</span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(<span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span></span></span></span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.inf">CategoryTheory.IsCofiltered.inf</a> <span class="fn">O</span> <span class="fn">H</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span></div></div><p>The morphisms from <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.inf">inf</a> O H</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.IsCofiltered.infTo" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.infTo_commutes"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L746-L749">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.infTo_commutes"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">infTo_commutes</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(O : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(H : <span class="fn"><a href="../../.././Mathlib/Data/Finset/Basic.html#Finset">Finset</a> <span class="fn">(<span class="fn">(X : <span class="fn">C</span>) ×' <span class="fn">(Y : <span class="fn">C</span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(_ : <span class="fn"><span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>) ×' <span class="fn">(<span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span></span></span></span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(mX : <span class="fn"><span class="fn">X</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(mY : <span class="fn"><span class="fn">Y</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">O</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(mf : <span class="fn"><span class="fn">{ <span class="fn">fst</span> := <span class="fn">X</span>, <span class="fn">snd</span> := <span class="fn">{ <span class="fn">fst</span> := <span class="fn">Y</span>, <span class="fn">snd</span> := <span class="fn">{ <span class="fn">fst</span> := <span class="fn">mX</span>, <span class="fn">snd</span> := <span class="fn">{ <span class="fn">fst</span> := <span class="fn">mY</span>, <span class="fn">snd</span> := <span class="fn">f</span> }</span> }</span> }</span> }</span> <a href="../../.././Init/Prelude.html#Membership.mem">∈</a> <span class="fn">H</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.infTo">CategoryTheory.IsCofiltered.infTo</a> <span class="fn">O</span> <span class="fn">H</span> <span class="fn">mX</span></span>)</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.infTo">CategoryTheory.IsCofiltered.infTo</a> <span class="fn">O</span> <span class="fn">H</span> <span class="fn">mY</span></span></span></div></div><p>The triangles consisting of a morphism in <code>H</code> and the maps from <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.inf">inf</a> O H</code> commute.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.cone_nonempty"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L757-L773">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.cone_nonempty"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">cone_nonempty</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">CategoryTheory.SmallCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/FinCategory.html#CategoryTheory.FinCategory">CategoryTheory.FinCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span></div></div><p>If we have <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> C</code>, then for any functor <code>F : J ⥤ C</code> with <code>FinCategory J</code>,
there exists a cone over <code>F</code>.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.cone"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L778-L779">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.cone"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">cone</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{J : <a href="../../.././foundational_types.html">Type</a> w}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.SmallCategory">CategoryTheory.SmallCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/FinCategory.html#CategoryTheory.FinCategory">CategoryTheory.FinCategory</a> <span class="fn">J</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">J</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span></div></div><p>An arbitrary choice of cone over <code>F : J ⥤ C</code>, for <code>FinCategory J</code> and <code><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">IsCofiltered</a> C</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.cone">CategoryTheory.IsCofiltered.cone</a> <span class="fn">F</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/Logic/Nonempty.html#Nonempty.some">Nonempty.some</a> <span class="fn">(_ : <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Cones.html#CategoryTheory.Limits.Cone">CategoryTheory.Limits.Cone</a> <span class="fn">F</span></span>)</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.IsCofiltered.cone" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsCofiltered.of_left_adjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L787-L789">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.of_left_adjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_left_adjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{L : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{R : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">L</span> <a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Adjunction">⊣</a> <span class="fn">R</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is cofiltered, and we have a functor <code>L : C ⥤ D</code> with a right adjoint,
then <code>D</code> is cofiltered.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.of_isLeftAdjoint"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L793-L794">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.of_isLeftAdjoint"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_isLeftAdjoint</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(L : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.IsLeftAdjoint">CategoryTheory.IsLeftAdjoint</a> <span class="fn">L</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">D</span></span></div></div><p>If <code>C</code> is cofiltered, and we have a left adjoint functor <code>L : C ⥤ D</code>, then <code>D</code> is cofiltered.</p></div></div><div class="decl" id="CategoryTheory.IsCofiltered.of_equivalence"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L798-L799">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered.of_equivalence"><span class="name">CategoryTheory</span>.<span class="name">IsCofiltered</span>.<span class="name">of_equivalence</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">C</span> <a href="../../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">D</span></span></div></div><p>Being cofiltered is preserved by equivalence of categories.</p></div></div><div class="decl" id="CategoryTheory.isCofilteredOrEmpty_op_of_isFilteredOrEmpty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L810-L819">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofilteredOrEmpty_op_of_isFilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_op_of_isFilteredOrEmpty</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.isCofiltered_op_of_isFiltered"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L821-L822">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofiltered_op_of_isFiltered"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_op_of_isFiltered</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.isFilteredOrEmpty_op_of_isCofilteredOrEmpty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L825-L834">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFilteredOrEmpty_op_of_isCofilteredOrEmpty"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_op_of_isCofilteredOrEmpty</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.isFiltered_op_of_isCofiltered"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L836-L837">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFiltered_op_of_isCofiltered"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_op_of_isCofiltered</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.isCofilteredOrEmpty_of_isFilteredOrEmpty_op"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L841-L842">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofilteredOrEmpty_of_isFilteredOrEmpty_op"><span class="name">CategoryTheory</span>.<span class="name">isCofilteredOrEmpty_of_isFilteredOrEmpty_op</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn">C</span></span></div></div><p>If Cᵒᵖ is filtered or empty, then C is cofiltered or empty.</p></div></div><div class="decl" id="CategoryTheory.isFilteredOrEmpty_of_isCofilteredOrEmpty_op"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L845-L846">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFilteredOrEmpty_of_isCofilteredOrEmpty_op"><span class="name">CategoryTheory</span>.<span class="name">isFilteredOrEmpty_of_isCofilteredOrEmpty_op</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofilteredOrEmpty">CategoryTheory.IsCofilteredOrEmpty</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFilteredOrEmpty">CategoryTheory.IsFilteredOrEmpty</a> <span class="fn">C</span></span></div></div><p>If Cᵒᵖ is cofiltered or empty, then C is filtered or empty.</p></div></div><div class="decl" id="CategoryTheory.isCofiltered_of_isFiltered_op"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L849-L850">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isCofiltered_of_isFiltered_op"><span class="name">CategoryTheory</span>.<span class="name">isCofiltered_of_isFiltered_op</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span></div></div><p>If Cᵒᵖ is filtered, then C is cofiltered.</p></div></div><div class="decl" id="CategoryTheory.isFiltered_of_isCofiltered_op"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L853-L854">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.isFiltered_of_isCofiltered_op"><span class="name">CategoryTheory</span>.<span class="name">isFiltered_of_isCofiltered_op</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span></div></div><p>If Cᵒᵖ is cofiltered, then C is filtered.</p></div></div><div class="decl" id="CategoryTheory.instIsFilteredULiftUliftCategory"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L860-L861">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsFilteredULiftUliftCategory"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredULiftUliftCategory</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">(<span class="fn"><a href="../../.././Init/Prelude.html#ULift">ULift.{u₂, u}</a>    <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">(<span class="fn"><a href="../../.././Init/Prelude.html#ULift">ULift.{u₂, u}</a>    <span class="fn">C</span></span>)</span></span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">(<span class="fn"><a href="../../.././Init/Prelude.html#ULift">ULift.{u₂, u}</a>    <span class="fn">C</span></span>)</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.instIsCofilteredULiftUliftCategory"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L863-L864">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsCofilteredULiftUliftCategory"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredULiftUliftCategory</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">(<span class="fn"><a href="../../.././Init/Prelude.html#ULift">ULift.{u₂, u}</a>    <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">(<span class="fn"><a href="../../.././Init/Prelude.html#ULift">ULift.{u₂, u}</a>    <span class="fn">C</span></span>)</span></span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">(<span class="fn"><a href="../../.././Init/Prelude.html#ULift">ULift.{u₂, u}</a>    <span class="fn">C</span></span>)</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.instIsFilteredULiftHomCategory"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L866-L867">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsFilteredULiftHomCategory"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredULiftHomCategory</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/ULift.html#CategoryTheory.ULiftHom">CategoryTheory.ULiftHom</a> <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/ULift.html#CategoryTheory.ULiftHom">CategoryTheory.ULiftHom</a> <span class="fn">C</span></span>)</span></span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/ULift.html#CategoryTheory.ULiftHom">CategoryTheory.ULiftHom</a> <span class="fn">C</span></span>)</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.instIsCofilteredULiftHomCategory"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L869-L870">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsCofilteredULiftHomCategory"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredULiftHomCategory</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/ULift.html#CategoryTheory.ULiftHom">CategoryTheory.ULiftHom</a> <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/ULift.html#CategoryTheory.ULiftHom">CategoryTheory.ULiftHom</a> <span class="fn">C</span></span>)</span></span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/ULift.html#CategoryTheory.ULiftHom">CategoryTheory.ULiftHom</a> <span class="fn">C</span></span>)</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.instIsFilteredAsSmallInstSmallCategoryAsSmall"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L872-L873">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsFilteredAsSmallInstSmallCategoryAsSmall"><span class="name">CategoryTheory</span>.<span class="name">instIsFilteredAsSmallInstSmallCategoryAsSmall</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/ULift.html#CategoryTheory.AsSmall">CategoryTheory.AsSmall</a> <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/ULift.html#CategoryTheory.AsSmall">CategoryTheory.AsSmall</a> <span class="fn">C</span></span>)</span></span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsFiltered">CategoryTheory.IsFiltered</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/ULift.html#CategoryTheory.AsSmall">CategoryTheory.AsSmall</a> <span class="fn">C</span></span>)</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.instIsCofilteredAsSmallInstSmallCategoryAsSmall"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Filtered/Basic.lean#L875-L876">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.instIsCofilteredAsSmallInstSmallCategoryAsSmall"><span class="name">CategoryTheory</span>.<span class="name">instIsCofilteredAsSmallInstSmallCategoryAsSmall</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/ULift.html#CategoryTheory.AsSmall">CategoryTheory.AsSmall</a> <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/ULift.html#CategoryTheory.AsSmall">CategoryTheory.AsSmall</a> <span class="fn">C</span></span>)</span></span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Filtered/Basic.html#CategoryTheory.IsCofiltered">CategoryTheory.IsCofiltered</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/ULift.html#CategoryTheory.AsSmall">CategoryTheory.AsSmall</a> <span class="fn">C</span></span>)</span></span>)</span></span></li></ul></details></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>