<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="stylesheet" href="../.././src/pygments.css"></link><link rel="shortcut icon" href="../.././favicon.ico"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.CategoryTheory.Skeletal</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Mathlib.CategoryTheory.Skeletal";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">CategoryTheory</span>.<span class="name">Skeletal</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;
            <button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Mathlib/CategoryTheory/IsomorphismClasses.html">Mathlib.CategoryTheory.IsomorphismClasses</a></li><li><a href="../.././Mathlib/CategoryTheory/Thin.html">Mathlib.CategoryTheory.Thin</a></li><li><a href="../.././Mathlib/CategoryTheory/Adjunction/Basic.html">Mathlib.CategoryTheory.Adjunction.Basic</a></li><li><a href="../.././Mathlib/CategoryTheory/Category/Preorder.html">Mathlib.CategoryTheory.Category.Preorder</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.CategoryTheory.Skeletal" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Skeletal"><span class="name">CategoryTheory</span>.<span class="name">Skeletal</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.IsSkeletonOf"><span class="name">CategoryTheory</span>.<span class="name">IsSkeletonOf</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Functor.eq_of_iso"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">eq_of_iso</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.functor_skeletal"><span class="name">CategoryTheory</span>.<span class="name">functor_skeletal</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Skeleton"><span class="name">CategoryTheory</span>.<span class="name">Skeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instInhabitedSkeleton"><span class="name">CategoryTheory</span>.<span class="name">instInhabitedSkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instCategorySkeleton"><span class="name">CategoryTheory</span>.<span class="name">instCategorySkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.fromSkeleton_map"><span class="name">CategoryTheory</span>.<span class="name">fromSkeleton_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.fromSkeleton_obj"><span class="name">CategoryTheory</span>.<span class="name">fromSkeleton_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.fromSkeleton"><span class="name">CategoryTheory</span>.<span class="name">fromSkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instFullSkeletonInstCategorySkeletonFromSkeleton"><span class="name">CategoryTheory</span>.<span class="name">instFullSkeletonInstCategorySkeletonFromSkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instFaithfulSkeletonInstCategorySkeletonFromSkeleton"><span class="name">CategoryTheory</span>.<span class="name">instFaithfulSkeletonInstCategorySkeletonFromSkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instEssSurjSkeletonInstCategorySkeletonFromSkeleton"><span class="name">CategoryTheory</span>.<span class="name">instEssSurjSkeletonInstCategorySkeletonFromSkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.fromSkeleton.isEquivalence"><span class="name">CategoryTheory</span>.<span class="name">fromSkeleton</span>.<span class="name">isEquivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.skeletonEquivalence"><span class="name">CategoryTheory</span>.<span class="name">skeletonEquivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.skeleton_skeletal"><span class="name">CategoryTheory</span>.<span class="name">skeleton_skeletal</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.skeletonIsSkeleton"><span class="name">CategoryTheory</span>.<span class="name">skeletonIsSkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.skeletonEquiv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">skeletonEquiv</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.inhabitedThinSkeleton"><span class="name">CategoryTheory</span>.<span class="name">inhabitedThinSkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.preorder"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">preorder</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.toThinSkeleton_obj"><span class="name">CategoryTheory</span>.<span class="name">toThinSkeleton_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.toThinSkeleton_map"><span class="name">CategoryTheory</span>.<span class="name">toThinSkeleton_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.toThinSkeleton"><span class="name">CategoryTheory</span>.<span class="name">toThinSkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.thin"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">thin</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.map_map"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.map_obj"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.map"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.comp_toThinSkeleton"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">comp_toThinSkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.mapNatTrans"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">mapNatTrans</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.map₂ObjMap"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map₂ObjMap</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.map₂Functor"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map₂Functor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.map₂NatTrans"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map₂NatTrans</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.map₂_obj"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map₂_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.map₂_map"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map₂_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.map₂"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map₂</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.toThinSkeleton_faithful"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">toThinSkeleton_faithful</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.fromThinSkeleton_obj"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">fromThinSkeleton_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.fromThinSkeleton_map"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">fromThinSkeleton_map</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.fromThinSkeleton"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">fromThinSkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.fromThinSkeletonEquivalence"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">fromThinSkeletonEquivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.equivalence"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">equivalence</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.equiv_of_both_ways"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">equiv_of_both_ways</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.thinSkeletonPartialOrder"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">thinSkeletonPartialOrder</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.skeletal"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">skeletal</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.map_comp_eq"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map_comp_eq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.map_id_eq"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map_id_eq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.map_iso_eq"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map_iso_eq</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.thinSkeletonIsSkeleton"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">thinSkeletonIsSkeleton</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.isSkeletonOfInhabited"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">isSkeletonOfInhabited</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.ThinSkeleton.lowerAdjunction"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">lowerAdjunction</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Equivalence.thinSkeletonOrderIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">thinSkeletonOrderIso</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Skeleton-of-a-category">Skeleton of a category <a class="hover-link" href="#Skeleton-of-a-category">#</a></h1><p>Define skeletal categories as categories in which any two isomorphic objects are equal.</p><p>Construct the skeleton of an arbitrary category by taking isomorphism classes, and show it is a
skeleton of the original category.</p><p>In addition, construct the skeleton of a thin category as a partial ordering, and (noncomputably)
show it is a skeleton of the original category. The advantage of this special case being handled
separately is that lemmas and definitions about orderings can be used directly, for example for the
subobject lattice. In addition, some of the commutative diagrams about the functors commute
definitionally on the nose which is convenient in practice.</p></div><div class="decl" id="CategoryTheory.Skeletal"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L42-L43">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeletal"><span class="name">CategoryTheory</span>.<span class="name">Skeletal</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Prop</a></div></div><p>A category is skeletal if isomorphic objects are equal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeletal">CategoryTheory.Skeletal</a> <span class="fn">C</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">∀ ⦃<span class="fn">X </span>Y : <span class="fn">C</span>⦄, <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/IsomorphismClasses.html#CategoryTheory.IsIsomorphic">CategoryTheory.IsIsomorphic</a> <span class="fn">X</span> <span class="fn">Y</span></span> → <span class="fn"><span class="fn">X</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">Y</span></span></span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Skeletal" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.IsSkeletonOf"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L49-L53">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.IsSkeletonOf"><span class="name">CategoryTheory</span>.<span class="name">IsSkeletonOf</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(D : <a href="../.././foundational_types.html">Type</a> u₂)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> (max (max (max u₁ u₂) v₁) v₂)</div></div><p><code><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.IsSkeletonOf">IsSkeletonOf</a> C D F</code> says that <code>F : D ⥤ C</code> exhibits <code>D</code> as a skeletal full subcategory of <code>C</code>,
in particular <code>F</code> is a (strong) equivalence and <code>D</code> is skeletal.</p><ul class="structure_fields" id="CategoryTheory.IsSkeletonOf.mk"><li id="CategoryTheory.IsSkeletonOf.skel" class="structure_field"><div class="structure_field_info">skel : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeletal">CategoryTheory.Skeletal</a> <span class="fn">D</span></span></div><div class="structure_field_doc"><p>The category <code>D</code> has isomorphic objects equal</p></div></li><li id="CategoryTheory.IsSkeletonOf.eqv" class="structure_field"><div class="structure_field_info">eqv : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">F</span></span></div><div class="structure_field_doc"><p>The functor <code>F</code> is an equivalence</p></div></li></ul><details id="instances-for-list-CategoryTheory.IsSkeletonOf" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Functor.eq_of_iso"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L61-L63">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Functor.eq_of_iso"><span class="name">CategoryTheory</span>.<span class="name">Functor</span>.<span class="name">eq_of_iso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F₁ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F₂ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(hC : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeletal">CategoryTheory.Skeletal</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(hF : <span class="fn"><span class="fn">F₁</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">F₁</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">F₂</span></span></div></div><p>If <code>C</code> is thin and skeletal, then any naturally isomorphic functors to <code>C</code> are equal.</p></div></div><div class="decl" id="CategoryTheory.functor_skeletal"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L69-L70">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.functor_skeletal"><span class="name">CategoryTheory</span>.<span class="name">functor_skeletal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(hC : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeletal">CategoryTheory.Skeletal</a> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeletal">CategoryTheory.Skeletal</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>)</span></span></div></div><p>If <code>C</code> is thin and skeletal, <code>D ⥤ C</code> is skeletal.
<code><a href="../.././Mathlib/CategoryTheory/Thin.html#CategoryTheory.functor_thin">CategoryTheory.functor_thin</a></code> shows it is thin also.</p></div></div><div class="decl" id="CategoryTheory.Skeleton"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L78-L78">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton"><span class="name">CategoryTheory</span>.<span class="name">Skeleton</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> u₁</div></div><p>Construct the skeleton category as the induced category on the isomorphism classes, and derive
its category structure.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">CategoryTheory.Skeleton</a> <span class="fn">C</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/FullSubcategory.html#CategoryTheory.InducedCategory">CategoryTheory.InducedCategory</a> <span class="fn">C</span> <span class="fn">Quotient.out</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Skeleton" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.instInhabitedSkeleton"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L81-L82">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.instInhabitedSkeleton"><span class="name">CategoryTheory</span>.<span class="name">instInhabitedSkeleton</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">CategoryTheory.Skeleton</a> <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.instInhabitedSkeleton">CategoryTheory.instInhabitedSkeleton</a> <span class="fn">C</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">⟦<span class="fn">default</span>⟧</span> }</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.instCategorySkeleton"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L85-L86">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.instCategorySkeleton"><span class="name">CategoryTheory</span>.<span class="name">instCategorySkeleton</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">CategoryTheory.Skeleton</a> <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.instCategorySkeleton">CategoryTheory.instCategorySkeleton</a> <span class="fn">C</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/FullSubcategory.html#CategoryTheory.InducedCategory.category">CategoryTheory.InducedCategory.category</a> <span class="fn">Quotient.out</span></span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.fromSkeleton_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L89-L89">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton_map"><span class="name">CategoryTheory</span>.<span class="name">fromSkeleton_map</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X </span>Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/FullSubcategory.html#CategoryTheory.InducedCategory">CategoryTheory.InducedCategory</a> <span class="fn">C</span> <span class="fn">Quotient.out</span></span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>), <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton">CategoryTheory.fromSkeleton</a> <span class="fn">C</span></span>)</span>.map <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">f</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.fromSkeleton_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L89-L89">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton_obj"><span class="name">CategoryTheory</span>.<span class="name">fromSkeleton_obj</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ (<span class="fn">a</span> : <span class="fn"><a href="../.././Init/Core.html#Quotient">Quotient</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/IsomorphismClasses.html#CategoryTheory.isIsomorphicSetoid">CategoryTheory.isIsomorphicSetoid</a> <span class="fn">C</span></span>)</span></span>), <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton">CategoryTheory.fromSkeleton</a> <span class="fn">C</span></span>)</span>.obj <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Data/Quot.html#Quotient.out">Quotient.out</a> <span class="fn">a</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.fromSkeleton"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L90-L91">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton"><span class="name">CategoryTheory</span>.<span class="name">fromSkeleton</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">CategoryTheory.Skeleton</a> <span class="fn">C</span></span>)</span> <span class="fn">C</span></span></div></div><p>The functor from the skeleton of <code>C</code> to <code>C</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton">CategoryTheory.fromSkeleton</a> <span class="fn">C</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/FullSubcategory.html#CategoryTheory.inducedFunctor">CategoryTheory.inducedFunctor</a> <span class="fn">Quotient.out</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.fromSkeleton" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.instFullSkeletonInstCategorySkeletonFromSkeleton"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L95-L96">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.instFullSkeletonInstCategorySkeletonFromSkeleton"><span class="name">CategoryTheory</span>.<span class="name">instFullSkeletonInstCategorySkeletonFromSkeleton</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Full">CategoryTheory.Full</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton">CategoryTheory.fromSkeleton</a> <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.instFullSkeletonInstCategorySkeletonFromSkeleton">CategoryTheory.instFullSkeletonInstCategorySkeletonFromSkeleton</a> <span class="fn">C</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/FullSubcategory.html#CategoryTheory.InducedCategory.full">CategoryTheory.InducedCategory.full</a> <span class="fn">Quotient.out</span></span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.instFaithfulSkeletonInstCategorySkeletonFromSkeleton"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L97-L98">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.instFaithfulSkeletonInstCategorySkeletonFromSkeleton"><span class="name">CategoryTheory</span>.<span class="name">instFaithfulSkeletonInstCategorySkeletonFromSkeleton</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Faithful">CategoryTheory.Faithful</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton">CategoryTheory.fromSkeleton</a> <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Faithful">CategoryTheory.Faithful</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton">CategoryTheory.fromSkeleton</a> <span class="fn">C</span></span>)</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Faithful">CategoryTheory.Faithful</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/FullSubcategory.html#CategoryTheory.inducedFunctor">CategoryTheory.inducedFunctor</a> <span class="fn">Quotient.out</span></span>)</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.instEssSurjSkeletonInstCategorySkeletonFromSkeleton"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L100-L100">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.instEssSurjSkeletonInstCategorySkeletonFromSkeleton"><span class="name">CategoryTheory</span>.<span class="name">instEssSurjSkeletonInstCategorySkeletonFromSkeleton</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.EssSurj">CategoryTheory.EssSurj</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton">CategoryTheory.fromSkeleton</a> <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.EssSurj">CategoryTheory.EssSurj</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton">CategoryTheory.fromSkeleton</a> <span class="fn">C</span></span>)</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/EssentialImage.html#CategoryTheory.EssSurj">CategoryTheory.EssSurj</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton">CategoryTheory.fromSkeleton</a> <span class="fn">C</span></span>)</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.fromSkeleton.isEquivalence"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L103-L104">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton.isEquivalence"><span class="name">CategoryTheory</span>.<span class="name">fromSkeleton</span>.<span class="name">isEquivalence</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton">CategoryTheory.fromSkeleton</a> <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton.isEquivalence">CategoryTheory.fromSkeleton.isEquivalence</a> <span class="fn">C</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence.ofFullyFaithfullyEssSurj">CategoryTheory.Equivalence.ofFullyFaithfullyEssSurj</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton">CategoryTheory.fromSkeleton</a> <span class="fn">C</span></span>)</span></span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.skeletonEquivalence"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L107-L108">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.skeletonEquivalence"><span class="name">CategoryTheory</span>.<span class="name">skeletonEquivalence</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">CategoryTheory.Skeleton</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span></span></div></div><p>The equivalence between the skeleton and the category itself.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.skeletonEquivalence">CategoryTheory.skeletonEquivalence</a> <span class="fn">C</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence">CategoryTheory.Functor.asEquivalence</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton">CategoryTheory.fromSkeleton</a> <span class="fn">C</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.skeletonEquivalence" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.skeleton_skeletal"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L111-L114">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.skeleton_skeletal"><span class="name">CategoryTheory</span>.<span class="name">skeleton_skeletal</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeletal">CategoryTheory.Skeletal</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">CategoryTheory.Skeleton</a> <span class="fn">C</span></span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.skeletonIsSkeleton"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L118-L120">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.skeletonIsSkeleton"><span class="name">CategoryTheory</span>.<span class="name">skeletonIsSkeleton</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.IsSkeletonOf">CategoryTheory.IsSkeletonOf</a> <span class="fn">C</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">CategoryTheory.Skeleton</a> <span class="fn">C</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton">CategoryTheory.fromSkeleton</a> <span class="fn">C</span></span>)</span></span></div></div><p>The <code>skeleton</code> of <code>C</code> given by choice is a skeleton of <code>C</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.skeletonIsSkeleton">CategoryTheory.skeletonIsSkeleton</a> <span class="fn">C</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">skel</span> := <span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeletal">CategoryTheory.Skeletal</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">CategoryTheory.Skeleton</a> <span class="fn">C</span></span>)</span></span>)</span>,
    <span class="fn">eqv</span> := <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.fromSkeleton.isEquivalence">CategoryTheory.fromSkeleton.isEquivalence</a> <span class="fn">C</span></span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.skeletonIsSkeleton" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.skeletonEquiv"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L129-L134">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Equivalence.skeletonEquiv"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">skeletonEquiv</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">CategoryTheory.Skeleton</a> <span class="fn">C</span></span> <a href="../.././Mathlib/Logic/Equiv/Defs.html#Equiv">≃</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeleton">CategoryTheory.Skeleton</a> <span class="fn">D</span></span></span></div></div><p>Two categories which are categorically equivalent have skeletons with equivalent objects.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.skeletonEquiv" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.ThinSkeleton"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L143-L144">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a> u₁</div></div><p>Construct the skeleton category by taking the quotient of objects. This construction gives a
preorder with nice definitional properties, but is only really appropriate for thin categories.
If your original category is not thin, you probably want to be using <code>skeleton</code> instead of this.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">C</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Core.html#Quotient">Quotient</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/IsomorphismClasses.html#CategoryTheory.isIsomorphicSetoid">CategoryTheory.isIsomorphicSetoid</a> <span class="fn">C</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.ThinSkeleton" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.inhabitedThinSkeleton"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L147-L148">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.inhabitedThinSkeleton"><span class="name">CategoryTheory</span>.<span class="name">inhabitedThinSkeleton</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.inhabitedThinSkeleton">CategoryTheory.inhabitedThinSkeleton</a> <span class="fn">C</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn"><a href="../.././Init/Core.html#Quotient.mk'">Quotient.mk'</a> <span class="fn">default</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.preorder"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L151-L165">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.preorder"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">preorder</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Init/Order/Defs.html#Preorder">Preorder</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.preorder">CategoryTheory.ThinSkeleton.preorder</a> <span class="fn">C</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/Init/Order/Defs.html#Preorder.mk">Preorder.mk</a> <span class="fn">(_ : <span class="fn">∀ (<span class="fn">q</span> : <span class="fn"><a href="../.././Init/Core.html#Quotient">Quotient</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/IsomorphismClasses.html#CategoryTheory.isIsomorphicSetoid">CategoryTheory.isIsomorphicSetoid</a> <span class="fn">C</span></span>)</span></span>), <span class="fn"><span class="fn">q</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">q</span></span></span>)</span>
    <span class="fn">(_ : <span class="fn">∀ (<span class="fn">a </span>b c : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">C</span></span>), <span class="fn"><span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">b</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span></span> → <span class="fn"><span class="fn">a</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">c</span></span></span></span></span>)</span></span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.toThinSkeleton_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L169-L169">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toThinSkeleton_obj"><span class="name">CategoryTheory</span>.<span class="name">toThinSkeleton_obj</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toThinSkeleton">CategoryTheory.toThinSkeleton</a> <span class="fn">C</span></span>)</span>.obj <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Init/Core.html#Quotient.mk'">Quotient.mk'</a> <span class="fn">a</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.toThinSkeleton_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L169-L169">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toThinSkeleton_map"><span class="name">CategoryTheory</span>.<span class="name">toThinSkeleton_map</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X </span>Y : <span class="fn">C</span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>), <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toThinSkeleton">CategoryTheory.toThinSkeleton</a> <span class="fn">C</span></span>)</span>.map <span class="fn">f</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.homOfLE">CategoryTheory.homOfLE</a> <span class="fn">(_ : <span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>)</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.toThinSkeleton"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L170-L172">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toThinSkeleton"><span class="name">CategoryTheory</span>.<span class="name">toThinSkeleton</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">C</span></span>)</span></span></div></div><p>The functor from a category to its thin skeleton.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toThinSkeleton">CategoryTheory.toThinSkeleton</a> <span class="fn">C</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.mk">CategoryTheory.Functor.mk</a>
    <span class="fn">{ <span class="fn">obj</span> := <span class="fn">Quotient.mk'</span>, <span class="fn">map</span> := <span class="fn">fun {<span class="fn">X </span>Y : <span class="fn">C</span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>) =&gt; <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.homOfLE">CategoryTheory.homOfLE</a> <span class="fn">(_ : <span class="fn"><a href="../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>)</span></span></span> }</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.toThinSkeleton" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><p>The constructions here are intended to be used when the category <code>C</code> is thin, even though
some of the statements can be shown without this assumption.</p></div><div class="decl" id="CategoryTheory.ThinSkeleton.thin"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L184-L187">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.thin"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">thin</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">C</span></span>)</span></span></div></div><p>The thin skeleton is thin.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<span class="fn"><span class="fn">x✝</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">x</span></span>)</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">(_ : <span class="fn"><a href="../.././Init/Core.html#Subsingleton">Subsingleton</a> <span class="fn">(<span class="fn"><span class="fn">x✝</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">x</span></span>)</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.map_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L193-L193">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map_map"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ (<span class="fn">a</span> : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>),
  <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">CategoryTheory.ThinSkeleton.map</a> <span class="fn">F</span></span>)</span>.map <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../.././Init/Core.html#Quotient.recOnSubsingleton₂">Quotient.recOnSubsingleton₂</a> (motive := <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">C</span></span>) =&gt;
      <span class="fn"><span class="fn">(<span class="fn"><span class="fn">x</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">x_1</span></span>)</span> →
        <span class="fn">(<span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Quot.html#Quotient.map">Quotient.map</a> <span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">(_ : <span class="fn">∀ (<span class="fn">X₁ </span>X₂ : <span class="fn">C</span>), <span class="fn"><span class="fn"><span class="fn">X₁</span> <a href="../.././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">X₂</span></span> → <span class="fn"><span class="fn">(<span class="fn">fun (<span class="fn">x</span> x_2 : <span class="fn">D</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">x_2</span></span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">F</span>.obj <span class="fn">X₁</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">F</span>.obj <span class="fn">X₂</span></span>)</span></span></span></span>)</span> <span class="fn">x</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a>           <span class="fn"><a href="../.././Mathlib/Data/Quot.html#Quotient.map">Quotient.map</a> <span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">(_ : <span class="fn">∀ (<span class="fn">X₁ </span>X₂ : <span class="fn">C</span>), <span class="fn"><span class="fn"><span class="fn">X₁</span> <a href="../.././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">X₂</span></span> → <span class="fn"><span class="fn">(<span class="fn">fun (<span class="fn">x</span> x_2 : <span class="fn">D</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">x_2</span></span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">F</span>.obj <span class="fn">X₁</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">F</span>.obj <span class="fn">X₂</span></span>)</span></span></span></span>)</span> <span class="fn">x_1</span></span></span>)</span></span></span>)
      <span class="fn">X</span> <span class="fn">Y</span>
      <span class="fn">(<span class="fn">fun (<span class="fn">x</span> y : <span class="fn">C</span>) (<span class="fn">k</span> : <span class="fn"><span class="fn">⟦<span class="fn">x</span>⟧</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">⟦<span class="fn">y</span>⟧</span></span>) =&gt;
        <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.homOfLE">CategoryTheory.homOfLE</a>
          <span class="fn">(_ :
            <span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Quot.html#Quotient.map">Quotient.map</a> <span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">(_ : <span class="fn">∀ (<span class="fn">X₁ </span>X₂ : <span class="fn">C</span>), <span class="fn"><span class="fn"><span class="fn">X₁</span> <a href="../.././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">X₂</span></span> → <span class="fn"><span class="fn">(<span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">D</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">x_1</span></span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">F</span>.obj <span class="fn">X₁</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">F</span>.obj <span class="fn">X₂</span></span>)</span></span></span></span>)</span> <span class="fn">⟦<span class="fn">x</span>⟧</span></span> <a href="../.././Init/Prelude.html#LE.le">≤</a>               <span class="fn"><a href="../.././Mathlib/Data/Quot.html#Quotient.map">Quotient.map</a> <span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">(_ : <span class="fn">∀ (<span class="fn">X₁ </span>X₂ : <span class="fn">C</span>), <span class="fn"><span class="fn"><span class="fn">X₁</span> <a href="../.././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">X₂</span></span> → <span class="fn"><span class="fn">(<span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">D</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">x_1</span></span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">F</span>.obj <span class="fn">X₁</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">F</span>.obj <span class="fn">X₂</span></span>)</span></span></span></span>)</span> <span class="fn">⟦<span class="fn">y</span>⟧</span></span></span>)</span></span></span>)</span>
      <span class="fn">a</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.map_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L193-L193">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map_obj"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ (<span class="fn">a</span> : <span class="fn"><a href="../.././Init/Core.html#Quotient">Quotient</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/IsomorphismClasses.html#CategoryTheory.isIsomorphicSetoid">CategoryTheory.isIsomorphicSetoid</a> <span class="fn">C</span></span>)</span></span>),
  <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">CategoryTheory.ThinSkeleton.map</a> <span class="fn">F</span></span>)</span>.obj <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../.././Mathlib/Data/Quot.html#Quotient.map">Quotient.map</a> <span class="fn"><span class="fn">F</span>.obj</span> <span class="fn">(_ : <span class="fn">∀ (<span class="fn">X₁ </span>X₂ : <span class="fn">C</span>), <span class="fn"><span class="fn"><span class="fn">X₁</span> <a href="../.././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">X₂</span></span> → <span class="fn"><span class="fn">(<span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn">D</span>) =&gt; <span class="fn"><span class="fn">x</span> <a href="../.././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">x_1</span></span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">F</span>.obj <span class="fn">X₁</span></span>)</span> <span class="fn">(<span class="fn"><span class="fn">F</span>.obj <span class="fn">X₂</span></span>)</span></span></span></span>)</span> <span class="fn">a</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L194-L196">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">C</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">D</span></span>)</span></span></div></div><p>A functor <code>C ⥤ D</code> computably lowers to a functor <code><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> C ⥤ <a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> D</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.ThinSkeleton.map" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.comp_toThinSkeleton"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L199-L200">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.comp_toThinSkeleton"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">comp_toThinSkeleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">F</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toThinSkeleton">CategoryTheory.toThinSkeleton</a> <span class="fn">D</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toThinSkeleton">CategoryTheory.toThinSkeleton</a> <span class="fn">C</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">CategoryTheory.ThinSkeleton.map</a> <span class="fn">F</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.mapNatTrans"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L204-L205">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.mapNatTrans"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">mapNatTrans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F₁ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F₂ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(k : <span class="fn"><span class="fn">F₁</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">F₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">CategoryTheory.ThinSkeleton.map</a> <span class="fn">F₁</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">CategoryTheory.ThinSkeleton.map</a> <span class="fn">F₂</span></span></span></div></div><p>Given a natural transformation <code>F₁ ⟶ F₂</code>, induce a natural transformation <code><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">map</a> F₁ ⟶ <a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">map</a> F₂</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.ThinSkeleton.mapNatTrans" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.map₂ObjMap"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L220-L224">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map₂ObjMap"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map₂ObjMap</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">C</span></span> → <span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">D</span></span> → <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">E</span></span></span></span></div></div><p>Given a bifunctor, we descend to a function on objects of <code><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a></code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.ThinSkeleton.map₂ObjMap" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.map₂Functor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L227-L233">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map₂Functor"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map₂Functor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">C</span></span> → <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">D</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">E</span></span>)</span></span></span></div></div><p>For each <code>x : <a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> C</code>, we promote <code><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map₂ObjMap">map₂ObjMap</a> F x</code> to a functor</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.ThinSkeleton.map₂Functor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.map₂NatTrans"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L237-L242">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map₂NatTrans"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map₂NatTrans</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{x₁ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x₂ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">(<span class="fn"><span class="fn">x₁</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">x₂</span></span>)</span> → <span class="fn">(<span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map₂Functor">CategoryTheory.ThinSkeleton.map₂Functor</a> <span class="fn">F</span> <span class="fn">x₁</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map₂Functor">CategoryTheory.ThinSkeleton.map₂Functor</a> <span class="fn">F</span> <span class="fn">x₂</span></span></span>)</span></span></div></div><p>This provides natural transformations <code><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map₂Functor">map₂Functor</a> F x₁ ⟶ <a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map₂Functor">map₂Functor</a> F x₂</code> given
<code>x₁ ⟶ x₂</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.ThinSkeleton.map₂NatTrans" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.map₂_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L247-L247">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map₂_obj"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map₂_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ (<span class="fn">a</span> : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">C</span></span>),
  <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map₂">CategoryTheory.ThinSkeleton.map₂</a> <span class="fn">F</span></span>)</span>.obj <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map₂Functor">CategoryTheory.ThinSkeleton.map₂Functor</a> <span class="fn">F</span> <span class="fn">a</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.map₂_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L247-L247">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map₂_map"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map₂_map</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ {<span class="fn">X </span>Y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">C</span></span>} (<span class="fn">a</span> : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>),
  <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map₂">CategoryTheory.ThinSkeleton.map₂</a> <span class="fn">F</span></span>)</span>.map <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map₂NatTrans">CategoryTheory.ThinSkeleton.map₂NatTrans</a> <span class="fn">F</span> <span class="fn">a</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.map₂"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L248-L250">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map₂"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map₂</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">E</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">C</span></span>)</span>
  <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">D</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">E</span></span>)</span></span>)</span></span></div></div><p>A functor <code>C ⥤ D ⥤ E</code> computably lowers to a functor
<code><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> C ⥤ <a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> D ⥤ <a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> E</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.ThinSkeleton.map₂" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.toThinSkeleton_faithful"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L259-L259">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.toThinSkeleton_faithful"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">toThinSkeleton_faithful</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Faithful">CategoryTheory.Faithful</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toThinSkeleton">CategoryTheory.toThinSkeleton</a> <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Faithful">CategoryTheory.Faithful</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toThinSkeleton">CategoryTheory.toThinSkeleton</a> <span class="fn">C</span></span>)</span></span>)</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/FullyFaithful.html#CategoryTheory.Faithful">CategoryTheory.Faithful</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.toThinSkeleton">CategoryTheory.toThinSkeleton</a> <span class="fn">C</span></span>)</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.fromThinSkeleton_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L263-L263">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeleton_obj"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">fromThinSkeleton_obj</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ (<span class="fn">a</span> : <span class="fn"><a href="../.././Init/Core.html#Quotient">Quotient</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/IsomorphismClasses.html#CategoryTheory.isIsomorphicSetoid">CategoryTheory.isIsomorphicSetoid</a> <span class="fn">C</span></span>)</span></span>),
  <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeleton">CategoryTheory.ThinSkeleton.fromThinSkeleton</a> <span class="fn">C</span></span>)</span>.obj <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/Data/Quot.html#Quotient.out">Quotient.out</a> <span class="fn">a</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.fromThinSkeleton_map"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L263-L263">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeleton_map"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">fromThinSkeleton_map</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{x : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{y : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">∀ (<span class="fn">a</span> : <span class="fn"><span class="fn">x</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">y</span></span>),
  <span class="fn"><span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeleton">CategoryTheory.ThinSkeleton.fromThinSkeleton</a> <span class="fn">C</span></span>)</span>.map <span class="fn">a</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>     <span class="fn"><a href="../.././Init/Core.html#Quotient.recOnSubsingleton₂">Quotient.recOnSubsingleton₂</a> (motive := <span class="fn">fun (<span class="fn">x</span> x_1 : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">C</span></span>) =&gt;
      <span class="fn"><span class="fn">(<span class="fn"><span class="fn">x</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">x_1</span></span>)</span> → <span class="fn">(<span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Quot.html#Quotient.out">Quotient.out</a> <span class="fn">x</span></span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn"><a href="../.././Mathlib/Data/Quot.html#Quotient.out">Quotient.out</a> <span class="fn">x_1</span></span></span>)</span></span></span>) <span class="fn">x</span> <span class="fn">y</span>
      <span class="fn">(<span class="fn">fun (<span class="fn">X</span> Y : <span class="fn">C</span>) (<span class="fn">f</span> : <span class="fn"><span class="fn">⟦<span class="fn">X</span>⟧</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">⟦<span class="fn">Y</span>⟧</span></span>) =&gt;
        <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/Logic/Nonempty.html#Nonempty.some">Nonempty.some</a> <span class="fn">(_ : <span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Quot.html#Quotient.out">Quotient.out</a> <span class="fn">⟦<span class="fn">X</span>⟧</span></span> <a href="../.././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">X</span></span>)</span></span>)</span>.hom</span>
          <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/Logic/Nonempty.html#Nonempty.some">Nonempty.some</a> <span class="fn">(_ : <span class="fn"><span class="fn">⟦<span class="fn">X</span>⟧</span> <a href="../.././Init/Prelude.html#LE.le">≤</a> <span class="fn">⟦<span class="fn">Y</span>⟧</span></span>)</span></span>)</span>
            <span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/Logic/Nonempty.html#Nonempty.some">Nonempty.some</a> <span class="fn">(_ : <span class="fn"><span class="fn"><a href="../.././Mathlib/Data/Quot.html#Quotient.out">Quotient.out</a> <span class="fn">⟦<span class="fn">Y</span>⟧</span></span> <a href="../.././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">Y</span></span>)</span></span>)</span>.inv</span></span>)</span></span></span>)</span>
      <span class="fn">a</span></span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.fromThinSkeleton"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L264-L268">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeleton"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">fromThinSkeleton</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">C</span></span>)</span> <span class="fn">C</span></span></div></div><p>Use <code><a href="../.././Mathlib/Data/Quot.html#Quotient.out">Quotient.out</a></code> to create a functor out of the thin skeleton.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.ThinSkeleton.fromThinSkeleton" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.fromThinSkeletonEquivalence"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L271-L275">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeletonEquivalence"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">fromThinSkeletonEquivalence</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.IsEquivalence">CategoryTheory.IsEquivalence</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeleton">CategoryTheory.ThinSkeleton.fromThinSkeleton</a> <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.equivalence"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L279-L280">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.equivalence"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">equivalence</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../.././foundational_types.html">Type</a> u₁)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">C</span></span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">C</span></span></div></div><p>The equivalence between the thin skeleton and the category itself.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.equivalence">CategoryTheory.ThinSkeleton.equivalence</a> <span class="fn">C</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Functor.asEquivalence">CategoryTheory.Functor.asEquivalence</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeleton">CategoryTheory.ThinSkeleton.fromThinSkeleton</a> <span class="fn">C</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.ThinSkeleton.equivalence" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.equiv_of_both_ways"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L285-L286">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.equiv_of_both_ways"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">equiv_of_both_ways</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Y : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">Y</span> <a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">X</span> <a href="../.././Init/Core.html#HasEquiv.Equiv">≈</a> <span class="fn">Y</span></span></div></div></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.thinSkeletonPartialOrder"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L289-L295">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.thinSkeletonPartialOrder"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">thinSkeletonPartialOrder</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/Init/Order/Defs.html#PartialOrder">PartialOrder</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">C</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.skeletal"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L298-L299">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.skeletal"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">skeletal</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeletal">CategoryTheory.Skeletal</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">C</span></span>)</span></span></div></div></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.map_comp_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L302-L304">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map_comp_eq"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map_comp_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{E : <a href="../.././foundational_types.html">Type</a> u₃}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₃, u₃}</a>     <span class="fn">E</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">E</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(G : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">CategoryTheory.ThinSkeleton.map</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">F</span> <span class="fn">G</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp">CategoryTheory.Functor.comp</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">CategoryTheory.ThinSkeleton.map</a> <span class="fn">F</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">CategoryTheory.ThinSkeleton.map</a> <span class="fn">G</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.map_id_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L307-L309">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map_id_eq"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map_id_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">CategoryTheory.ThinSkeleton.map</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">C</span></span>)</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.id">CategoryTheory.Functor.id</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">C</span></span>)</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.map_iso_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L312-L315">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map_iso_eq"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">map_iso_eq</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F₁ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F₂ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">F₁</span> <a href="../.././Mathlib/CategoryTheory/Iso.html#CategoryTheory.Iso">≅</a> <span class="fn">F₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">CategoryTheory.ThinSkeleton.map</a> <span class="fn">F₁</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">CategoryTheory.ThinSkeleton.map</a> <span class="fn">F₂</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.thinSkeletonIsSkeleton"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L319-L322">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.thinSkeletonIsSkeleton"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">thinSkeletonIsSkeleton</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.IsSkeletonOf">CategoryTheory.IsSkeletonOf</a> <span class="fn">C</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">C</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeleton">CategoryTheory.ThinSkeleton.fromThinSkeleton</a> <span class="fn">C</span></span>)</span></span></div></div><p><code><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeleton">fromThinSkeleton</a> C</code> exhibits the thin skeleton as a skeleton.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">CategoryTheory.ThinSkeleton.thinSkeletonIsSkeleton</span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">skel</span> := <span class="fn">(_ : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Skeletal">CategoryTheory.Skeletal</a> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">C</span></span>)</span></span>)</span>,
    <span class="fn">eqv</span> := <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeletonEquivalence">CategoryTheory.ThinSkeleton.fromThinSkeletonEquivalence</a> <span class="fn">C</span></span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.ThinSkeleton.thinSkeletonIsSkeleton" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.isSkeletonOfInhabited"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L325-L327">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable instance</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.isSkeletonOfInhabited"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">isSkeletonOfInhabited</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Inhabited">Inhabited</a>
  <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.IsSkeletonOf">CategoryTheory.IsSkeletonOf</a> <span class="fn">C</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">C</span></span>)</span> <span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.fromThinSkeleton">CategoryTheory.ThinSkeleton.fromThinSkeleton</a> <span class="fn">C</span></span>)</span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">CategoryTheory.ThinSkeleton.isSkeletonOfInhabited</span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">CategoryTheory.ThinSkeleton.thinSkeletonIsSkeleton</span> }</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.ThinSkeleton.lowerAdjunction"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L335-L347">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.lowerAdjunction"><span class="name">CategoryTheory</span>.<span class="name">ThinSkeleton</span>.<span class="name">lowerAdjunction</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{D : <a href="../.././foundational_types.html">Type</a> u₂}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₂, u₂}</a>     <span class="fn">D</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(R : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">D</span> <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(L : <span class="fn"><a href="../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <span class="fn">D</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">L</span> <a href="../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Adjunction">⊣</a> <span class="fn">R</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">CategoryTheory.ThinSkeleton.map</a> <span class="fn">L</span></span> <a href="../.././Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Adjunction">⊣</a> <span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.map">CategoryTheory.ThinSkeleton.map</a> <span class="fn">R</span></span></span></div></div><p>An adjunction between thin categories gives an adjunction between their thin skeletons.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.ThinSkeleton.lowerAdjunction" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.Equivalence.thinSkeletonOrderIso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Skeletal.lean#L362-L364">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Equivalence.thinSkeletonOrderIso"><span class="name">CategoryTheory</span>.<span class="name">Equivalence</span>.<span class="name">thinSkeletonOrderIso</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../.././foundational_types.html">Type</a> u₁}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v₁, u₁}</a>     <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../.././foundational_types.html">Type</a> u_1}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Init/Order/Defs.html#PartialOrder">PartialOrder</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.IsThin">Quiver.IsThin</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn">C</span> <a href="../.././Mathlib/CategoryTheory/Equivalence.html#CategoryTheory.Equivalence">≌</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">CategoryTheory.ThinSkeleton</a> <span class="fn">C</span></span> <a href="../.././Mathlib/Order/Hom/Basic.html#OrderIso">≃o</a> <span class="fn">α</span></span></div></div><p>When <code>e : C ≌ α</code> is a categorical equivalence from a thin category <code>C</code> to some partial order <code>α</code>,
the <code><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton">ThinSkeleton</a> C</code> is order isomorphic to <code>α</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.Equivalence.thinSkeletonOrderIso">CategoryTheory.Equivalence.thinSkeletonOrderIso</a> <span class="fn">e</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Mathlib/CategoryTheory/Category/Preorder.html#CategoryTheory.Equivalence.toOrderIso">CategoryTheory.Equivalence.toOrderIso</a> <span class="fn">(<span class="fn"><span class="fn">(<span class="fn"><a href="../.././Mathlib/CategoryTheory/Skeletal.html#CategoryTheory.ThinSkeleton.equivalence">CategoryTheory.ThinSkeleton.equivalence</a> <span class="fn">C</span></span>)</span>.trans <span class="fn">e</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-CategoryTheory.Equivalence.thinSkeletonOrderIso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>