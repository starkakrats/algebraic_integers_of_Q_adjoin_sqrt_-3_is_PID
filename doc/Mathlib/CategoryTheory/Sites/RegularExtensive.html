<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="stylesheet" href="../../.././src/pygments.css"></link><link rel="shortcut icon" href="../../.././favicon.ico"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Mathlib.CategoryTheory.Sites.RegularExtensive</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Mathlib.CategoryTheory.Sites.RegularExtensive";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Mathlib</span>.<span class="name">CategoryTheory</span>.<span class="name">Sites</span>.<span class="name">RegularExtensive</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;
            <button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/RegularExtensive.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init.html">Init</a></li><li><a href="../../.././Mathlib/CategoryTheory/Extensive.html">Mathlib.CategoryTheory.Extensive</a></li><li><a href="../../.././Mathlib/CategoryTheory/Preadditive/Projective.html">Mathlib.CategoryTheory.Preadditive.Projective</a></li><li><a href="../../.././Mathlib/CategoryTheory/Sites/Coherent.html">Mathlib.CategoryTheory.Sites.Coherent</a></li><li><a href="../../.././Mathlib/CategoryTheory/Sites/Preserves.html">Mathlib.CategoryTheory.Sites.Preserves</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Mathlib.CategoryTheory.Sites.RegularExtensive" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Preregular"><span class="name">CategoryTheory</span>.<span class="name">Preregular</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instPreregular"><span class="name">CategoryTheory</span>.<span class="name">instPreregular</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.regularCoverage"><span class="name">CategoryTheory</span>.<span class="name">regularCoverage</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.extensiveCoverage"><span class="name">CategoryTheory</span>.<span class="name">extensiveCoverage</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.effectiveEpi_desc_iff_effectiveEpiFamily"><span class="name">CategoryTheory</span>.<span class="name">effectiveEpi_desc_iff_effectiveEpiFamily</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instPrecoherent"><span class="name">CategoryTheory</span>.<span class="name">instPrecoherent</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.extensive_regular_generate_coherent"><span class="name">CategoryTheory</span>.<span class="name">extensive_regular_generate_coherent</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presieve.regular"><span class="name">CategoryTheory</span>.<span class="name">Presieve</span>.<span class="name">regular</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.regularCoverage.MapToEqualizer"><span class="name">CategoryTheory</span>.<span class="name">regularCoverage</span>.<span class="name">MapToEqualizer</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.regularCoverage.EqualizerCondition"><span class="name">CategoryTheory</span>.<span class="name">regularCoverage</span>.<span class="name">EqualizerCondition</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.regularCoverage.EqualizerCondition.isSheafFor"><span class="name">CategoryTheory</span>.<span class="name">regularCoverage</span>.<span class="name">EqualizerCondition</span>.<span class="name">isSheafFor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.regularCoverage.equalizerCondition_of_regular"><span class="name">CategoryTheory</span>.<span class="name">regularCoverage</span>.<span class="name">equalizerCondition_of_regular</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.regularCoverage.isSheafFor_regular_of_projective"><span class="name">CategoryTheory</span>.<span class="name">regularCoverage</span>.<span class="name">isSheafFor_regular_of_projective</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.regularCoverage.EqualizerCondition.isSheaf_iff"><span class="name">CategoryTheory</span>.<span class="name">regularCoverage</span>.<span class="name">EqualizerCondition</span>.<span class="name">isSheaf_iff</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.regularCoverage.isSheaf_of_projective"><span class="name">CategoryTheory</span>.<span class="name">regularCoverage</span>.<span class="name">isSheaf_of_projective</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.regularCoverage.isSheaf_yoneda_obj"><span class="name">CategoryTheory</span>.<span class="name">regularCoverage</span>.<span class="name">isSheaf_yoneda_obj</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.regularCoverage.subcanonical"><span class="name">CategoryTheory</span>.<span class="name">regularCoverage</span>.<span class="name">subcanonical</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.Presieve.extensive"><span class="name">CategoryTheory</span>.<span class="name">Presieve</span>.<span class="name">extensive</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instHasPullbacks"><span class="name">CategoryTheory</span>.<span class="name">instHasPullbacks</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instPreservesLimitTypeTypesDiscreteDiscreteCategoryFunctor"><span class="name">CategoryTheory</span>.<span class="name">instPreservesLimitTypeTypesDiscreteDiscreteCategoryFunctor</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isSheafFor_extensive_of_preservesFiniteProducts"><span class="name">CategoryTheory</span>.<span class="name">isSheafFor_extensive_of_preservesFiniteProducts</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.instExtensiveSigmaObjHasColimitOfHasColimitsOfShapeDiscreteDiscreteCategoryHasColimitsOfShape_discreteHasFiniteCoproductsOf_fintypeFunctorOfArrowsι"><span class="name">CategoryTheory</span>.<span class="name">instExtensiveSigmaObjHasColimitOfHasColimitsOfShapeDiscreteDiscreteCategoryHasColimitsOfShape_discreteHasFiniteCoproductsOf_fintypeFunctorOfArrowsι</span></a></div><div class="nav_link"><a class="break_within" href="#CategoryTheory.isSheaf_iff_preservesFiniteProducts"><span class="name">CategoryTheory</span>.<span class="name">isSheaf_iff_preservesFiniteProducts</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="The-Regular-and-Extensive-Coverages">The Regular and Extensive Coverages <a class="hover-link" href="#The-Regular-and-Extensive-Coverages">#</a></h1><p>This file defines two coverages on a category <code>C</code>.</p><p>The first one is called the <em>regular</em> coverage and for that to exist, the category <code>C</code> must satisfy
a condition called <code><a href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.Preregular">Preregular</a> C</code>. This means that effective epimorphisms can be "pulled back". The
covering sieves of this coverage are generated by presieves consisting of a single effective
epimorphism.</p><p>The second one is called the <em>extensive</em> coverage and for that to exist, the category <code>C</code> must
satisfy a condition called <code>FinitaryPreExtensive C</code>. This means <code>C</code> has finite coproducts and that
those are preserved by pullbacks. The covering sieves of this coverage are generated by presieves
consisting finitely many arrows that together induce an isomorphism from the coproduct to the
target. This condition is weaker than <code>FinitaryExtensive</code>, where in addition finite coproducts are
disjoint.</p><h2 class="markdown-heading" id="Main-results">Main results <a class="hover-link" href="#Main-results">#</a></h2><ul>
<li>
<p><code>instance : Precoherent C</code> given <code><a href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.Preregular">Preregular</a> C</code> and <code>FinitaryPreExtensive C</code>.</p>
</li>
<li>
<p><code>extensive_union_regular_generates_coherent</code>: the union of the regular and extensive coverages
generates the coherent topology on <code>C</code> if <code>C</code> is precoherent, preextensive and preregular.</p>
</li>
<li>
<p><code>isSheaf_iff_equalizerCondition</code>: In a preregular category with pullbacks, the sheaves for the
regular topology are precisely the presheaves satisfying an equaliser condition with respect to
effective epimorphisms.</p>
</li>
<li>
<p><code><a href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.regularCoverage.isSheaf_of_projective">isSheaf_of_projective</a></code>: In a preregular category in which every object is projective, every
presheaf is a sheaf for the regular topology.</p>
</li>
<li>
<p><code><a href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.isSheaf_iff_preservesFiniteProducts">isSheaf_iff_preservesFiniteProducts</a></code>: In a finitary extensive category, the sheaves for the
extensive topology are precisely those preserving finite products.</p>
</li>
</ul></div><div class="decl" id="CategoryTheory.Preregular"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/RegularExtensive.lean#L61-L75">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.Preregular"><span class="name">CategoryTheory</span>.<span class="name">Preregular</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>The condition <code><a href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.Preregular">Preregular</a> C</code> is property that effective epis can be "pulled back" along any
morphism. This is satisfied e.g. by categories that have pullbacks that preserve effective
epimorphisms (like <code>Profinite</code> and <code>CompHaus</code>), and categories where every object is projective
(like  <code>Stonean</code>).</p><ul class="structure_fields" id="CategoryTheory.Preregular.mk"><li id="CategoryTheory.Preregular.exists_fac" class="structure_field"><div class="structure_field_info">exists_fac : <span class="fn">∀ {<span class="fn">X </span>Y Z : <span class="fn">C</span>} (<span class="fn">f</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>) (<span class="fn">g</span> : <span class="fn"><span class="fn">Z</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>) [<span class="fn">inst</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/EffectiveEpimorphic.html#CategoryTheory.EffectiveEpi">CategoryTheory.EffectiveEpi</a> <span class="fn">g</span></span>],
  <span class="fn">∃ (W : <span class="fn">C</span>) (h : <span class="fn"><span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>) (_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/EffectiveEpimorphic.html#CategoryTheory.EffectiveEpi">CategoryTheory.EffectiveEpi</a> <span class="fn">h</span></span>) (i : <span class="fn"><span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Z</span></span>),
    <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">i</span> <span class="fn">g</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">h</span> <span class="fn">f</span></span></span></span></span></div><div class="structure_field_doc"><p>For <code>X</code>, <code>Y</code>, <code>Z</code>, <code>f</code>, <code>g</code> like in the diagram, where <code>g</code> is an effective epi, there exists
an object <code>W</code>, an effective epi <code>h : W ⟶ X</code> and a morphism <code>i : W ⟶ Z</code> making the diagram
commute.</p><pre><code>W --i-→ Z
|       |
h       g
↓       ↓
X --f-→ Y
</code></pre></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.Preregular" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.instPreregular"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/RegularExtensive.lean#L77-L85">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.instPreregular"><span class="name">CategoryTheory</span>.<span class="name">instPreregular</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Coherent.html#CategoryTheory.Precoherent">CategoryTheory.Precoherent</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/FiniteProducts.html#CategoryTheory.Limits.HasFiniteCoproducts">CategoryTheory.Limits.HasFiniteCoproducts</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.Preregular">CategoryTheory.Preregular</a> <span class="fn">C</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.Preregular">CategoryTheory.Preregular</a> <span class="fn">C</span></span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.Preregular">CategoryTheory.Preregular</a> <span class="fn">C</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.regularCoverage"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/RegularExtensive.lean#L90-L104">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.regularCoverage"><span class="name">CategoryTheory</span>.<span class="name">regularCoverage</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.Preregular">CategoryTheory.Preregular</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Coverage.html#CategoryTheory.Coverage">CategoryTheory.Coverage</a> <span class="fn">C</span></span></div></div><p>The regular coverage on a regular category <code>C</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.regularCoverage" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.extensiveCoverage"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/RegularExtensive.lean#L111-L125">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.extensiveCoverage"><span class="name">CategoryTheory</span>.<span class="name">extensiveCoverage</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Extensive.html#CategoryTheory.FinitaryPreExtensive">CategoryTheory.FinitaryPreExtensive</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Coverage.html#CategoryTheory.Coverage">CategoryTheory.Coverage</a> <span class="fn">C</span></span></div></div><p>The extensive coverage on an extensive category <code>C</code></p><p>TODO: use general colimit API instead of <code>IsIso (Sigma.desc π)</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.extensiveCoverage" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.effectiveEpi_desc_iff_effectiveEpiFamily"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/RegularExtensive.lean#L127-L132">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.effectiveEpi_desc_iff_effectiveEpiFamily"><span class="name">CategoryTheory</span>.<span class="name">effectiveEpi_desc_iff_effectiveEpiFamily</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Extensive.html#CategoryTheory.FinitaryPreExtensive">CategoryTheory.FinitaryPreExtensive</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Data/Fintype/Basic.html#Fintype">Fintype</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(X : <span class="fn"><span class="fn">α</span> → <span class="fn">C</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(π : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">X</span> <span class="fn">a</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/EffectiveEpimorphic.html#CategoryTheory.EffectiveEpi">CategoryTheory.EffectiveEpi</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Sigma.desc">CategoryTheory.Limits.Sigma.desc</a> <span class="fn">π</span></span>)</span></span> <a href="../../.././Init/Core.html#Iff">↔</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/EffectiveEpimorphic.html#CategoryTheory.EffectiveEpiFamily">CategoryTheory.EffectiveEpiFamily</a> <span class="fn">X</span> <span class="fn">π</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.instPrecoherent"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/RegularExtensive.lean#L134-L149">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.instPrecoherent"><span class="name">CategoryTheory</span>.<span class="name">instPrecoherent</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Extensive.html#CategoryTheory.FinitaryPreExtensive">CategoryTheory.FinitaryPreExtensive</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.Preregular">CategoryTheory.Preregular</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Coherent.html#CategoryTheory.Precoherent">CategoryTheory.Precoherent</a> <span class="fn">C</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Coherent.html#CategoryTheory.Precoherent">CategoryTheory.Precoherent</a> <span class="fn">C</span></span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Coherent.html#CategoryTheory.Precoherent">CategoryTheory.Precoherent</a> <span class="fn">C</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.extensive_regular_generate_coherent"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/RegularExtensive.lean#L152-L211">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.extensive_regular_generate_coherent"><span class="name">CategoryTheory</span>.<span class="name">extensive_regular_generate_coherent</span></a></span><span class="decl_args">
<span class="fn">(C : <a href="../../.././foundational_types.html">Type</a> u)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.Preregular">CategoryTheory.Preregular</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Extensive.html#CategoryTheory.FinitaryPreExtensive">CategoryTheory.FinitaryPreExtensive</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Coverage.html#CategoryTheory.Coverage.toGrothendieck">CategoryTheory.Coverage.toGrothendieck</a> <span class="fn">C</span> <span class="fn">(<span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.extensiveCoverage">CategoryTheory.extensiveCoverage</a> <span class="fn">C</span></span> <a href="../../.././Mathlib/Order/Notation.html#Sup.sup">⊔</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.regularCoverage">CategoryTheory.regularCoverage</a> <span class="fn">C</span></span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Coherent.html#CategoryTheory.coherentTopology">CategoryTheory.coherentTopology</a> <span class="fn">C</span></span></span></div></div><p>The union of the extensive and regular coverages generates the coherent topology on <code>C</code>.</p></div></div><div class="decl" id="CategoryTheory.Presieve.regular"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/RegularExtensive.lean#L220-L223">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.Presieve.regular"><span class="name">CategoryTheory</span>.<span class="name">Presieve</span>.<span class="name">regular</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(R : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve">CategoryTheory.Presieve</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A presieve is <em>regular</em> if it consists of a single effective epimorphism.</p><ul class="structure_fields" id="CategoryTheory.Presieve.regular.mk"><li id="CategoryTheory.Presieve.regular.single_epi" class="structure_field"><div class="structure_field_info">single_epi : <span class="fn">∃ (Y : <span class="fn">C</span>) (f : <span class="fn"><span class="fn">Y</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>),
  <span class="fn"><span class="fn">(<span class="fn"><span class="fn">R</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.ofArrows">CategoryTheory.Presieve.ofArrows</a> <span class="fn">(<span class="fn">fun (<span class="fn">x</span> : <a href="../../.././Init/Prelude.html#Unit">Unit</a>) =&gt; <span class="fn">Y</span></span>)</span> <span class="fn">fun (<span class="fn">x</span> : <a href="../../.././Init/Prelude.html#Unit">Unit</a>) =&gt; <span class="fn">f</span></span></span></span>)</span> <a href="../../.././Init/Prelude.html#And">∧</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/EffectiveEpimorphic.html#CategoryTheory.EffectiveEpi">CategoryTheory.EffectiveEpi</a> <span class="fn">f</span></span></span></span></div><div class="structure_field_doc"><p><code>R</code> consists of a single epimorphism.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.Presieve.regular" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.regularCoverage.MapToEqualizer"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/RegularExtensive.lean#L230-L233">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.regularCoverage.MapToEqualizer"><span class="name">CategoryTheory</span>.<span class="name">regularCoverage</span>.<span class="name">MapToEqualizer</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(P : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <a href="../../.././foundational_types.html">(<a href="../../.././foundational_types.html">Type</a> u_1)</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{W : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">B</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g₁ : <span class="fn"><span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g₂ : <span class="fn"><span class="fn">W</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(w : <span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g₁</span> <span class="fn">f</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp">CategoryTheory.CategoryStruct.comp</a> <span class="fn">g₂</span> <span class="fn">f</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">P</span>.obj <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">B</span></span>)</span></span> → <span class="fn">↑<span class="fn">{<span class="fn">x</span> : <span class="fn"><span class="fn">P</span>.obj <span class="fn">(<span class="fn"><a href="../../.././Mathlib/Data/Opposite.html#Opposite.op">Opposite.op</a> <span class="fn">X</span></span>)</span></span> | <span class="fn"><span class="fn"><span class="fn">P</span>.map <span class="fn"><span class="fn">g₁</span>.op</span> <span class="fn">x</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">P</span>.map <span class="fn"><span class="fn">g₂</span>.op</span> <span class="fn">x</span></span></span>}</span></span></span></div></div><p>The map to the explicit equalizer used in the sheaf condition.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.regularCoverage.MapToEqualizer">CategoryTheory.regularCoverage.MapToEqualizer</a> <span class="fn">P</span> <span class="fn">f</span> <span class="fn">g₁</span> <span class="fn">g₂</span> <span class="fn">w</span> <span class="fn">t</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">val</span> := <span class="fn"><span class="fn">P</span>.map <span class="fn"><span class="fn">f</span>.op</span> <span class="fn">t</span></span>, <span class="fn">property</span> := <span class="fn">(_ : <span class="fn"><span class="fn"><span class="fn">P</span>.map <span class="fn"><span class="fn">g₁</span>.op</span> <span class="fn">(<span class="fn"><span class="fn">P</span>.map <span class="fn"><span class="fn">f</span>.op</span> <span class="fn">t</span></span>)</span></span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">P</span>.map <span class="fn"><span class="fn">g₂</span>.op</span> <span class="fn">(<span class="fn"><span class="fn">P</span>.map <span class="fn"><span class="fn">f</span>.op</span> <span class="fn">t</span></span>)</span></span></span>)</span> }</span></span></li></ul></details><details id="instances-for-list-CategoryTheory.regularCoverage.MapToEqualizer" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.regularCoverage.EqualizerCondition"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/RegularExtensive.lean#L238-L241">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.regularCoverage.EqualizerCondition"><span class="name">CategoryTheory</span>.<span class="name">regularCoverage</span>.<span class="name">EqualizerCondition</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(P : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <a href="../../.././foundational_types.html">(<a href="../../.././foundational_types.html">Type</a> u_1)</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>The sheaf condition with respect to regular presieves, given the existence of the relavant pullback.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-CategoryTheory.regularCoverage.EqualizerCondition" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="CategoryTheory.regularCoverage.EqualizerCondition.isSheafFor"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/RegularExtensive.lean#L243-L257">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.regularCoverage.EqualizerCondition.isSheafFor"><span class="name">CategoryTheory</span>.<span class="name">regularCoverage</span>.<span class="name">EqualizerCondition</span>.<span class="name">isSheafFor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{B : <span class="fn">C</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{S : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve">CategoryTheory.Presieve</a> <span class="fn">B</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.Presieve.regular">CategoryTheory.Presieve.regular</a> <span class="fn">S</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.hasPullbacks">CategoryTheory.Presieve.hasPullbacks</a> <span class="fn">S</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <a href="../../.././foundational_types.html">(<a href="../../.././foundational_types.html">Type</a> u_1)</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hF : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.regularCoverage.EqualizerCondition">CategoryTheory.regularCoverage.EqualizerCondition</a> <span class="fn">F</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.IsSheafFor">CategoryTheory.Presieve.IsSheafFor</a> <span class="fn">F</span> <span class="fn">S</span></span></div></div></div></div><div class="decl" id="CategoryTheory.regularCoverage.equalizerCondition_of_regular"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/RegularExtensive.lean#L259-L273">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.regularCoverage.equalizerCondition_of_regular"><span class="name">CategoryTheory</span>.<span class="name">regularCoverage</span>.<span class="name">equalizerCondition_of_regular</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <a href="../../.././foundational_types.html">(<a href="../../.././foundational_types.html">Type</a> u_1)</a></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(hSF : <span class="fn">∀ {<span class="fn">B</span> : <span class="fn">C</span>} (<span class="fn">S</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve">CategoryTheory.Presieve</a> <span class="fn">B</span></span>) [<span class="fn">inst</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.Presieve.regular">CategoryTheory.Presieve.regular</a> <span class="fn">S</span></span>]
  [<span class="fn">inst</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.hasPullbacks">CategoryTheory.Presieve.hasPullbacks</a> <span class="fn">S</span></span>], <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.IsSheafFor">CategoryTheory.Presieve.IsSheafFor</a> <span class="fn">F</span> <span class="fn">S</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.regularCoverage.EqualizerCondition">CategoryTheory.regularCoverage.EqualizerCondition</a> <span class="fn">F</span></span></div></div></div></div><div class="decl" id="CategoryTheory.regularCoverage.isSheafFor_regular_of_projective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/RegularExtensive.lean#L275-L282">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.regularCoverage.isSheafFor_regular_of_projective"><span class="name">CategoryTheory</span>.<span class="name">regularCoverage</span>.<span class="name">isSheafFor_regular_of_projective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(S : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve">CategoryTheory.Presieve</a> <span class="fn">X</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.Presieve.regular">CategoryTheory.Presieve.regular</a> <span class="fn">S</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Preadditive/Projective.html#CategoryTheory.Projective">CategoryTheory.Projective</a> <span class="fn">X</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <a href="../../.././foundational_types.html">(<a href="../../.././foundational_types.html">Type</a> u_1)</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.IsSheafFor">CategoryTheory.Presieve.IsSheafFor</a> <span class="fn">F</span> <span class="fn">S</span></span></div></div></div></div><div class="decl" id="CategoryTheory.regularCoverage.EqualizerCondition.isSheaf_iff"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/RegularExtensive.lean#L284-L290">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.regularCoverage.EqualizerCondition.isSheaf_iff"><span class="name">CategoryTheory</span>.<span class="name">regularCoverage</span>.<span class="name">EqualizerCondition</span>.<span class="name">isSheaf_iff</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <a href="../../.././foundational_types.html">(<a href="../../.././foundational_types.html">Type</a> u_1)</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ ⦃<span class="fn">X </span>Y : <span class="fn">C</span>⦄ (<span class="fn">π</span> : <span class="fn"><span class="fn">X</span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">Y</span></span>) [<span class="fn">inst</span> : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/EffectiveEpimorphic.html#CategoryTheory.EffectiveEpi">CategoryTheory.EffectiveEpi</a> <span class="fn">π</span></span>], <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.html#CategoryTheory.Limits.HasPullback">CategoryTheory.Limits.HasPullback</a> <span class="fn">π</span> <span class="fn">π</span></span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.Preregular">CategoryTheory.Preregular</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.IsSheaf">CategoryTheory.Presieve.IsSheaf</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Coverage.html#CategoryTheory.Coverage.toGrothendieck">CategoryTheory.Coverage.toGrothendieck</a> <span class="fn">C</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.regularCoverage">CategoryTheory.regularCoverage</a> <span class="fn">C</span></span>)</span></span>)</span> <span class="fn">F</span></span> <a href="../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.regularCoverage.EqualizerCondition">CategoryTheory.regularCoverage.EqualizerCondition</a> <span class="fn">F</span></span></span></div></div></div></div><div class="decl" id="CategoryTheory.regularCoverage.isSheaf_of_projective"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/RegularExtensive.lean#L292-L295">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.regularCoverage.isSheaf_of_projective"><span class="name">CategoryTheory</span>.<span class="name">regularCoverage</span>.<span class="name">isSheaf_of_projective</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <a href="../../.././foundational_types.html">(<a href="../../.././foundational_types.html">Type</a> u_1)</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.Preregular">CategoryTheory.Preregular</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn">∀ (<span class="fn">X</span> : <span class="fn">C</span>), <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Preadditive/Projective.html#CategoryTheory.Projective">CategoryTheory.Projective</a> <span class="fn">X</span></span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.IsSheaf">CategoryTheory.Presieve.IsSheaf</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Coverage.html#CategoryTheory.Coverage.toGrothendieck">CategoryTheory.Coverage.toGrothendieck</a> <span class="fn">C</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.regularCoverage">CategoryTheory.regularCoverage</a> <span class="fn">C</span></span>)</span></span>)</span> <span class="fn">F</span></span></div></div></div></div><div class="decl" id="CategoryTheory.regularCoverage.isSheaf_yoneda_obj"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/RegularExtensive.lean#L298-L316">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.regularCoverage.isSheaf_yoneda_obj"><span class="name">CategoryTheory</span>.<span class="name">regularCoverage</span>.<span class="name">isSheaf_yoneda_obj</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.Preregular">CategoryTheory.Preregular</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(W : <span class="fn">C</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.IsSheaf">CategoryTheory.Presieve.IsSheaf</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Coverage.html#CategoryTheory.Coverage.toGrothendieck">CategoryTheory.Coverage.toGrothendieck</a> <span class="fn">C</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.regularCoverage">CategoryTheory.regularCoverage</a> <span class="fn">C</span></span>)</span></span>)</span>
  <span class="fn">(<span class="fn"><span class="fn">CategoryTheory.yoneda</span>.obj <span class="fn">W</span></span>)</span></span></div></div><p>Every Yoneda-presheaf is a sheaf for the regular topology.</p></div></div><div class="decl" id="CategoryTheory.regularCoverage.subcanonical"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/RegularExtensive.lean#L319-L320">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.regularCoverage.subcanonical"><span class="name">CategoryTheory</span>.<span class="name">regularCoverage</span>.<span class="name">subcanonical</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.Preregular">CategoryTheory.Preregular</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.Sheaf.Subcanonical">CategoryTheory.Sheaf.Subcanonical</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Coverage.html#CategoryTheory.Coverage.toGrothendieck">CategoryTheory.Coverage.toGrothendieck</a> <span class="fn">C</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.regularCoverage">CategoryTheory.regularCoverage</a> <span class="fn">C</span></span>)</span></span>)</span></span></div></div><p>The regular topology on any preregular category is subcanonical.</p></div></div><div class="decl" id="CategoryTheory.Presieve.extensive"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/RegularExtensive.lean#L332-L337">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.Presieve.extensive"><span class="name">CategoryTheory</span>.<span class="name">Presieve</span>.<span class="name">extensive</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(R : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve">CategoryTheory.Presieve</a> <span class="fn">X</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Prop</a></div></div><p>A presieve is <em>extensive</em> if it is finite and its arrows induce an isomorphism from the
coproduct to the target.</p><ul class="structure_fields" id="CategoryTheory.Presieve.extensive.mk"><li id="CategoryTheory.Presieve.extensive.arrows_nonempty_isColimit" class="structure_field"><div class="structure_field_info">arrows_nonempty_isColimit : <span class="fn">∃ (α : <a href="../../.././foundational_types.html">Type</a>) (x : <span class="fn"><a href="../../.././Mathlib/Data/Fintype/Basic.html#Fintype">Fintype</a> <span class="fn">α</span></span>) (Z : <span class="fn"><span class="fn">α</span> → <span class="fn">C</span></span>) (π : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn"><span class="fn">Z</span> <span class="fn">a</span></span> <a href="../../.././Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom">⟶</a> <span class="fn">X</span></span></span>),
  <span class="fn"><span class="fn"><span class="fn">R</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.ofArrows">CategoryTheory.Presieve.ofArrows</a> <span class="fn">Z</span> <span class="fn">π</span></span></span> <a href="../../.././Init/Prelude.html#And">∧</a>     <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/IsLimit.html#CategoryTheory.Limits.IsColimit">CategoryTheory.Limits.IsColimit</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Cofan.mk">CategoryTheory.Limits.Cofan.mk</a> <span class="fn">X</span> <span class="fn">π</span></span>)</span></span>)</span></span></span></span></div><div class="structure_field_doc"><p><code>R</code> consists of a finite collection of arrows that together induce an isomorphism from the
coproduct of their sources.</p></div></li></ul><details class="instances"><summary>Instances</summary><ul id="instances-list-CategoryTheory.Presieve.extensive" class="instances-list"></ul></details></div></div><div class="decl" id="CategoryTheory.instHasPullbacks"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/RegularExtensive.lean#L339-L344">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.instHasPullbacks"><span class="name">CategoryTheory</span>.<span class="name">instHasPullbacks</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Extensive.html#CategoryTheory.FinitaryPreExtensive">CategoryTheory.FinitaryPreExtensive</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(S : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve">CategoryTheory.Presieve</a> <span class="fn">X</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.Presieve.extensive">CategoryTheory.Presieve.extensive</a> <span class="fn">S</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.hasPullbacks">CategoryTheory.Presieve.hasPullbacks</a> <span class="fn">S</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.hasPullbacks">CategoryTheory.Presieve.hasPullbacks</a> <span class="fn">S</span></span>)</span> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn">(_ : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.hasPullbacks">CategoryTheory.Presieve.hasPullbacks</a> <span class="fn">S</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.instPreservesLimitTypeTypesDiscreteDiscreteCategoryFunctor"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/RegularExtensive.lean#L346-L348">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.instPreservesLimitTypeTypesDiscreteDiscreteCategoryFunctor"><span class="name">CategoryTheory</span>.<span class="name">instPreservesLimitTypeTypesDiscreteDiscreteCategoryFunctor</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Data/Fintype/Basic.html#Fintype">Fintype</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{Z : <span class="fn"><span class="fn">α</span> → <span class="fn">C</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn">C</span> <a href="../../.././foundational_types.html">(<a href="../../.././foundational_types.html">Type</a> w)</a></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Preserves/Finite.html#CategoryTheory.Limits.PreservesFiniteProducts">CategoryTheory.Limits.PreservesFiniteProducts</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Preserves/Basic.html#CategoryTheory.Limits.PreservesLimit">CategoryTheory.Limits.PreservesLimit</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/DiscreteCategory.html#CategoryTheory.Discrete.functor">CategoryTheory.Discrete.functor</a> <span class="fn">fun (<span class="fn">a</span> : <span class="fn">α</span>) =&gt; <span class="fn"><span class="fn">Z</span> <span class="fn">a</span></span></span></span>)</span> <span class="fn">F</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">CategoryTheory.instPreservesLimitTypeTypesDiscreteDiscreteCategoryFunctor</span> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn">CategoryTheory.Limits.PreservesLimitsOfShape.preservesLimit</span></span></li></ul></details></div></div><div class="decl" id="CategoryTheory.isSheafFor_extensive_of_preservesFiniteProducts"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/RegularExtensive.lean#L356-L361">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.isSheafFor_extensive_of_preservesFiniteProducts"><span class="name">CategoryTheory</span>.<span class="name">isSheafFor_extensive_of_preservesFiniteProducts</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Extensive.html#CategoryTheory.FinitaryPreExtensive">CategoryTheory.FinitaryPreExtensive</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{X : <span class="fn">C</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(S : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve">CategoryTheory.Presieve</a> <span class="fn">X</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.Presieve.extensive">CategoryTheory.Presieve.extensive</a> <span class="fn">S</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <a href="../../.././foundational_types.html">(<a href="../../.././foundational_types.html">Type</a> (max u v))</a></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Preserves/Finite.html#CategoryTheory.Limits.PreservesFiniteProducts">CategoryTheory.Limits.PreservesFiniteProducts</a> <span class="fn">F</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/IsSheafFor.html#CategoryTheory.Presieve.IsSheafFor">CategoryTheory.Presieve.IsSheafFor</a> <span class="fn">F</span> <span class="fn">S</span></span></div></div><p>A finite product preserving presheaf is a sheaf for the extensive topology on a category which is
<code>FinitaryPreExtensive</code>.</p></div></div><div class="decl" id="CategoryTheory.instExtensiveSigmaObjHasColimitOfHasColimitsOfShapeDiscreteDiscreteCategoryHasColimitsOfShape_discreteHasFiniteCoproductsOf_fintypeFunctorOfArrowsι"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/RegularExtensive.lean#L363-L364">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.instExtensiveSigmaObjHasColimitOfHasColimitsOfShapeDiscreteDiscreteCategoryHasColimitsOfShape_discreteHasFiniteCoproductsOf_fintypeFunctorOfArrowsι"><span class="name">CategoryTheory</span>.<span class="name">instExtensiveSigmaObjHasColimitOfHasColimitsOfShapeDiscreteDiscreteCategoryHasColimitsOfShape_discreteHasFiniteCoproductsOf_fintypeFunctorOfArrowsι</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Extensive.html#CategoryTheory.FinitaryPreExtensive">CategoryTheory.FinitaryPreExtensive</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <a href="../../.././foundational_types.html">Type</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/Data/Fintype/Basic.html#Fintype">Fintype</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(Z : <span class="fn"><span class="fn">α</span> → <span class="fn">C</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.Presieve.extensive">CategoryTheory.Presieve.extensive</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Sieves.html#CategoryTheory.Presieve.ofArrows">CategoryTheory.Presieve.ofArrows</a> <span class="fn">Z</span> <span class="fn">fun (<span class="fn">i</span> : <span class="fn">α</span>) =&gt; <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Shapes/Products.html#CategoryTheory.Limits.Sigma.ι">CategoryTheory.Limits.Sigma.ι</a> <span class="fn">Z</span> <span class="fn">i</span></span></span></span>)</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="CategoryTheory.isSheaf_iff_preservesFiniteProducts"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover-community/mathlib4/blob/8c661e5492d1852ac9a417cfc675b6545d77c4b7/Mathlib/CategoryTheory/Sites/RegularExtensive.lean#L369-L399">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.isSheaf_iff_preservesFiniteProducts"><span class="name">CategoryTheory</span>.<span class="name">isSheaf_iff_preservesFiniteProducts</span></a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <a href="../../.././foundational_types.html">Type</a> u}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category">CategoryTheory.Category.{v, u}</a>    <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Extensive.html#CategoryTheory.FinitaryPreExtensive">CategoryTheory.FinitaryPreExtensive</a> <span class="fn">C</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Extensive.html#CategoryTheory.FinitaryExtensive">CategoryTheory.FinitaryExtensive</a> <span class="fn">C</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(F : <span class="fn"><a href="../../.././Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor">CategoryTheory.Functor</a> <span class="fn"><span class="fn">C</span><a href="../../.././Mathlib/Data/Opposite.html#Opposite">ᵒᵖ</a></span> <a href="../../.././foundational_types.html">(<a href="../../.././foundational_types.html">Type</a> (max u v))</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/SheafOfTypes.html#CategoryTheory.Presieve.IsSheaf">CategoryTheory.Presieve.IsSheaf</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/Coverage.html#CategoryTheory.Coverage.toGrothendieck">CategoryTheory.Coverage.toGrothendieck</a> <span class="fn">C</span> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Sites/RegularExtensive.html#CategoryTheory.extensiveCoverage">CategoryTheory.extensiveCoverage</a> <span class="fn">C</span></span>)</span></span>)</span> <span class="fn">F</span></span> <a href="../../.././Init/Core.html#Iff">↔</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">(<span class="fn"><a href="../../.././Mathlib/CategoryTheory/Limits/Preserves/Finite.html#CategoryTheory.Limits.PreservesFiniteProducts">CategoryTheory.Limits.PreservesFiniteProducts</a> <span class="fn">F</span></span>)</span></span></span></div></div><p>A presheaf on a category which is <code>FinitaryExtensive</code> is a sheaf iff it preserves finite products.</p></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>