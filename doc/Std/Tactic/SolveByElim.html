<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../.././style.css"></link><link rel="stylesheet" href="../.././src/pygments.css"></link><link rel="shortcut icon" href="../.././favicon.ico"></link><link rel="prefetch" href="../.././/declarations/declaration-data.bmp" as="image"></link><title>Std.Tactic.SolveByElim</title><script defer="true" src="../.././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../.././";</script><script>const MODULE_NAME="Std.Tactic.SolveByElim";</script><script type="module" src="../.././jump-src.js"></script><script type="module" src="../.././search.js"></script><script type="module" src="../.././expand-nav.js"></script><script type="module" src="../.././how-about.js"></script><script type="module" src="../.././instances.js"></script><script type="module" src="../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span></h2><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib4_docs"></input><input type="text" name="q" autocomplete="off"></input>&#32;
            <button id="search_button" onclick="javascript: form.action='../.././search.html';">Search</button><button>Google site search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../.././Init.html">Init</a></li><li><a href="../.././Std/Tactic/LabelAttr.html">Std.Tactic.LabelAttr</a></li><li><a href="../.././Std/Data/Sum/Basic.html">Std.Data.Sum.Basic</a></li><li><a href="../.././Std/Tactic/Relation/Symm.html">Std.Tactic.Relation.Symm</a></li><li><a href="../.././Std/Tactic/SolveByElim/Backtrack.html">Std.Tactic.SolveByElim.Backtrack</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Std.Tactic.SolveByElim" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.MVarId.symmSaturate"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">symmSaturate</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.tacticSymm_saturate"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">tacticSymm_saturate</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.applyTactics"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">applyTactics</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.applyFirst"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">applyFirst</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.ApplyRulesConfig"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">ApplyRulesConfig</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.Config"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">Config</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.instCoeConfigBacktrackConfig"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">instCoeConfigBacktrackConfig</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.elabConfig"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">elabConfig</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.elabApplyRulesConfig"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">elabApplyRulesConfig</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.Config.accept"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">Config</span>.<span class="name">accept</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.Config.mainGoalProc"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">Config</span>.<span class="name">mainGoalProc</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.Config.intros"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">Config</span>.<span class="name">intros</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.Config.synthInstance"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">Config</span>.<span class="name">synthInstance</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.Config.withDischarge"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">Config</span>.<span class="name">withDischarge</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.Config.introsAfter"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">Config</span>.<span class="name">introsAfter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.Config.synthInstanceAfter"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">Config</span>.<span class="name">synthInstanceAfter</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.Config.testPartialSolutions"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">Config</span>.<span class="name">testPartialSolutions</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.Config.testSolutions"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">Config</span>.<span class="name">testSolutions</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.Config.requireUsingAll"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">Config</span>.<span class="name">requireUsingAll</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.elabContextLemmas"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">elabContextLemmas</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.applyLemmas"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">applyLemmas</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.applyFirstLemma"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">applyFirstLemma</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.solveByElim"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">solveByElim</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.solveByElim.run"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">solveByElim</span>.<span class="name">run</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.MVarId.applyRules"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">applyRules</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.mkAssumptionSet"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">mkAssumptionSet</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.mkAssumptionSet.elab'"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">mkAssumptionSet</span>.<span class="name">elab'</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.erase"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">erase</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.star"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">star</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.arg"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">arg</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.args"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">args</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.using_"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">using_</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.parseArgs"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">parseArgs</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.parseUsing"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">parseUsing</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.solveByElimSyntax"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">solveByElimSyntax</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.solveByElim.processSyntax"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">solveByElim</span>.<span class="name">processSyntax</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.applyAssumptionSyntax"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">applyAssumptionSyntax</span></a></div><div class="nav_link"><a class="break_within" href="#Std.Tactic.SolveByElim.applyRulesSyntax"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">applyRulesSyntax</span></a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="solve-by-elim-apply-rules-and-apply-assumption"><code>solve_by_elim</code>, <code>apply_rules</code>, and <code>apply_assumption</code>. <a class="hover-link" href="#solve-by-elim-apply-rules-and-apply-assumption">#</a></h1><p><code>solve_by_elim</code> takes a collection of facts from the local context or
supplied as arguments by the user, and performs a backtracking
depth-first search by attempting to <code>apply</code> these facts to the goal.</p><p>It is a highly configurable tactic, with options to control the
backtracking, to solve multiple goals simultaneously (with backtracking
between goals), or to supply a discharging tactic for unprovable goals.</p><p><code>apply_rules</code> and <code>apply_assumption</code> are much simpler tactics which do
not perform backtracking, but are currently implemented in terms of
<code>solve_by_elim</code> with backtracking disabled, in order to be able to share
the front-end customisation and parsing of user options. It would be
reasonable to further separate these in future.</p></div><div class="decl" id="Lean.MVarId.symmSaturate"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L36-L46">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Lean.MVarId.symmSaturate"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">symmSaturate</span></a></span><span class="decl_args">
<span class="fn">(g : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span></div></div><p>For every hypothesis <code>h : a ~ b</code> where a <code>@[symm]</code> lemma is available,
add a hypothesis <code>h_symm : b ~ a</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.MVarId.symmSaturate" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.tacticSymm_saturate"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L54-L56">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.tacticSymm_saturate"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">tacticSymm_saturate</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>For every hypothesis <code>h : a ~ b</code> where a <code>@[symm]</code> lemma is available,
add a hypothesis <code>h_symm : b ~ a</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.tacticSymm_saturate">Std.Tactic.tacticSymm_saturate</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Std.Tactic.tacticSymm_saturate</span> <span class="fn">1024</span> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;symm_saturate&quot;</span> <a href="../.././Init/Prelude.html#Bool.false">false</a></span>)</span></span></span></li></ul></details><details id="instances-for-list-Std.Tactic.tacticSymm_saturate" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.applyTactics"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L72-L82">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.applyTactics"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">applyTactics</span></a></span><span class="decl_args">
<span class="fn">(cfg : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyConfig">Lean.Meta.ApplyConfig</a>
  <span class="fn">{ <span class="fn">newGoals</span> := <a href="../.././Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals.nonDependentFirst">Lean.Meta.ApplyNewGoals.nonDependentFirst</a>, <span class="fn">synthAssignedInstances</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>, <span class="fn">allowSynthFailures</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a>,
    <span class="fn">approx</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(transparency : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/MetaTypes.html#Lean.Meta.TransparencyMode">Lean.Meta.TransparencyMode</a> <a href="../.././Init/MetaTypes.html#Lean.Meta.TransparencyMode.default">Lean.Meta.TransparencyMode.default</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(lemmas : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Std/Control/Nondet/Basic.html#Nondet">Nondet</a> <a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span>)</span></span></div></div><p><code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.applyTactics">applyTactics</a> lemmas goal</code> will return a list of tactics,
corresponding to applying each one of the lemmas to the goal <code>goal</code>.</p><p>Providing this to the <code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.backtracking">backtracking</a></code> tactic,
we can perform backtracking search based on applying a list of lemmas.</p><p><code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.applyTactics">applyTactics</a> (trace := `name)</code> will construct trace nodes for ``name<code>indicating which calls to</code>apply` succeeded or failed.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.Tactic.SolveByElim.applyTactics" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.applyFirst"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L90-L92">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.applyFirst"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">applyFirst</span></a></span><span class="decl_args">
<span class="fn">(cfg : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyConfig">Lean.Meta.ApplyConfig</a>
  <span class="fn">{ <span class="fn">newGoals</span> := <a href="../.././Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals.nonDependentFirst">Lean.Meta.ApplyNewGoals.nonDependentFirst</a>, <span class="fn">synthAssignedInstances</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>, <span class="fn">allowSynthFailures</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a>,
    <span class="fn">approx</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(transparency : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/MetaTypes.html#Lean.Meta.TransparencyMode">Lean.Meta.TransparencyMode</a> <a href="../.././Init/MetaTypes.html#Lean.Meta.TransparencyMode.default">Lean.Meta.TransparencyMode.default</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(lemmas : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span>)</span></span></div></div><p><code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.applyFirst">applyFirst</a> lemmas goal</code> applies the first of the <code>lemmas</code>
which can be successfully applied to <code>goal</code>, and fails if none apply.</p><p>We use this in <code>apply_rules</code> and <code>apply_assumption</code> where backtracking is not needed.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.applyFirst">Std.Tactic.SolveByElim.applyFirst</a> <span class="fn">cfg</span> <span class="fn">transparency</span> <span class="fn">lemmas</span> <span class="fn">g</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Std/Control/Nondet/Basic.html#Nondet.head">Nondet.head</a> <span class="fn">(<span class="fn"><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.applyTactics">Std.Tactic.SolveByElim.applyTactics</a> <span class="fn">cfg</span> <span class="fn">transparency</span> <span class="fn">lemmas</span> <span class="fn">g</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-Std.Tactic.SolveByElim.applyFirst" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.ApplyRulesConfig"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L95-L103">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">ApplyRulesConfig</span></a></span><span class="decl_extends">extends</span><span class="decl_parent">
<span class="fn"><a class="break_within" href="../.././Std/Tactic/SolveByElim/Backtrack.html#Std.Tactic.BacktrackConfig"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">BacktrackConfig</span></a></span></span>
, <span class="decl_parent">
<span class="fn"><a class="break_within" href="../.././Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyConfig"><span class="name">Lean</span>.<span class="name">Meta</span>.<span class="name">ApplyConfig</span></a></span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>The default <code>maxDepth</code> for <code>apply_rules</code> is higher.</p><ul class="structure_fields" id="Std.Tactic.SolveByElim.ApplyRulesConfig.mk"><li id="Std.Tactic.SolveByElim.ApplyRulesConfig.maxDepth" class="structure_field"><div class="structure_field_info">maxDepth : <a href="../.././Init/Prelude.html#Nat">Nat</a></div></li><li id="Std.Tactic.SolveByElim.ApplyRulesConfig.proc" class="structure_field"><div class="structure_field_info">proc : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span> → <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span> → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span>)</span></span>)</span></span></span></div></li><li id="Std.Tactic.SolveByElim.ApplyRulesConfig.suspend" class="structure_field"><div class="structure_field_info">suspend : <span class="fn"><a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a> → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Init/Prelude.html#Bool">Bool</a></span></span></div></li><li id="Std.Tactic.SolveByElim.ApplyRulesConfig.discharge" class="structure_field"><div class="structure_field_info">discharge : <span class="fn"><a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a> → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span>)</span></span>)</span></span></span></div></li><li id="Std.Tactic.SolveByElim.ApplyRulesConfig.commitIndependentGoals" class="structure_field"><div class="structure_field_info">commitIndependentGoals : <a href="../.././Init/Prelude.html#Bool">Bool</a></div></li><li id="Std.Tactic.SolveByElim.ApplyRulesConfig.newGoals" class="structure_field"><div class="structure_field_info">newGoals : <a href="../.././Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals">Lean.Meta.ApplyNewGoals</a></div></li><li id="Std.Tactic.SolveByElim.ApplyRulesConfig.synthAssignedInstances" class="structure_field"><div class="structure_field_info">synthAssignedInstances : <a href="../.././Init/Prelude.html#Bool">Bool</a></div></li><li id="Std.Tactic.SolveByElim.ApplyRulesConfig.allowSynthFailures" class="structure_field"><div class="structure_field_info">allowSynthFailures : <a href="../.././Init/Prelude.html#Bool">Bool</a></div></li><li id="Std.Tactic.SolveByElim.ApplyRulesConfig.approx" class="structure_field"><div class="structure_field_info">approx : <a href="../.././Init/Prelude.html#Bool">Bool</a></div></li><li id="Std.Tactic.SolveByElim.ApplyRulesConfig.transparency" class="structure_field"><div class="structure_field_info">transparency : <a href="../.././Init/MetaTypes.html#Lean.Meta.TransparencyMode">Lean.Meta.TransparencyMode</a></div><div class="structure_field_doc"><p>Transparency mode for calls to <code>apply</code>.</p></div></li><li id="Std.Tactic.SolveByElim.ApplyRulesConfig.symm" class="structure_field"><div class="structure_field_info">symm : <a href="../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>Also use symmetric versions (via <code>@[symm]</code>) of local hypotheses.</p></div></li><li id="Std.Tactic.SolveByElim.ApplyRulesConfig.exfalso" class="structure_field"><div class="structure_field_info">exfalso : <a href="../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>Try proving the goal via <code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig.exfalso">exfalso</a></code> if <code>solve_by_elim</code> otherwise fails.
This is only used when operating on a single goal.</p></div></li></ul><details id="instances-for-list-Std.Tactic.SolveByElim.ApplyRulesConfig" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.Config"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L111-L114">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">Config</span></a></span><span class="decl_extends">extends</span><span class="decl_parent">
<span class="fn"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">ApplyRulesConfig</span></a></span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././foundational_types.html">Type</a></div></div><p>Configuration structure to control the behaviour of <code>solve_by_elim</code>:</p><ul>
<li>transparency mode for calls to <code>apply</code></li>
<li>whether to use <code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig.symm">symm</a></code> on hypotheses and <code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig.exfalso">exfalso</a></code> on the goal as needed,</li>
<li>see also <code>BacktrackConfig</code> for hooks allowing flow control.</li>
</ul><ul class="structure_fields" id="Std.Tactic.SolveByElim.Config.mk"><li id="Std.Tactic.SolveByElim.Config.maxDepth" class="structure_field"><div class="structure_field_info">maxDepth : <a href="../.././Init/Prelude.html#Nat">Nat</a></div></li><li id="Std.Tactic.SolveByElim.Config.proc" class="structure_field"><div class="structure_field_info">proc : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span> → <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span> → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span>)</span></span>)</span></span></span></div></li><li id="Std.Tactic.SolveByElim.Config.suspend" class="structure_field"><div class="structure_field_info">suspend : <span class="fn"><a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a> → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Init/Prelude.html#Bool">Bool</a></span></span></div></li><li id="Std.Tactic.SolveByElim.Config.discharge" class="structure_field"><div class="structure_field_info">discharge : <span class="fn"><a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a> → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span>)</span></span>)</span></span></span></div></li><li id="Std.Tactic.SolveByElim.Config.commitIndependentGoals" class="structure_field"><div class="structure_field_info">commitIndependentGoals : <a href="../.././Init/Prelude.html#Bool">Bool</a></div></li><li id="Std.Tactic.SolveByElim.Config.newGoals" class="structure_field"><div class="structure_field_info">newGoals : <a href="../.././Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals">Lean.Meta.ApplyNewGoals</a></div></li><li id="Std.Tactic.SolveByElim.Config.synthAssignedInstances" class="structure_field"><div class="structure_field_info">synthAssignedInstances : <a href="../.././Init/Prelude.html#Bool">Bool</a></div></li><li id="Std.Tactic.SolveByElim.Config.allowSynthFailures" class="structure_field"><div class="structure_field_info">allowSynthFailures : <a href="../.././Init/Prelude.html#Bool">Bool</a></div></li><li id="Std.Tactic.SolveByElim.Config.approx" class="structure_field"><div class="structure_field_info">approx : <a href="../.././Init/Prelude.html#Bool">Bool</a></div></li><li id="Std.Tactic.SolveByElim.Config.transparency" class="structure_field"><div class="structure_field_info">transparency : <a href="../.././Init/MetaTypes.html#Lean.Meta.TransparencyMode">Lean.Meta.TransparencyMode</a></div></li><li id="Std.Tactic.SolveByElim.Config.symm" class="structure_field"><div class="structure_field_info">symm : <a href="../.././Init/Prelude.html#Bool">Bool</a></div></li><li id="Std.Tactic.SolveByElim.Config.exfalso" class="structure_field"><div class="structure_field_info">exfalso : <a href="../.././Init/Prelude.html#Bool">Bool</a></div></li><li id="Std.Tactic.SolveByElim.Config.backtracking" class="structure_field"><div class="structure_field_info">backtracking : <a href="../.././Init/Prelude.html#Bool">Bool</a></div><div class="structure_field_doc"><p>Enable backtracking search.</p></div></li></ul><details id="instances-for-list-Std.Tactic.SolveByElim.Config" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.instCoeConfigBacktrackConfig"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L116-L116">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.instCoeConfigBacktrackConfig"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">instCoeConfigBacktrackConfig</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Coe.html#Coe">Coe</a> <a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Std.Tactic.SolveByElim.Config</a> <a href="../.././Std/Tactic/SolveByElim/Backtrack.html#Std.Tactic.BacktrackConfig">Std.Tactic.BacktrackConfig</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.instCoeConfigBacktrackConfig">Std.Tactic.SolveByElim.instCoeConfigBacktrackConfig</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">coe</span> := <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Std.Tactic.SolveByElim.Config</a>) =&gt; <span class="fn"><span class="fn"><span class="fn">x</span>.toApplyRulesConfig</span>.toBacktrackConfig</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.elabConfig"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L118-L121">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.elabConfig"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">elabConfig</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a> → <span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Std.Tactic.SolveByElim.Config</a></span></span></div></div><p>Allow elaboration of <code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Config</a></code> arguments to tactics.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.Tactic.SolveByElim.elabConfig" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.elabApplyRulesConfig"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L123-L126">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.elabApplyRulesConfig"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">elabApplyRulesConfig</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a> → <span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig">Std.Tactic.SolveByElim.ApplyRulesConfig</a></span></span></div></div><p>Allow elaboration of <code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig">ApplyRulesConfig</a></code> arguments to tactics.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.Tactic.SolveByElim.elabApplyRulesConfig" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="mod_doc"><p>These functions could be lifted up to <code>BacktrackConfig</code>,
but we'd still need to keep copies here.</p></div><div class="decl" id="Std.Tactic.SolveByElim.Config.accept"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L135-L141">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.accept"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">Config</span>.<span class="name">accept</span></a></span><span class="decl_args">
<span class="fn">(cfg : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Std.Tactic.SolveByElim.Config</a>
  <span class="fn">{
    <span class="fn">toApplyRulesConfig</span> :=
      <span class="fn">{
        <span class="fn">toBacktrackConfig</span> :=
          <span class="fn">{ <span class="fn">maxDepth</span> := <span class="fn">6</span>, <span class="fn">proc</span> := <span class="fn">fun (<span class="fn">x</span> x : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span>) =&gt; <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">none</span></span></span>,
            <span class="fn">suspend</span> := <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span></span>, <span class="fn">discharge</span> := <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn">failure</span></span>,
            <span class="fn">commitIndependentGoals</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a> }</span>,
        <span class="fn">toApplyConfig</span> :=
          <span class="fn">{ <span class="fn">newGoals</span> := <a href="../.././Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals.nonDependentFirst">Lean.Meta.ApplyNewGoals.nonDependentFirst</a>, <span class="fn">synthAssignedInstances</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>,
            <span class="fn">allowSynthFailures</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a>, <span class="fn">approx</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span>,
        <span class="fn">transparency</span> := <a href="../.././Init/MetaTypes.html#Lean.Meta.TransparencyMode.default">Lean.Meta.TransparencyMode.default</a>, <span class="fn">symm</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>, <span class="fn">exfalso</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span>,
    <span class="fn">backtracking</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(test : <span class="fn"><a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a> → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Init/Prelude.html#Bool">Bool</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Std.Tactic.SolveByElim.Config</a></div></div><p>Create or modify a <code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Config</a></code> which allows a class of goals to be returned as subgoals.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.Tactic.SolveByElim.Config.accept" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.Config.mainGoalProc"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L147-L153">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.mainGoalProc"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">Config</span>.<span class="name">mainGoalProc</span></a></span><span class="decl_args">
<span class="fn">(cfg : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Std.Tactic.SolveByElim.Config</a>
  <span class="fn">{
    <span class="fn">toApplyRulesConfig</span> :=
      <span class="fn">{
        <span class="fn">toBacktrackConfig</span> :=
          <span class="fn">{ <span class="fn">maxDepth</span> := <span class="fn">6</span>, <span class="fn">proc</span> := <span class="fn">fun (<span class="fn">x</span> x : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span>) =&gt; <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">none</span></span></span>,
            <span class="fn">suspend</span> := <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span></span>, <span class="fn">discharge</span> := <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn">failure</span></span>,
            <span class="fn">commitIndependentGoals</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a> }</span>,
        <span class="fn">toApplyConfig</span> :=
          <span class="fn">{ <span class="fn">newGoals</span> := <a href="../.././Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals.nonDependentFirst">Lean.Meta.ApplyNewGoals.nonDependentFirst</a>, <span class="fn">synthAssignedInstances</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>,
            <span class="fn">allowSynthFailures</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a>, <span class="fn">approx</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span>,
        <span class="fn">transparency</span> := <a href="../.././Init/MetaTypes.html#Lean.Meta.TransparencyMode.default">Lean.Meta.TransparencyMode.default</a>, <span class="fn">symm</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>, <span class="fn">exfalso</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span>,
    <span class="fn">backtracking</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(proc : <span class="fn"><a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a> → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Std.Tactic.SolveByElim.Config</a></div></div><p>Create or modify a <code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Config</a></code> which runs a tactic on the main goal.
If that tactic fails, fall back to the <code>proc</code> behaviour of <code>cfg</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.Tactic.SolveByElim.Config.mainGoalProc" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.Config.intros"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L159-L160">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.intros"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">Config</span>.<span class="name">intros</span></a></span><span class="decl_args">
<span class="fn">(cfg : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Std.Tactic.SolveByElim.Config</a>
  <span class="fn">{
    <span class="fn">toApplyRulesConfig</span> :=
      <span class="fn">{
        <span class="fn">toBacktrackConfig</span> :=
          <span class="fn">{ <span class="fn">maxDepth</span> := <span class="fn">6</span>, <span class="fn">proc</span> := <span class="fn">fun (<span class="fn">x</span> x : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span>) =&gt; <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">none</span></span></span>,
            <span class="fn">suspend</span> := <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span></span>, <span class="fn">discharge</span> := <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn">failure</span></span>,
            <span class="fn">commitIndependentGoals</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a> }</span>,
        <span class="fn">toApplyConfig</span> :=
          <span class="fn">{ <span class="fn">newGoals</span> := <a href="../.././Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals.nonDependentFirst">Lean.Meta.ApplyNewGoals.nonDependentFirst</a>, <span class="fn">synthAssignedInstances</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>,
            <span class="fn">allowSynthFailures</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a>, <span class="fn">approx</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span>,
        <span class="fn">transparency</span> := <a href="../.././Init/MetaTypes.html#Lean.Meta.TransparencyMode.default">Lean.Meta.TransparencyMode.default</a>, <span class="fn">symm</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>, <span class="fn">exfalso</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span>,
    <span class="fn">backtracking</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Std.Tactic.SolveByElim.Config</a></div></div><p>Create or modify a <code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Config</a></code> which calls <code>intro</code> on each goal before applying lemmas.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.intros">Std.Tactic.SolveByElim.Config.intros</a> <span class="fn">cfg</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.mainGoalProc">Std.Tactic.SolveByElim.Config.mainGoalProc</a> <span class="fn">cfg</span> <span class="fn">fun (<span class="fn">g</span> : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn">do
    let __do_lift ← <span class="fn"><a href="../.././Lean/Meta/Tactic/Intro.html#Lean.MVarId.intro1P">Lean.MVarId.intro1P</a> <span class="fn">g</span></span>
    <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">[<span class="fn"><span class="fn">__do_lift</span>.snd</span>]</span></span></span></span></span></span></li></ul></details><details id="instances-for-list-Std.Tactic.SolveByElim.Config.intros" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.Config.synthInstance"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L166-L167">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.synthInstance"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">Config</span>.<span class="name">synthInstance</span></a></span><span class="decl_args">
<span class="fn">(cfg : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Std.Tactic.SolveByElim.Config</a>
  <span class="fn">{
    <span class="fn">toApplyRulesConfig</span> :=
      <span class="fn">{
        <span class="fn">toBacktrackConfig</span> :=
          <span class="fn">{ <span class="fn">maxDepth</span> := <span class="fn">6</span>, <span class="fn">proc</span> := <span class="fn">fun (<span class="fn">x</span> x : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span>) =&gt; <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">none</span></span></span>,
            <span class="fn">suspend</span> := <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span></span>, <span class="fn">discharge</span> := <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn">failure</span></span>,
            <span class="fn">commitIndependentGoals</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a> }</span>,
        <span class="fn">toApplyConfig</span> :=
          <span class="fn">{ <span class="fn">newGoals</span> := <a href="../.././Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals.nonDependentFirst">Lean.Meta.ApplyNewGoals.nonDependentFirst</a>, <span class="fn">synthAssignedInstances</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>,
            <span class="fn">allowSynthFailures</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a>, <span class="fn">approx</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span>,
        <span class="fn">transparency</span> := <a href="../.././Init/MetaTypes.html#Lean.Meta.TransparencyMode.default">Lean.Meta.TransparencyMode.default</a>, <span class="fn">symm</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>, <span class="fn">exfalso</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span>,
    <span class="fn">backtracking</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Std.Tactic.SolveByElim.Config</a></div></div><p>Attempt typeclass inference on each goal, before applying lemmas.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.synthInstance">Std.Tactic.SolveByElim.Config.synthInstance</a> <span class="fn">cfg</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.mainGoalProc">Std.Tactic.SolveByElim.Config.mainGoalProc</a> <span class="fn">cfg</span> <span class="fn">fun (<span class="fn">g</span> : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn">do
    <span class="fn"><a href="../.././Std/Lean/Meta/Basic.html#Lean.MVarId.synthInstance">Lean.MVarId.synthInstance</a> <span class="fn">g</span></span>
    <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">[]</span></span></span></span></span></span></li></ul></details><details id="instances-for-list-Std.Tactic.SolveByElim.Config.synthInstance" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.Config.withDischarge"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L171-L175">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.withDischarge"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">Config</span>.<span class="name">withDischarge</span></a></span><span class="decl_args">
<span class="fn">(cfg : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Std.Tactic.SolveByElim.Config</a>
  <span class="fn">{
    <span class="fn">toApplyRulesConfig</span> :=
      <span class="fn">{
        <span class="fn">toBacktrackConfig</span> :=
          <span class="fn">{ <span class="fn">maxDepth</span> := <span class="fn">6</span>, <span class="fn">proc</span> := <span class="fn">fun (<span class="fn">x</span> x : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span>) =&gt; <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">none</span></span></span>,
            <span class="fn">suspend</span> := <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span></span>, <span class="fn">discharge</span> := <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn">failure</span></span>,
            <span class="fn">commitIndependentGoals</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a> }</span>,
        <span class="fn">toApplyConfig</span> :=
          <span class="fn">{ <span class="fn">newGoals</span> := <a href="../.././Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals.nonDependentFirst">Lean.Meta.ApplyNewGoals.nonDependentFirst</a>, <span class="fn">synthAssignedInstances</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>,
            <span class="fn">allowSynthFailures</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a>, <span class="fn">approx</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span>,
        <span class="fn">transparency</span> := <a href="../.././Init/MetaTypes.html#Lean.Meta.TransparencyMode.default">Lean.Meta.TransparencyMode.default</a>, <span class="fn">symm</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>, <span class="fn">exfalso</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span>,
    <span class="fn">backtracking</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(discharge : <span class="fn"><a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a> → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span>)</span></span>)</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Std.Tactic.SolveByElim.Config</a></div></div><p>Add a discharging tactic, falling back to the original discharging tactic if it fails.
Return <code>none</code> to return the goal as a new subgoal, or <code>some goals</code> to replace it.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.Tactic.SolveByElim.Config.withDischarge" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.Config.introsAfter"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L178-L179">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.introsAfter"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">Config</span>.<span class="name">introsAfter</span></a></span><span class="decl_args">
<span class="fn">(cfg : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Std.Tactic.SolveByElim.Config</a>
  <span class="fn">{
    <span class="fn">toApplyRulesConfig</span> :=
      <span class="fn">{
        <span class="fn">toBacktrackConfig</span> :=
          <span class="fn">{ <span class="fn">maxDepth</span> := <span class="fn">6</span>, <span class="fn">proc</span> := <span class="fn">fun (<span class="fn">x</span> x : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span>) =&gt; <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">none</span></span></span>,
            <span class="fn">suspend</span> := <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span></span>, <span class="fn">discharge</span> := <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn">failure</span></span>,
            <span class="fn">commitIndependentGoals</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a> }</span>,
        <span class="fn">toApplyConfig</span> :=
          <span class="fn">{ <span class="fn">newGoals</span> := <a href="../.././Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals.nonDependentFirst">Lean.Meta.ApplyNewGoals.nonDependentFirst</a>, <span class="fn">synthAssignedInstances</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>,
            <span class="fn">allowSynthFailures</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a>, <span class="fn">approx</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span>,
        <span class="fn">transparency</span> := <a href="../.././Init/MetaTypes.html#Lean.Meta.TransparencyMode.default">Lean.Meta.TransparencyMode.default</a>, <span class="fn">symm</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>, <span class="fn">exfalso</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span>,
    <span class="fn">backtracking</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Std.Tactic.SolveByElim.Config</a></div></div><p>Create or modify a <code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Config</a></code> which calls <code>intro</code> on any goal for which no lemma applies.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.Tactic.SolveByElim.Config.introsAfter" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.Config.synthInstanceAfter"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L183-L184">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.synthInstanceAfter"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">Config</span>.<span class="name">synthInstanceAfter</span></a></span><span class="decl_args">
<span class="fn">(cfg : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Std.Tactic.SolveByElim.Config</a>
  <span class="fn">{
    <span class="fn">toApplyRulesConfig</span> :=
      <span class="fn">{
        <span class="fn">toBacktrackConfig</span> :=
          <span class="fn">{ <span class="fn">maxDepth</span> := <span class="fn">6</span>, <span class="fn">proc</span> := <span class="fn">fun (<span class="fn">x</span> x : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span>) =&gt; <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">none</span></span></span>,
            <span class="fn">suspend</span> := <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span></span>, <span class="fn">discharge</span> := <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn">failure</span></span>,
            <span class="fn">commitIndependentGoals</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a> }</span>,
        <span class="fn">toApplyConfig</span> :=
          <span class="fn">{ <span class="fn">newGoals</span> := <a href="../.././Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals.nonDependentFirst">Lean.Meta.ApplyNewGoals.nonDependentFirst</a>, <span class="fn">synthAssignedInstances</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>,
            <span class="fn">allowSynthFailures</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a>, <span class="fn">approx</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span>,
        <span class="fn">transparency</span> := <a href="../.././Init/MetaTypes.html#Lean.Meta.TransparencyMode.default">Lean.Meta.TransparencyMode.default</a>, <span class="fn">symm</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>, <span class="fn">exfalso</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span>,
    <span class="fn">backtracking</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Std.Tactic.SolveByElim.Config</a></div></div><p>Create or modify a <code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Config</a></code> which
calls <code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.synthInstance">synthInstance</a></code> on any goal for which no lemma applies.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.synthInstanceAfter">Std.Tactic.SolveByElim.Config.synthInstanceAfter</a> <span class="fn">cfg</span></span> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.withDischarge">Std.Tactic.SolveByElim.Config.withDischarge</a> <span class="fn">cfg</span> <span class="fn">fun (<span class="fn">g</span> : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn">do
    <span class="fn"><a href="../.././Std/Lean/Meta/Basic.html#Lean.MVarId.synthInstance">Lean.MVarId.synthInstance</a> <span class="fn">g</span></span>
    <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Option.some">some</a> <span class="fn">[]</span></span>)</span></span></span></span></span></span></li></ul></details><details id="instances-for-list-Std.Tactic.SolveByElim.Config.synthInstanceAfter" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.Config.testPartialSolutions"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L190-L194">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.testPartialSolutions"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">Config</span>.<span class="name">testPartialSolutions</span></a></span><span class="decl_args">
<span class="fn">(cfg : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Std.Tactic.SolveByElim.Config</a>
  <span class="fn">{
    <span class="fn">toApplyRulesConfig</span> :=
      <span class="fn">{
        <span class="fn">toBacktrackConfig</span> :=
          <span class="fn">{ <span class="fn">maxDepth</span> := <span class="fn">6</span>, <span class="fn">proc</span> := <span class="fn">fun (<span class="fn">x</span> x : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span>) =&gt; <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">none</span></span></span>,
            <span class="fn">suspend</span> := <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span></span>, <span class="fn">discharge</span> := <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn">failure</span></span>,
            <span class="fn">commitIndependentGoals</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a> }</span>,
        <span class="fn">toApplyConfig</span> :=
          <span class="fn">{ <span class="fn">newGoals</span> := <a href="../.././Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals.nonDependentFirst">Lean.Meta.ApplyNewGoals.nonDependentFirst</a>, <span class="fn">synthAssignedInstances</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>,
            <span class="fn">allowSynthFailures</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a>, <span class="fn">approx</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span>,
        <span class="fn">transparency</span> := <a href="../.././Init/MetaTypes.html#Lean.Meta.TransparencyMode.default">Lean.Meta.TransparencyMode.default</a>, <span class="fn">symm</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>, <span class="fn">exfalso</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span>,
    <span class="fn">backtracking</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(test : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span> → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Init/Prelude.html#Bool">Bool</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Std.Tactic.SolveByElim.Config</a></div></div><p>Create or modify a <code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Config</a></code> which rejects branches for which <code>test</code>,
applied to the instantiations of the original goals, fails or returns <code>false</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.Tactic.SolveByElim.Config.testPartialSolutions" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.Config.testSolutions"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L200-L205">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.testSolutions"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">Config</span>.<span class="name">testSolutions</span></a></span><span class="decl_args">
<span class="fn">(cfg : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Std.Tactic.SolveByElim.Config</a>
  <span class="fn">{
    <span class="fn">toApplyRulesConfig</span> :=
      <span class="fn">{
        <span class="fn">toBacktrackConfig</span> :=
          <span class="fn">{ <span class="fn">maxDepth</span> := <span class="fn">6</span>, <span class="fn">proc</span> := <span class="fn">fun (<span class="fn">x</span> x : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span>) =&gt; <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">none</span></span></span>,
            <span class="fn">suspend</span> := <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span></span>, <span class="fn">discharge</span> := <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn">failure</span></span>,
            <span class="fn">commitIndependentGoals</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a> }</span>,
        <span class="fn">toApplyConfig</span> :=
          <span class="fn">{ <span class="fn">newGoals</span> := <a href="../.././Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals.nonDependentFirst">Lean.Meta.ApplyNewGoals.nonDependentFirst</a>, <span class="fn">synthAssignedInstances</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>,
            <span class="fn">allowSynthFailures</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a>, <span class="fn">approx</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span>,
        <span class="fn">transparency</span> := <a href="../.././Init/MetaTypes.html#Lean.Meta.TransparencyMode.default">Lean.Meta.TransparencyMode.default</a>, <span class="fn">symm</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>, <span class="fn">exfalso</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span>,
    <span class="fn">backtracking</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(test : <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span> → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <a href="../.././Init/Prelude.html#Bool">Bool</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Std.Tactic.SolveByElim.Config</a></div></div><p>Create or modify a <code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Config</a></code> which rejects complete solutions for which <code>test</code>,
applied to the instantiations of the original goals, fails or returns <code>false</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.Tactic.SolveByElim.Config.testSolutions" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.Config.requireUsingAll"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L211-L213">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config.requireUsingAll"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">Config</span>.<span class="name">requireUsingAll</span></a></span><span class="decl_args">
<span class="fn">(cfg : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Std.Tactic.SolveByElim.Config</a>
  <span class="fn">{
    <span class="fn">toApplyRulesConfig</span> :=
      <span class="fn">{
        <span class="fn">toBacktrackConfig</span> :=
          <span class="fn">{ <span class="fn">maxDepth</span> := <span class="fn">6</span>, <span class="fn">proc</span> := <span class="fn">fun (<span class="fn">x</span> x : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span>) =&gt; <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">none</span></span></span>,
            <span class="fn">suspend</span> := <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span></span>, <span class="fn">discharge</span> := <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn">failure</span></span>,
            <span class="fn">commitIndependentGoals</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a> }</span>,
        <span class="fn">toApplyConfig</span> :=
          <span class="fn">{ <span class="fn">newGoals</span> := <a href="../.././Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals.nonDependentFirst">Lean.Meta.ApplyNewGoals.nonDependentFirst</a>, <span class="fn">synthAssignedInstances</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>,
            <span class="fn">allowSynthFailures</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a>, <span class="fn">approx</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span>,
        <span class="fn">transparency</span> := <a href="../.././Init/MetaTypes.html#Lean.Meta.TransparencyMode.default">Lean.Meta.TransparencyMode.default</a>, <span class="fn">symm</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>, <span class="fn">exfalso</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span>,
    <span class="fn">backtracking</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(use : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Std.Tactic.SolveByElim.Config</a></div></div><p>Create or modify a <code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Config</a></code> which only accept solutions
for which every expression in <code>use</code> appears as a subexpression.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.Tactic.SolveByElim.Config.requireUsingAll" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.elabContextLemmas"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L221-L223">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.elabContextLemmas"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">elabContextLemmas</span></a></span><span class="decl_args">
<span class="fn">(g : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args">
<span class="fn">(lemmas : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ctx : <span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span></div></div><p>Elaborate a list of lemmas and local context.
See <code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.mkAssumptionSet">mkAssumptionSet</a></code> for an explanation of why this is needed.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.Tactic.SolveByElim.elabContextLemmas" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.applyLemmas"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L226-L232">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.applyLemmas"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">applyLemmas</span></a></span><span class="decl_args">
<span class="fn">(cfg : <a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Std.Tactic.SolveByElim.Config</a>)</span></span>
<span class="decl_args">
<span class="fn">(lemmas : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ctx : <span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Std/Control/Nondet/Basic.html#Nondet">Nondet</a> <a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span>)</span></span></div></div><p>Returns the list of tactics corresponding to applying the available lemmas to the goal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.Tactic.SolveByElim.applyLemmas" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.applyFirstLemma"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L235-L241">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.applyFirstLemma"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">applyFirstLemma</span></a></span><span class="decl_args">
<span class="fn">(cfg : <a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Std.Tactic.SolveByElim.Config</a>)</span></span>
<span class="decl_args">
<span class="fn">(lemmas : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ctx : <span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span>)</span></span></div></div><p>Applies the first possible lemma to the goal.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.Tactic.SolveByElim.applyFirstLemma" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.solveByElim"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L259-L278">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.solveByElim"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">solveByElim</span></a></span><span class="decl_args">
<span class="fn">(cfg : <a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Std.Tactic.SolveByElim.Config</a>)</span></span>
<span class="decl_args">
<span class="fn">(lemmas : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ctx : <span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(goals : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span>)</span></span></div></div><p>Solve a collection of goals by repeatedly applying lemmas, backtracking as necessary.</p><p>Arguments:</p><ul>
<li><code>cfg : <a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Config</a></code> additional configuration options
(options for <code>apply</code>, maximum depth, and custom flow control)</li>
<li><code>lemmas : <a href="../.././Init/Prelude.html#List">List</a> (TermElabM Expr)</code> lemmas to apply.
These are thunks in <code>TermElabM</code> to avoid stuck metavariables.</li>
<li><code>ctx : TermElabM (List Expr)</code> monadic function returning the local hypotheses to use.</li>
<li><code>goals : <a href="../.././Init/Prelude.html#List">List</a> MVarId</code> the initial list of goals for <code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.solveByElim">solveByElim</a></code></li>
</ul><p>Returns a list of suspended goals, if it succeeded on all other subgoals.
By default <code>cfg.suspend</code> is <code>false,</code> <code>cfg.discharge</code> fails, and <code>cfg.failAtMaxDepth</code> is <code>true</code>,
and so the returned list is always empty.
Custom wrappers (e.g. <code>apply_assumption</code> and <code>apply_rules</code>) may modify this behaviour.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.Tactic.SolveByElim.solveByElim" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.solveByElim.run"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L274-L278">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.solveByElim.run"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">solveByElim</span>.<span class="name">run</span></a></span><span class="decl_args">
<span class="fn">(cfg : <a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Std.Tactic.SolveByElim.Config</a>)</span></span>
<span class="decl_args">
<span class="fn">(lemmas : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(ctx : <span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span> → <span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span>)</span></span></span></div></div><p>Run either backtracking search, or repeated application, on the list of goals.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.Tactic.SolveByElim.solveByElim.run" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.MVarId.applyRules"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L289-L292">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Lean.MVarId.applyRules"><span class="name">Lean</span>.<span class="name">MVarId</span>.<span class="name">applyRules</span></a></span><span class="decl_args">
<span class="fn">(cfg : <a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Std.Tactic.SolveByElim.Config</a>)</span></span>
<span class="decl_args">
<span class="fn">(lemmas : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(only : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Init/Prelude.html#Bool">Bool</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span>)</span></span></div></div><p>A <code>MetaM</code> analogue of the <code>apply_rules</code> user tactic.</p><p>We pass the lemmas as <code>TermElabM Expr</code> rather than just <code>Expr</code>,
so they can be generated fresh for each application, to avoid stuck metavariables.</p><p>By default it uses all local hypotheses, but you can disable this with <code>only := true</code>.
If you need to remove particular local hypotheses, call <code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.solveByElim">solveByElim</a></code> directly.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.MVarId.applyRules" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.mkAssumptionSet"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L345-L369">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.mkAssumptionSet"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">mkAssumptionSet</span></a></span><span class="decl_args">
<span class="fn">(noDefaults : <a href="../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(star : <a href="../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(add : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Init/Meta.html#Lean.Syntax.Term">Lean.Term</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(remove : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Init/Meta.html#Lean.Syntax.Term">Lean.Term</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(use : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Init/Meta.html#Lean.Syntax.Ident">Lean.Ident</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <span class="fn">(<span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span>)</span></span></span>)</span></span></div></div><p><code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.mkAssumptionSet">mkAssumptionSet</a></code> builds a collection of lemmas for use in
the backtracking search in <code>solve_by_elim</code>.</p><ul>
<li>By default, it includes all local hypotheses, along with <code><a href="../.././Init/Prelude.html#rfl">rfl</a></code>, <code><a href="../.././Init/Core.html#trivial">trivial</a></code>, <code><a href="../.././Init/Prelude.html#congrFun">congrFun</a></code>
and <code><a href="../.././Init/Prelude.html#congrArg">congrArg</a></code>.</li>
<li>The flag <code>noDefaults</code> removes these.</li>
<li>The flag <code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.star">star</a></code> includes all local hypotheses, but not <code><a href="../.././Init/Prelude.html#rfl">rfl</a></code>, <code><a href="../.././Init/Core.html#trivial">trivial</a></code>, <code><a href="../.././Init/Prelude.html#congrFun">congrFun</a></code>,
or <code><a href="../.././Init/Prelude.html#congrArg">congrArg</a></code>. (It doesn't make sense to use <code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.star">star</a></code> without <code>noDefaults</code>.)</li>
<li>The argument <code>add</code> is the list of terms inside the square brackets that did not have <code>-</code>
and can be used to add expressions or local hypotheses</li>
<li>The argument <code>remove</code> is the list of terms inside the square brackets that had a <code>-</code>,
and can be used to remove local hypotheses.
(It doesn't make sense to remove expressions which are not local hypotheses,
to remove local hypotheses unless <code>!noDefaults || <a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.star">star</a></code>,
and it does not make sense to use <code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.star">star</a></code> unless you remove at least one local hypothesis.)</li>
</ul><p><code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.mkAssumptionSet">mkAssumptionSet</a></code> returns not a <code><a href="../.././Init/Prelude.html#List">List</a> expr</code>, but a <code><a href="../.././Init/Prelude.html#List">List</a> (TermElabM Expr) × TermElabM (List Expr)</code>.
There are two separate problems that need to be solved.</p><h3 class="markdown-heading" id="Stuck-metavariables">Stuck metavariables <a class="hover-link" href="#Stuck-metavariables">#</a></h3><p>Lemmas with implicit arguments would be filled in with metavariables if we created the
<code>Expr</code> objects immediately, so instead we return thunks that generate the expressions
on demand. This is the first component, with type <code><a href="../.././Init/Prelude.html#List">List</a> (TermElabM expr)</code>.</p><p>As an example, we have <code>def <a href="../.././Init/Prelude.html#rfl">rfl</a> : ∀ {α : Sort u} {a : α}, a = a</code>, which on elaboration will become
<code>@rfl ?m_1 ?m_2</code>.</p><p>Because <code>solve_by_elim</code> works by repeated application of lemmas against subgoals,
the first time such a lemma is successfully applied,
those metavariables will be unified, and thereafter have fixed values.
This would make it impossible to apply the lemma
a second time with different values of the metavariables.</p><p>See https://github.com/leanprover-community/mathlib/issues/2269</p><h3 class="markdown-heading" id="Relevant-local-hypotheses">Relevant local hypotheses <a class="hover-link" href="#Relevant-local-hypotheses">#</a></h3><p><code>solve_by_elim*</code> works with multiple goals,
and we need to use separate sets of local hypotheses for each goal.
The second component of the returned value provides these local hypotheses.
(Essentially using <code>local_context</code>, along with some filtering to remove hypotheses
that have been explicitly removed via <code>only</code> or <code>[-h]</code>.)</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.Tactic.SolveByElim.mkAssumptionSet" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.mkAssumptionSet.elab'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L369-L369">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.mkAssumptionSet.elab'"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">mkAssumptionSet</span>.<span class="name">elab'</span></a></span><span class="decl_args">
<span class="fn">(t : <a href="../.././Init/Meta.html#Lean.Syntax.Term">Lean.Term</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.TermElabM">Lean.Elab.TermElabM</a> <a href="../.././Lean/Expr.html#Lean.Expr">Lean.Expr</a></span></div></div><p>Run <code>elabTerm</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.mkAssumptionSet.elab'">Std.Tactic.SolveByElim.mkAssumptionSet.elab'</a> <span class="fn">t</span></span> <a href="../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../.././Lean/Elab/Term.html#Lean.Elab.Term.elabTerm">Lean.Elab.Term.elabTerm</a> <span class="fn"><span class="fn">t</span>.raw</span> <span class="fn">none</span> <a href="../.././Init/Prelude.html#Bool.true">true</a> <a href="../.././Init/Prelude.html#Bool.true">true</a></span></span></li></ul></details><details id="instances-for-list-Std.Tactic.SolveByElim.mkAssumptionSet.elab'" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.erase"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L371-L372">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.erase"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">erase</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Syntax for omitting a local hypothesis in <code>solve_by_elim</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.Tactic.SolveByElim.erase" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.star"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L373-L374">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.star"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">star</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Syntax for including all local hypotheses in <code>solve_by_elim</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.star">Std.Tactic.SolveByElim.star</a> <a href="../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">&quot;star&quot;</span> <span class="fn">`Std.Tactic.SolveByElim.star</span> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;*&quot;</span></span>)</span></span></span></li></ul></details><details id="instances-for-list-Std.Tactic.SolveByElim.star" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.arg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L375-L376">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.arg"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">arg</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Syntax for adding or removing a term, or <code>*</code>, in <code>solve_by_elim</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.Tactic.SolveByElim.arg" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.args"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L377-L378">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.args"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">args</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Syntax for adding and removing terms in <code>solve_by_elim</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.Tactic.SolveByElim.args" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.using_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L379-L380">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.using_"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">using_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p>Syntax for using all lemmas labelled with an attribute in <code>solve_by_elim</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.Tactic.SolveByElim.using_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.parseArgs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L390-L405">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.parseArgs"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">parseArgs</span></a></span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`Std.Tactic.SolveByElim.args</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Bool">Bool</a> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn"><span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Init/Meta.html#Lean.Syntax.Term">Lean.Term</a></span> <a href="../.././Init/Prelude.html#Prod">×</a> <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Init/Meta.html#Lean.Syntax.Term">Lean.Term</a></span></span></span></div></div><p>Parse the lemma argument of a call to <code>solve_by_elim</code>.
The first component should be true if <code>*</code> appears at least once.
The second component should contain each term <code>t</code>in the arguments.
The third component should contain <code>t</code> for each <code>-t</code> in the arguments.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.Tactic.SolveByElim.parseArgs" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.parseUsing"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L408-L413">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.parseUsing"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">parseUsing</span></a></span><span class="decl_args">
<span class="fn">(s : <span class="fn"><a href="../.././Init/Prelude.html#Option">Option</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">`Std.Tactic.SolveByElim.using_</span></span>)</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Init/Meta.html#Lean.Syntax.Ident">Lean.Ident</a></span></div></div><p>Parse the <code>using ...</code> argument for <code>solve_by_elim</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.Tactic.SolveByElim.parseUsing" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.solveByElimSyntax"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L415-L453">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.solveByElimSyntax"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">solveByElimSyntax</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>solve_by_elim</code> calls <code>apply</code> on the main goal to find an assumption whose head matches
and then repeatedly calls <code>apply</code> on the generated subgoals until no subgoals remain,
performing at most <code>maxDepth</code> (defaults to 6) recursive steps.</p><p><code>solve_by_elim</code> discharges the current goal or fails.</p><p><code>solve_by_elim</code> performs backtracking if subgoals can not be solved.</p><p>By default, the assumptions passed to <code>apply</code> are the local context, <code><a href="../.././Init/Prelude.html#rfl">rfl</a></code>, <code><a href="../.././Init/Core.html#trivial">trivial</a></code>,
<code><a href="../.././Init/Prelude.html#congrFun">congrFun</a></code> and <code><a href="../.././Init/Prelude.html#congrArg">congrArg</a></code>.</p><p>The assumptions can be modified with similar syntax as for <code>simp</code>:</p><ul>
<li><code>solve_by_elim [h₁, h₂, ..., hᵣ]</code> also applies the given expressions.</li>
<li><code>solve_by_elim only [h₁, h₂, ..., hᵣ]</code> does not include the local context,
<code><a href="../.././Init/Prelude.html#rfl">rfl</a></code>, <code><a href="../.././Init/Core.html#trivial">trivial</a></code>, <code><a href="../.././Init/Prelude.html#congrFun">congrFun</a></code>, or <code><a href="../.././Init/Prelude.html#congrArg">congrArg</a></code> unless they are explicitly included.</li>
<li><code>solve_by_elim [-h₁, ... -hₙ]</code> removes the given local hypotheses.</li>
<li><code>solve_by_elim using [a₁, ...]</code> uses all lemmas which have been labelled
with the attributes <code>aᵢ</code> (these attributes must be created using <code>register_label_attr</code>).</li>
</ul><p><code>solve_by_elim*</code> tries to solve all goals together, using backtracking if a solution for one goal
makes other goals impossible.
(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)</p><p>Optional arguments passed via a configuration argument as <code>solve_by_elim (config := { ... })</code></p><ul>
<li><code>maxDepth</code>: number of attempts at discharging generated subgoals</li>
<li><code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig.symm">symm</a></code>: adds all hypotheses derived by <code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig.symm">symm</a></code> (defaults to <code>true</code>).</li>
<li><code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig.exfalso">exfalso</a></code>: allow calling <code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig.exfalso">exfalso</a></code> and trying again if <code>solve_by_elim</code> fails
(defaults to <code>true</code>).</li>
<li><code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig.transparency">transparency</a></code>: change the transparency mode when calling <code>apply</code>. Defaults to <code>.default</code>,
but it is often useful to change to <code>.reducible</code>,
so semireducible definitions will not be unfolded when trying to apply a lemma.</li>
</ul><p>See also the doc-comment for <code><a href="../.././Std/Tactic/SolveByElim/Backtrack.html#Std.Tactic.BacktrackConfig">Std.Tactic.BacktrackConfig</a></code> for the options
<code>proc</code>, <code>suspend</code>, and <code>discharge</code> which allow further customization of <code>solve_by_elim</code>.
Both <code>apply_assumption</code> and <code>apply_rules</code> are implemented via these hooks.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.Tactic.SolveByElim.solveByElimSyntax" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.solveByElim.processSyntax"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L457-L462">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.solveByElim.processSyntax"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">solveByElim</span>.<span class="name">processSyntax</span></a></span><span class="decl_args">
<span class="fn">(cfg : <span class="fn"><a href="../.././Init/Prelude.html#optParam">optParam</a> <a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.Config">Std.Tactic.SolveByElim.Config</a>
  <span class="fn">{
    <span class="fn">toApplyRulesConfig</span> :=
      <span class="fn">{
        <span class="fn">toBacktrackConfig</span> :=
          <span class="fn">{ <span class="fn">maxDepth</span> := <span class="fn">6</span>, <span class="fn">proc</span> := <span class="fn">fun (<span class="fn">x</span> x : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span>) =&gt; <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">none</span></span></span>,
            <span class="fn">suspend</span> := <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn"><a href="../.././Init/Prelude.html#Pure.pure">pure</a> <a href="../.././Init/Prelude.html#Bool.false">false</a></span></span>, <span class="fn">discharge</span> := <span class="fn">fun (<span class="fn">x</span> : <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a>) =&gt; <span class="fn">failure</span></span>,
            <span class="fn">commitIndependentGoals</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a> }</span>,
        <span class="fn">toApplyConfig</span> :=
          <span class="fn">{ <span class="fn">newGoals</span> := <a href="../.././Lean/Meta/Tactic/Apply.html#Lean.Meta.ApplyNewGoals.nonDependentFirst">Lean.Meta.ApplyNewGoals.nonDependentFirst</a>, <span class="fn">synthAssignedInstances</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>,
            <span class="fn">allowSynthFailures</span> := <a href="../.././Init/Prelude.html#Bool.false">false</a>, <span class="fn">approx</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span>,
        <span class="fn">transparency</span> := <a href="../.././Init/MetaTypes.html#Lean.Meta.TransparencyMode.default">Lean.Meta.TransparencyMode.default</a>, <span class="fn">symm</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a>, <span class="fn">exfalso</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span>,
    <span class="fn">backtracking</span> := <a href="../.././Init/Prelude.html#Bool.true">true</a> }</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(only : <a href="../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(star : <a href="../.././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(add : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Init/Meta.html#Lean.Syntax.Term">Lean.Term</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(remove : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Init/Meta.html#Lean.Syntax.Term">Lean.Term</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(use : <span class="fn"><a href="../.././Init/Prelude.html#Array">Array</a> <a href="../.././Init/Meta.html#Lean.Syntax.Ident">Lean.Ident</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(goals : <span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../.././Lean/Meta/Basic.html#Lean.Meta.MetaM">Lean.MetaM</a> <span class="fn">(<span class="fn"><a href="../.././Init/Prelude.html#List">List</a> <a href="../.././Lean/Expr.html#Lean.MVarId">Lean.MVarId</a></span>)</span></span></div></div><p>Wrapper for <code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.solveByElim">solveByElim</a></code> that processes a list of <code>Term</code>s
that specify the lemmas to use.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.Tactic.SolveByElim.solveByElim.processSyntax" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.applyAssumptionSyntax"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L477-L498">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.applyAssumptionSyntax"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">applyAssumptionSyntax</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>apply_assumption</code> looks for an assumption of the form <code>... → ∀ _, ... → head</code>
where <code>head</code> matches the current goal.</p><p>You can specify additional rules to apply using <code>apply_assumption [...]</code>.
By default <code>apply_assumption</code> will also try <code><a href="../.././Init/Prelude.html#rfl">rfl</a></code>, <code><a href="../.././Init/Core.html#trivial">trivial</a></code>, <code><a href="../.././Init/Prelude.html#congrFun">congrFun</a></code>, and <code><a href="../.././Init/Prelude.html#congrArg">congrArg</a></code>.
If you don't want these, or don't want to use all hypotheses, use <code>apply_assumption only [...]</code>.
You can use <code>apply_assumption [-h]</code> to omit a local hypothesis.
You can use <code>apply_assumption using [a₁, ...]</code> to use all lemmas which have been labelled
with the attributes <code>aᵢ</code> (these attributes must be created using <code>register_label_attr</code>).</p><p><code>apply_assumption</code> will use consequences of local hypotheses obtained via <code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig.symm">symm</a></code>.</p><p>If <code>apply_assumption</code> fails, it will call <code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig.exfalso">exfalso</a></code> and try again.
Thus if there is an assumption of the form <code>P → ¬ Q</code>, the new tactic state
will have two goals, <code>P</code> and <code>Q</code>.</p><p>You can pass a further configuration via the syntax <code>apply_rules (config := {...}) lemmas</code>.
The options supported are the same as for <code>solve_by_elim</code> (and include all the options for <code>apply</code>).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.Tactic.SolveByElim.applyAssumptionSyntax" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Std.Tactic.SolveByElim.applyRulesSyntax"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/std4/blob/0d0ac1c43e1ec1965e0806af9e7a32999ea31096/Std/Tactic/SolveByElim.lean#L510-L533">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.applyRulesSyntax"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">SolveByElim</span>.<span class="name">applyRulesSyntax</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../.././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div><p><code>apply_rules [l₁, l₂, ...]</code> tries to solve the main goal by iteratively
applying the list of lemmas <code>[l₁, l₂, ...]</code> or by applying a local hypothesis.
If <code>apply</code> generates new goals, <code>apply_rules</code> iteratively tries to solve those goals.
You can use <code>apply_rules [-h]</code> to omit a local hypothesis.</p><p><code>apply_rules</code> will also use <code><a href="../.././Init/Prelude.html#rfl">rfl</a></code>, <code><a href="../.././Init/Core.html#trivial">trivial</a></code>, <code><a href="../.././Init/Prelude.html#congrFun">congrFun</a></code> and <code><a href="../.././Init/Prelude.html#congrArg">congrArg</a></code>.
These can be disabled, as can local hypotheses, by using <code>apply_rules only [...]</code>.</p><p>You can use <code>apply_rules using [a₁, ...]</code> to use all lemmas which have been labelled
with the attributes <code>aᵢ</code> (these attributes must be created using <code>register_label_attr</code>).</p><p>You can pass a further configuration via the syntax <code>apply_rules (config := {...})</code>.
The options supported are the same as for <code>solve_by_elim</code> (and include all the options for <code>apply</code>).</p><p><code>apply_rules</code> will try calling <code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig.symm">symm</a></code> on hypotheses and <code><a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig.exfalso">exfalso</a></code> on the goal as needed.
This can be disabled with <code>apply_rules (config := {symm := false, <a href="../.././Std/Tactic/SolveByElim.html#Std.Tactic.SolveByElim.ApplyRulesConfig.exfalso">exfalso</a> := false})</code>.</p><p>You can bound the iteration depth using the syntax <code>apply_rules (config := {maxDepth := n})</code>.</p><p>Unlike <code>solve_by_elim</code>, <code>apply_rules</code> does not perform backtracking, and greedily applies
a lemma from the list until it gets stuck.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Std.Tactic.SolveByElim.applyRulesSyntax" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>